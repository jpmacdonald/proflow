// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transition {
    #[prost(bool, tag = "1")]
    pub is_default: bool,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VisualMedia {
    #[prost(enumeration = "visual_media::Behavior", tag = "1")]
    pub behavior: i32,
    #[prost(enumeration = "visual_media::ScaleMode", tag = "2")]
    pub scale_mode: i32,
    #[prost(enumeration = "visual_media::FlipMode", tag = "3")]
    pub flip_mode: i32,
    #[prost(enumeration = "visual_media::NativeRotation", tag = "4")]
    pub native_rotation: i32,
    #[prost(message, optional, tag = "5")]
    pub resolution: ::core::option::Option<visual_media::Size>,
    #[prost(uint32, tag = "6")]
    pub enabled_effects_count: u32,
    #[prost(bool, tag = "7")]
    pub has_effect_preset: bool,
    #[prost(message, optional, tag = "8")]
    pub transition: ::core::option::Option<Transition>,
}
/// Nested message and enum types in `VisualMedia`.
pub mod visual_media {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Size {
        #[prost(uint32, tag = "1")]
        pub width: u32,
        #[prost(uint32, tag = "2")]
        pub height: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Behavior {
        Background = 0,
        Foreground = 1,
        VideoInput = 2,
    }
    impl Behavior {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Behavior::Background => "BACKGROUND",
                Behavior::Foreground => "FOREGROUND",
                Behavior::VideoInput => "VIDEO_INPUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKGROUND" => Some(Self::Background),
                "FOREGROUND" => Some(Self::Foreground),
                "VIDEO_INPUT" => Some(Self::VideoInput),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScaleMode {
        Fit = 0,
        Fill = 1,
        Stretch = 2,
        Blur = 3,
    }
    impl ScaleMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ScaleMode::Fit => "FIT",
                ScaleMode::Fill => "FILL",
                ScaleMode::Stretch => "STRETCH",
                ScaleMode::Blur => "BLUR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIT" => Some(Self::Fit),
                "FILL" => Some(Self::Fill),
                "STRETCH" => Some(Self::Stretch),
                "BLUR" => Some(Self::Blur),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FlipMode {
        None = 0,
        Horizontal = 1,
        Vertical = 2,
        Both = 3,
    }
    impl FlipMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FlipMode::None => "NONE",
                FlipMode::Horizontal => "HORIZONTAL",
                FlipMode::Vertical => "VERTICAL",
                FlipMode::Both => "BOTH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "HORIZONTAL" => Some(Self::Horizontal),
                "VERTICAL" => Some(Self::Vertical),
                "BOTH" => Some(Self::Both),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NativeRotation {
        Standard = 0,
        _90 = 90,
        _180 = 180,
        _270 = 270,
    }
    impl NativeRotation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NativeRotation::Standard => "STANDARD",
                NativeRotation::_90 => "_90",
                NativeRotation::_180 => "_180",
                NativeRotation::_270 => "_270",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STANDARD" => Some(Self::Standard),
                "_90" => Some(Self::_90),
                "_180" => Some(Self::_180),
                "_270" => Some(Self::_270),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transport {
    #[prost(enumeration = "transport::DurationRange", tag = "1")]
    pub source_duration_range: i32,
    #[prost(bool, tag = "2")]
    pub has_audio_ramp_in: bool,
    #[prost(bool, tag = "3")]
    pub has_audio_ramp_out: bool,
    #[prost(bool, tag = "4")]
    pub has_in_point: bool,
    #[prost(bool, tag = "5")]
    pub has_out_point: bool,
    #[prost(double, tag = "6")]
    pub play_rate: f64,
    #[prost(uint32, tag = "7")]
    pub playback_marker_count: u32,
}
/// Nested message and enum types in `Transport`.
pub mod transport {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DurationRange {
        Under10s = 0,
        _10sTo30s = 1,
        _30sTo60s = 2,
        _1mTo5m = 3,
        _5mTo10m = 4,
        _10mTo30m = 5,
        _30mTo60m = 6,
        _1hTo2h = 7,
        Over2h = 8,
    }
    impl DurationRange {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DurationRange::Under10s => "UNDER_10S",
                DurationRange::_10sTo30s => "_10S_TO_30S",
                DurationRange::_30sTo60s => "_30S_TO_60S",
                DurationRange::_1mTo5m => "_1M_TO_5M",
                DurationRange::_5mTo10m => "_5M_TO_10M",
                DurationRange::_10mTo30m => "_10M_TO_30M",
                DurationRange::_30mTo60m => "_30M_TO_60M",
                DurationRange::_1hTo2h => "_1H_TO_2H",
                DurationRange::Over2h => "OVER_2H",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDER_10S" => Some(Self::Under10s),
                "_10S_TO_30S" => Some(Self::_10sTo30s),
                "_30S_TO_60S" => Some(Self::_30sTo60s),
                "_1M_TO_5M" => Some(Self::_1mTo5m),
                "_5M_TO_10M" => Some(Self::_5mTo10m),
                "_10M_TO_30M" => Some(Self::_10mTo30m),
                "_30M_TO_60M" => Some(Self::_30mTo60m),
                "_1H_TO_2H" => Some(Self::_1hTo2h),
                "OVER_2H" => Some(Self::Over2h),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Video {
    #[prost(message, optional, tag = "7")]
    pub visual_media: ::core::option::Option<VisualMedia>,
    #[prost(enumeration = "video::PlaybackBehavior", tag = "8")]
    pub playback_behavior: i32,
    #[prost(enumeration = "CompletionTarget", tag = "9")]
    pub completion_target: i32,
    #[prost(bool, tag = "10")]
    pub soft_loop_enabled: bool,
    #[prost(double, tag = "11")]
    pub soft_loop_duration: f64,
    #[prost(double, tag = "12")]
    pub frame_rate: f64,
    #[prost(uint32, tag = "13")]
    pub audio_channel_count: u32,
    #[prost(message, optional, tag = "14")]
    pub transport: ::core::option::Option<Transport>,
    #[prost(enumeration = "SourceType", tag = "15")]
    pub source_type: i32,
}
/// Nested message and enum types in `Video`.
pub mod video {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlaybackBehavior {
        Stop = 0,
        Loop = 1,
        LoopForPlayCount = 2,
        LoopForTime = 3,
    }
    impl PlaybackBehavior {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PlaybackBehavior::Stop => "STOP",
                PlaybackBehavior::Loop => "LOOP",
                PlaybackBehavior::LoopForPlayCount => "LOOP_FOR_PLAY_COUNT",
                PlaybackBehavior::LoopForTime => "LOOP_FOR_TIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STOP" => Some(Self::Stop),
                "LOOP" => Some(Self::Loop),
                "LOOP_FOR_PLAY_COUNT" => Some(Self::LoopForPlayCount),
                "LOOP_FOR_TIME" => Some(Self::LoopForTime),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Audio {
    #[prost(enumeration = "audio::Behavior", tag = "1")]
    pub behavior: i32,
    #[prost(enumeration = "audio::PlaybackBehavior", tag = "2")]
    pub playback_behavior: i32,
    #[prost(message, optional, tag = "3")]
    pub transition: ::core::option::Option<Transition>,
    #[prost(uint32, tag = "4")]
    pub audio_channel_count: u32,
    #[prost(message, optional, tag = "5")]
    pub transport: ::core::option::Option<Transport>,
    #[prost(enumeration = "SourceType", tag = "6")]
    pub source_type: i32,
}
/// Nested message and enum types in `Audio`.
pub mod audio {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Behavior {
        Tune = 0,
        Sound = 1,
    }
    impl Behavior {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Behavior::Tune => "TUNE",
                Behavior::Sound => "SOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TUNE" => Some(Self::Tune),
                "SOUND" => Some(Self::Sound),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlaybackBehavior {
        Stop = 0,
        Loop = 1,
        Next = 2,
    }
    impl PlaybackBehavior {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PlaybackBehavior::Stop => "STOP",
                PlaybackBehavior::Loop => "LOOP",
                PlaybackBehavior::Next => "NEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STOP" => Some(Self::Stop),
                "LOOP" => Some(Self::Loop),
                "NEXT" => Some(Self::Next),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    #[prost(message, optional, tag = "1")]
    pub visual_media: ::core::option::Option<VisualMedia>,
    #[prost(enumeration = "CompletionTarget", tag = "2")]
    pub completion_target: i32,
    #[prost(enumeration = "SourceType", tag = "3")]
    pub source_type: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoInput {
    #[prost(message, optional, tag = "1")]
    pub visual_media: ::core::option::Option<VisualMedia>,
    #[prost(double, tag = "2")]
    pub frame_rate: f64,
    #[prost(uint32, tag = "3")]
    pub audio_channel_count: u32,
    #[prost(enumeration = "SourceType", tag = "4")]
    pub source_type: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AirCastVideo {
    #[prost(bool, tag = "1")]
    pub password_enabled: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AirCastAudio {
    #[prost(bool, tag = "1")]
    pub password_enabled: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompletionTarget {
    None = 0,
    Next = 1,
    Random = 2,
    Cue = 3,
    First = 4,
}
impl CompletionTarget {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CompletionTarget::None => "NONE",
            CompletionTarget::Next => "NEXT",
            CompletionTarget::Random => "RANDOM",
            CompletionTarget::Cue => "CUE",
            CompletionTarget::First => "FIRST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "NEXT" => Some(Self::Next),
            "RANDOM" => Some(Self::Random),
            "CUE" => Some(Self::Cue),
            "FIRST" => Some(Self::First),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SourceType {
    Local = 0,
    Procontent = 1,
}
impl SourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SourceType::Local => "LOCAL",
            SourceType::Procontent => "PROCONTENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOCAL" => Some(Self::Local),
            "PROCONTENT" => Some(Self::Procontent),
            _ => None,
        }
    }
}
