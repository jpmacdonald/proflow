// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericEvent {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationLaunch {
    #[prost(string, tag = "1")]
    pub hardware_id: ::prost::alloc::string::String,
    #[prost(enumeration = "application_launch::Channel", tag = "2")]
    pub channel: i32,
    #[prost(enumeration = "application_launch::Platform", tag = "3")]
    pub platform: i32,
    #[prost(string, tag = "4")]
    pub app_version: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub os_version: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub build_number: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub language: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub hardware_model: ::prost::alloc::string::String,
    #[prost(uint64, tag = "10")]
    pub physical_memory: u64,
    #[prost(string, tag = "11")]
    pub video_controller: ::prost::alloc::string::String,
    #[prost(uint64, tag = "12")]
    pub video_controller_ram: u64,
}
/// Nested message and enum types in `ApplicationLaunch`.
pub mod application_launch {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Channel {
        Beta = 0,
        Release = 1,
    }
    impl Channel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Channel::Beta => "BETA",
                Channel::Release => "RELEASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BETA" => Some(Self::Beta),
                "RELEASE" => Some(Self::Release),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Platform {
        Windows = 0,
        Macos = 1,
    }
    impl Platform {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Platform::Windows => "WINDOWS",
                Platform::Macos => "MACOS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WINDOWS" => Some(Self::Windows),
                "MACOS" => Some(Self::Macos),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoInputTriggered {
    #[prost(enumeration = "video_input_triggered::AudioSource", tag = "1")]
    pub audio_source: i32,
}
/// Nested message and enum types in `VideoInputTriggered`.
pub mod video_input_triggered {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudioSource {
        None = 0,
        Self_ = 1,
        Other = 2,
    }
    impl AudioSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AudioSource::None => "NONE",
                AudioSource::Self_ => "SELF",
                AudioSource::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "SELF" => Some(Self::Self_),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoInputCustomMap {
    #[prost(bool, tag = "1")]
    pub value: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoInputStartUp {
    #[prost(uint32, tag = "1")]
    pub input_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoInputThumbnailUpdate {
    #[prost(enumeration = "video_input_thumbnail_update::UpdateType", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `VideoInputThumbnailUpdate`.
pub mod video_input_thumbnail_update {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UpdateType {
        Capture = 0,
        Disk = 1,
        Reset = 2,
    }
    impl UpdateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UpdateType::Capture => "CAPTURE",
                UpdateType::Disk => "DISK",
                UpdateType::Reset => "RESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CAPTURE" => Some(Self::Capture),
                "DISK" => Some(Self::Disk),
                "RESET" => Some(Self::Reset),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioInputAutoOnChange {
    #[prost(uint32, tag = "1")]
    pub input_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioSettingsSdiNdiActive {
    #[prost(bool, tag = "1")]
    pub value: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioSettingsCustomMap {
    #[prost(bool, tag = "1")]
    pub value: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioInputModeSelection {
    #[prost(enumeration = "audio_input_mode_selection::ModeType", tag = "1")]
    pub mode_type: i32,
}
/// Nested message and enum types in `AudioInputModeSelection`.
pub mod audio_input_mode_selection {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ModeType {
        On = 0,
        Off = 1,
        Autooff = 2,
        Autoon = 3,
    }
    impl ModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ModeType::On => "ON",
                ModeType::Off => "OFF",
                ModeType::Autooff => "AUTOOFF",
                ModeType::Autoon => "AUTOON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ON" => Some(Self::On),
                "OFF" => Some(Self::Off),
                "AUTOOFF" => Some(Self::Autooff),
                "AUTOON" => Some(Self::Autoon),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioInputAutoOnStartup {
    #[prost(uint32, tag = "1")]
    pub input_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioSettingsSdiNdiState {
    #[prost(uint32, tag = "1")]
    pub bus_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioInputStartUp {
    #[prost(uint32, tag = "1")]
    pub total_input_count: u32,
    #[prost(uint32, tag = "2")]
    pub on_input_count: u32,
    #[prost(uint32, tag = "3")]
    pub off_input_count: u32,
    #[prost(uint32, tag = "4")]
    pub auto_on_input_count: u32,
    #[prost(uint32, tag = "5")]
    pub auto_off_input_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CueTriggered {
    #[prost(double, tag = "1")]
    pub trigger_delay: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputAudioMonitoring {
    #[prost(enumeration = "input_audio_monitoring::InputType", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `InputAudioMonitoring`.
pub mod input_audio_monitoring {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InputType {
        Audio = 0,
        Video = 1,
    }
    impl InputType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InputType::Audio => "AUDIO",
                InputType::Video => "VIDEO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResiStartUp {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResiLoginChange {
    #[prost(enumeration = "resi_login_change::LoginState", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `ResiLoginChange`.
pub mod resi_login_change {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoginState {
        Loggedin = 0,
        Loggedout = 1,
    }
    impl LoginState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LoginState::Loggedin => "LOGGEDIN",
                LoginState::Loggedout => "LOGGEDOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOGGEDIN" => Some(Self::Loggedin),
                "LOGGEDOUT" => Some(Self::Loggedout),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteStreamStart {
    #[prost(enumeration = "remote_stream_start::StartResult", tag = "1")]
    pub result: i32,
}
/// Nested message and enum types in `RemoteStreamStart`.
pub mod remote_stream_start {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StartResult {
        Success = 0,
        Failed = 1,
        Usercanceled = 2,
    }
    impl StartResult {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StartResult::Success => "SUCCESS",
                StartResult::Failed => "FAILED",
                StartResult::Usercanceled => "USERCANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "FAILED" => Some(Self::Failed),
                "USERCANCELED" => Some(Self::Usercanceled),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteStreamStop {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartCaptureDisk {
    #[prost(enumeration = "Codec", tag = "1")]
    pub codec: i32,
    #[prost(uint32, tag = "2")]
    pub resolution_width: u32,
    #[prost(uint32, tag = "3")]
    pub resolution_height: u32,
    #[prost(enumeration = "FrameRate", tag = "4")]
    pub frame_rate: i32,
    #[prost(bool, tag = "5")]
    pub stream_started: bool,
    #[prost(uint32, tag = "6")]
    pub video_bitrate: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartCaptureRtmp {
    #[prost(enumeration = "Codec", tag = "1")]
    pub codec: i32,
    #[prost(uint32, tag = "2")]
    pub resolution_width: u32,
    #[prost(uint32, tag = "3")]
    pub resolution_height: u32,
    #[prost(enumeration = "FrameRate", tag = "4")]
    pub frame_rate: i32,
    #[prost(bool, tag = "5")]
    pub stream_started: bool,
    #[prost(uint32, tag = "6")]
    pub video_bitrate: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartCaptureResi {
    #[prost(enumeration = "Codec", tag = "1")]
    pub codec: i32,
    #[prost(uint32, tag = "2")]
    pub resolution_width: u32,
    #[prost(uint32, tag = "3")]
    pub resolution_height: u32,
    #[prost(enumeration = "FrameRate", tag = "4")]
    pub frame_rate: i32,
    #[prost(bool, tag = "5")]
    pub stream_started: bool,
    #[prost(uint32, tag = "6")]
    pub video_bitrate: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopCapture {
    #[prost(double, tag = "1")]
    pub duration: f64,
    #[prost(int32, tag = "2")]
    pub dropped_frames: i32,
    #[prost(double, tag = "3")]
    pub percent_dropped_frames: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Print {
    #[prost(uint32, tag = "1")]
    pub document_count: u32,
    #[prost(enumeration = "print::PrintMode", tag = "2")]
    pub mode: i32,
    #[prost(bool, tag = "3")]
    pub include_metadata: bool,
    #[prost(bool, tag = "4")]
    pub include_presentation_notes: bool,
    #[prost(bool, tag = "5")]
    pub include_current_date: bool,
    #[prost(bool, tag = "6")]
    pub include_slide_labels: bool,
    #[prost(bool, tag = "7")]
    pub include_slide_notes: bool,
    #[prost(bool, tag = "8")]
    pub include_disabled_slides: bool,
    #[prost(uint32, tag = "9")]
    pub number_columns: u32,
    #[prost(string, tag = "10")]
    pub print_to_device: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Print`.
pub mod print {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PrintMode {
        Thumbnail = 0,
        Outline = 1,
    }
    impl PrintMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PrintMode::Thumbnail => "THUMBNAIL",
                PrintMode::Outline => "OUTLINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "THUMBNAIL" => Some(Self::Thumbnail),
                "OUTLINE" => Some(Self::Outline),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Device {
    #[prost(string, tag = "1")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub device_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub device_protocol: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Downgrade {
    #[prost(enumeration = "downgrade::FromVersionType", tag = "1")]
    pub from_version_type: i32,
}
/// Nested message and enum types in `Downgrade`.
pub mod downgrade {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FromVersionType {
        Unknown = 0,
        Beta = 1,
        Release = 2,
    }
    impl FromVersionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FromVersionType::Unknown => "FROM_VERSION_TYPE_UNKNOWN",
                FromVersionType::Beta => "FROM_VERSION_TYPE_BETA",
                FromVersionType::Release => "FROM_VERSION_TYPE_RELEASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FROM_VERSION_TYPE_UNKNOWN" => Some(Self::Unknown),
                "FROM_VERSION_TYPE_BETA" => Some(Self::Beta),
                "FROM_VERSION_TYPE_RELEASE" => Some(Self::Release),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcliReport {
    #[prost(enumeration = "ccli_report::Action", tag = "1")]
    pub action: i32,
}
/// Nested message and enum types in `CCLIReport`.
pub mod ccli_report {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        ReportWindowOpened = 0,
        ReportCleared = 1,
        ReportExported = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::ReportWindowOpened => "REPORT_WINDOW_OPENED",
                Action::ReportCleared => "REPORT_CLEARED",
                Action::ReportExported => "REPORT_EXPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REPORT_WINDOW_OPENED" => Some(Self::ReportWindowOpened),
                "REPORT_CLEARED" => Some(Self::ReportCleared),
                "REPORT_EXPORTED" => Some(Self::ReportExported),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransitionWindow {
    #[prost(uint32, tag = "1")]
    pub duration_seconds: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditorObjectAdded {
    #[prost(enumeration = "editor_object_added::FromInsertionSource", tag = "1")]
    pub from_insertion_source: i32,
    #[prost(enumeration = "editor_object_added::InsertedType", tag = "2")]
    pub inserted_type: i32,
}
/// Nested message and enum types in `EditorObjectAdded`.
pub mod editor_object_added {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FromInsertionSource {
        EditorToolbar = 0,
        EditorMainMenu = 1,
        EditorHotkey = 2,
        EditorCopyPaste = 3,
    }
    impl FromInsertionSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FromInsertionSource::EditorToolbar => "EDITOR_TOOLBAR",
                FromInsertionSource::EditorMainMenu => "EDITOR_MAIN_MENU",
                FromInsertionSource::EditorHotkey => "EDITOR_HOTKEY",
                FromInsertionSource::EditorCopyPaste => "EDITOR_COPY_PASTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EDITOR_TOOLBAR" => Some(Self::EditorToolbar),
                "EDITOR_MAIN_MENU" => Some(Self::EditorMainMenu),
                "EDITOR_HOTKEY" => Some(Self::EditorHotkey),
                "EDITOR_COPY_PASTE" => Some(Self::EditorCopyPaste),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InsertedType {
        EditorText = 0,
        EditorShape = 1,
        EditorCustomShape = 2,
        EditorMedia = 3,
        EditorVideoInput = 4,
        EditorWeb = 5,
        EditorCurrentSlide = 6,
        EditorNextSlide = 7,
        EditorScreenPreview = 8,
        EditorTimer = 9,
        EditorSystemClock = 10,
        EditorVideoCountdown = 11,
        EditorAudioCountdown = 12,
        EditorPlaybackMarker = 13,
        EditorChordChart = 14,
        EditorStageMessage = 15,
        EditorPlanningCenterLive = 16,
        EditorTimecode = 17,
        EditorGroup = 18,
        EditorLabel = 19,
        EditorCaptureStatus = 20,
    }
    impl InsertedType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InsertedType::EditorText => "EDITOR_TEXT",
                InsertedType::EditorShape => "EDITOR_SHAPE",
                InsertedType::EditorCustomShape => "EDITOR_CUSTOM_SHAPE",
                InsertedType::EditorMedia => "EDITOR_MEDIA",
                InsertedType::EditorVideoInput => "EDITOR_VIDEO_INPUT",
                InsertedType::EditorWeb => "EDITOR_WEB",
                InsertedType::EditorCurrentSlide => "EDITOR_CURRENT_SLIDE",
                InsertedType::EditorNextSlide => "EDITOR_NEXT_SLIDE",
                InsertedType::EditorScreenPreview => "EDITOR_SCREEN_PREVIEW",
                InsertedType::EditorTimer => "EDITOR_TIMER",
                InsertedType::EditorSystemClock => "EDITOR_SYSTEM_CLOCK",
                InsertedType::EditorVideoCountdown => "EDITOR_VIDEO_COUNTDOWN",
                InsertedType::EditorAudioCountdown => "EDITOR_AUDIO_COUNTDOWN",
                InsertedType::EditorPlaybackMarker => "EDITOR_PLAYBACK_MARKER",
                InsertedType::EditorChordChart => "EDITOR_CHORD_CHART",
                InsertedType::EditorStageMessage => "EDITOR_STAGE_MESSAGE",
                InsertedType::EditorPlanningCenterLive => "EDITOR_PLANNING_CENTER_LIVE",
                InsertedType::EditorTimecode => "EDITOR_TIMECODE",
                InsertedType::EditorGroup => "EDITOR_GROUP",
                InsertedType::EditorLabel => "EDITOR_LABEL",
                InsertedType::EditorCaptureStatus => "EDITOR_CAPTURE_STATUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EDITOR_TEXT" => Some(Self::EditorText),
                "EDITOR_SHAPE" => Some(Self::EditorShape),
                "EDITOR_CUSTOM_SHAPE" => Some(Self::EditorCustomShape),
                "EDITOR_MEDIA" => Some(Self::EditorMedia),
                "EDITOR_VIDEO_INPUT" => Some(Self::EditorVideoInput),
                "EDITOR_WEB" => Some(Self::EditorWeb),
                "EDITOR_CURRENT_SLIDE" => Some(Self::EditorCurrentSlide),
                "EDITOR_NEXT_SLIDE" => Some(Self::EditorNextSlide),
                "EDITOR_SCREEN_PREVIEW" => Some(Self::EditorScreenPreview),
                "EDITOR_TIMER" => Some(Self::EditorTimer),
                "EDITOR_SYSTEM_CLOCK" => Some(Self::EditorSystemClock),
                "EDITOR_VIDEO_COUNTDOWN" => Some(Self::EditorVideoCountdown),
                "EDITOR_AUDIO_COUNTDOWN" => Some(Self::EditorAudioCountdown),
                "EDITOR_PLAYBACK_MARKER" => Some(Self::EditorPlaybackMarker),
                "EDITOR_CHORD_CHART" => Some(Self::EditorChordChart),
                "EDITOR_STAGE_MESSAGE" => Some(Self::EditorStageMessage),
                "EDITOR_PLANNING_CENTER_LIVE" => Some(Self::EditorPlanningCenterLive),
                "EDITOR_TIMECODE" => Some(Self::EditorTimecode),
                "EDITOR_GROUP" => Some(Self::EditorGroup),
                "EDITOR_LABEL" => Some(Self::EditorLabel),
                "EDITOR_CAPTURE_STATUS" => Some(Self::EditorCaptureStatus),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataIdDuplicated {
    #[prost(enumeration = "data_id_duplicated::DataType", tag = "1")]
    pub r#type: i32,
    #[prost(int32, tag = "2")]
    pub number_duplicates: i32,
}
/// Nested message and enum types in `DataIdDuplicated`.
pub mod data_id_duplicated {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        Presentation = 0,
        Media = 1,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataType::Presentation => "DATA_TYPE_PRESENTATION",
                DataType::Media => "DATA_TYPE_MEDIA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_TYPE_PRESENTATION" => Some(Self::Presentation),
                "DATA_TYPE_MEDIA" => Some(Self::Media),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForceQuit {
    #[prost(enumeration = "force_quit::Reason", tag = "1")]
    pub reason: i32,
}
/// Nested message and enum types in `ForceQuit`.
pub mod force_quit {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reason {
        Unknown = 0,
        HostsFile = 1,
        SystemTimeSkew = 2,
        InvalidWatermark = 3,
        PiratedSoftware = 4,
        MetalUnavailable = 5,
        UbiquityDownloadAborted = 6,
        CoreRustControllerFailure = 7,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Reason::Unknown => "UNKNOWN",
                Reason::HostsFile => "HOSTS_FILE",
                Reason::SystemTimeSkew => "SYSTEM_TIME_SKEW",
                Reason::InvalidWatermark => "INVALID_WATERMARK",
                Reason::PiratedSoftware => "PIRATED_SOFTWARE",
                Reason::MetalUnavailable => "METAL_UNAVAILABLE",
                Reason::UbiquityDownloadAborted => "UBIQUITY_DOWNLOAD_ABORTED",
                Reason::CoreRustControllerFailure => "CORE_RUST_CONTROLLER_FAILURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "HOSTS_FILE" => Some(Self::HostsFile),
                "SYSTEM_TIME_SKEW" => Some(Self::SystemTimeSkew),
                "INVALID_WATERMARK" => Some(Self::InvalidWatermark),
                "PIRATED_SOFTWARE" => Some(Self::PiratedSoftware),
                "METAL_UNAVAILABLE" => Some(Self::MetalUnavailable),
                "UBIQUITY_DOWNLOAD_ABORTED" => Some(Self::UbiquityDownloadAborted),
                "CORE_RUST_CONTROLLER_FAILURE" => Some(Self::CoreRustControllerFailure),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaCleanupSize {
    #[prost(uint64, tag = "1")]
    pub bytes_of_media_files_cleaned_up: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Codec {
    H264 = 0,
    H264software = 1,
    H265 = 2,
    H265software = 3,
    Prores422proxy = 4,
    Prores422lt = 5,
    Prores422 = 6,
    Prores422hq = 7,
    Prores4444 = 8,
    Prores4444xq = 9,
    Hap = 10,
    Hapalpha = 11,
    Notch = 12,
    Automatic = 13,
    Hapq = 14,
    Hapqalpha = 15,
}
impl Codec {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Codec::H264 => "H264",
            Codec::H264software => "H264SOFTWARE",
            Codec::H265 => "H265",
            Codec::H265software => "H265SOFTWARE",
            Codec::Prores422proxy => "PRORES422PROXY",
            Codec::Prores422lt => "PRORES422LT",
            Codec::Prores422 => "PRORES422",
            Codec::Prores422hq => "PRORES422HQ",
            Codec::Prores4444 => "PRORES4444",
            Codec::Prores4444xq => "PRORES4444XQ",
            Codec::Hap => "HAP",
            Codec::Hapalpha => "HAPALPHA",
            Codec::Notch => "NOTCH",
            Codec::Automatic => "AUTOMATIC",
            Codec::Hapq => "HAPQ",
            Codec::Hapqalpha => "HAPQALPHA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "H264" => Some(Self::H264),
            "H264SOFTWARE" => Some(Self::H264software),
            "H265" => Some(Self::H265),
            "H265SOFTWARE" => Some(Self::H265software),
            "PRORES422PROXY" => Some(Self::Prores422proxy),
            "PRORES422LT" => Some(Self::Prores422lt),
            "PRORES422" => Some(Self::Prores422),
            "PRORES422HQ" => Some(Self::Prores422hq),
            "PRORES4444" => Some(Self::Prores4444),
            "PRORES4444XQ" => Some(Self::Prores4444xq),
            "HAP" => Some(Self::Hap),
            "HAPALPHA" => Some(Self::Hapalpha),
            "NOTCH" => Some(Self::Notch),
            "AUTOMATIC" => Some(Self::Automatic),
            "HAPQ" => Some(Self::Hapq),
            "HAPQALPHA" => Some(Self::Hapqalpha),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FrameRate {
    Unspecified = 0,
    _24fps = 1,
    _25fps = 2,
    _2997fps = 3,
    _30fps = 4,
    _50fps = 5,
    _5994fps = 6,
    _60fps = 7,
}
impl FrameRate {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FrameRate::Unspecified => "UNSPECIFIED",
            FrameRate::_24fps => "_24FPS",
            FrameRate::_25fps => "_25FPS",
            FrameRate::_2997fps => "_2997FPS",
            FrameRate::_30fps => "_30FPS",
            FrameRate::_50fps => "_50FPS",
            FrameRate::_5994fps => "_5994FPS",
            FrameRate::_60fps => "_60FPS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "_24FPS" => Some(Self::_24fps),
            "_25FPS" => Some(Self::_25fps),
            "_2997FPS" => Some(Self::_2997fps),
            "_30FPS" => Some(Self::_30fps),
            "_50FPS" => Some(Self::_50fps),
            "_5994FPS" => Some(Self::_5994fps),
            "_60FPS" => Some(Self::_60fps),
            _ => None,
        }
    }
}
