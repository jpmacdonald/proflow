// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlphaType {
    Unknown = 0,
    Straight = 1,
    Premultiplied = 2,
}
impl AlphaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AlphaType::Unknown => "ALPHA_TYPE_UNKNOWN",
            AlphaType::Straight => "ALPHA_TYPE_STRAIGHT",
            AlphaType::Premultiplied => "ALPHA_TYPE_PREMULTIPLIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALPHA_TYPE_UNKNOWN" => Some(Self::Unknown),
            "ALPHA_TYPE_STRAIGHT" => Some(Self::Straight),
            "ALPHA_TYPE_PREMULTIPLIED" => Some(Self::Premultiplied),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Color {
    #[prost(float, tag = "1")]
    pub red: f32,
    #[prost(float, tag = "2")]
    pub green: f32,
    #[prost(float, tag = "3")]
    pub blue: f32,
    #[prost(float, tag = "4")]
    pub alpha: f32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DigitalAudio {}
/// Nested message and enum types in `DigitalAudio`.
pub mod digital_audio {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Setup {
        #[prost(message, repeated, tag = "1")]
        pub buses: ::prost::alloc::vec::Vec<Bus>,
        #[prost(message, optional, tag = "2")]
        pub monitor_device: ::core::option::Option<Device>,
        #[prost(message, optional, tag = "3")]
        pub main_output_device: ::core::option::Option<Device>,
        #[prost(bool, tag = "4")]
        pub enable_sdi_ndi_device: bool,
        #[prost(message, optional, tag = "5")]
        pub sdi_ndi_device: ::core::option::Option<Device>,
        #[prost(bool, tag = "6")]
        pub monitor_on_mains: bool,
        #[prost(bool, tag = "7")]
        pub disable_main_output_device: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Bus {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub muted: bool,
        #[prost(bool, tag = "3")]
        pub solo: bool,
        #[prost(bool, tag = "4")]
        pub test_tone: bool,
        #[prost(double, tag = "5")]
        pub master_level: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Device {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub render_id: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub formats: ::prost::alloc::vec::Vec<device::Format>,
        #[prost(message, optional, tag = "4")]
        pub routing: ::core::option::Option<device::Routing>,
    }
    /// Nested message and enum types in `Device`.
    pub mod device {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Format {
            #[prost(uint32, tag = "1")]
            pub sample_rate: u32,
            #[prost(uint32, tag = "2")]
            pub bit_depth: u32,
            #[prost(enumeration = "format::Type", tag = "3")]
            pub r#type: i32,
        }
        /// Nested message and enum types in `Format`.
        pub mod format {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                Int = 0,
                Float = 1,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Type::Int => "TYPE_INT",
                        Type::Float => "TYPE_FLOAT",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TYPE_INT" => Some(Self::Int),
                        "TYPE_FLOAT" => Some(Self::Float),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Map {
            #[prost(uint32, tag = "1")]
            pub channel_index: u32,
            #[prost(uint32, repeated, tag = "2")]
            pub mapped_indices: ::prost::alloc::vec::Vec<u32>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Channel {
            #[prost(bool, tag = "1")]
            pub mute_enable: bool,
            #[prost(bool, tag = "2")]
            pub solo_enable: bool,
            #[prost(bool, tag = "3")]
            pub tone_enable: bool,
            #[prost(double, tag = "4")]
            pub audio_delay: f64,
            #[prost(double, tag = "5")]
            pub level: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Routing {
            #[prost(message, repeated, tag = "1")]
            pub channels: ::prost::alloc::vec::Vec<Channel>,
            #[prost(message, repeated, tag = "2")]
            pub map: ::prost::alloc::vec::Vec<Map>,
            #[prost(bool, tag = "3")]
            pub is_custom_map: bool,
            #[prost(message, optional, tag = "4")]
            pub master_channel: ::core::option::Option<Channel>,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uuid {
    #[prost(string, tag = "1")]
    pub string: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Effect {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(bool, tag = "2")]
    pub enabled: bool,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub render_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub behavior_description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub category: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub variables: ::prost::alloc::vec::Vec<effect::EffectVariable>,
}
/// Nested message and enum types in `Effect`.
pub mod effect {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EffectVariable {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        #[prost(oneof = "effect_variable::Type", tags = "3, 4, 5, 6, 7")]
        pub r#type: ::core::option::Option<effect_variable::Type>,
    }
    /// Nested message and enum types in `EffectVariable`.
    pub mod effect_variable {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EffectInt {
            #[prost(int32, tag = "1")]
            pub value: i32,
            #[prost(int32, tag = "2")]
            pub default_value: i32,
            #[prost(int32, tag = "3")]
            pub min: i32,
            #[prost(int32, tag = "4")]
            pub max: i32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EffectFloat {
            #[prost(float, tag = "1")]
            pub value: f32,
            #[prost(float, tag = "2")]
            pub default_value: f32,
            #[prost(float, tag = "3")]
            pub min: f32,
            #[prost(float, tag = "4")]
            pub max: f32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EffectDouble {
            #[prost(double, tag = "1")]
            pub value: f64,
            #[prost(double, tag = "2")]
            pub default_value: f64,
            #[prost(double, tag = "3")]
            pub min: f64,
            #[prost(double, tag = "4")]
            pub max: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EffectColor {
            #[prost(message, optional, tag = "1")]
            pub color: ::core::option::Option<super::super::Color>,
            #[prost(message, optional, tag = "2")]
            pub default_color: ::core::option::Option<super::super::Color>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EffectDirection {
            #[prost(enumeration = "effect_direction::EffectDirection", tag = "1")]
            pub direction: i32,
            #[prost(enumeration = "effect_direction::EffectDirection", tag = "2")]
            pub default_direction: i32,
            #[prost(uint32, tag = "3")]
            pub available_directions: u32,
        }
        /// Nested message and enum types in `EffectDirection`.
        pub mod effect_direction {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum EffectDirection {
                None = 0,
                TopLeft = 1,
                Top = 2,
                TopRight = 4,
                Left = 8,
                Center = 16,
                Right = 32,
                BottomLeft = 64,
                Bottom = 128,
                BottomRight = 256,
            }
            impl EffectDirection {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        EffectDirection::None => "EFFECT_DIRECTION_NONE",
                        EffectDirection::TopLeft => "EFFECT_DIRECTION_TOP_LEFT",
                        EffectDirection::Top => "EFFECT_DIRECTION_TOP",
                        EffectDirection::TopRight => "EFFECT_DIRECTION_TOP_RIGHT",
                        EffectDirection::Left => "EFFECT_DIRECTION_LEFT",
                        EffectDirection::Center => "EFFECT_DIRECTION_CENTER",
                        EffectDirection::Right => "EFFECT_DIRECTION_RIGHT",
                        EffectDirection::BottomLeft => "EFFECT_DIRECTION_BOTTOM_LEFT",
                        EffectDirection::Bottom => "EFFECT_DIRECTION_BOTTOM",
                        EffectDirection::BottomRight => "EFFECT_DIRECTION_BOTTOM_RIGHT",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "EFFECT_DIRECTION_NONE" => Some(Self::None),
                        "EFFECT_DIRECTION_TOP_LEFT" => Some(Self::TopLeft),
                        "EFFECT_DIRECTION_TOP" => Some(Self::Top),
                        "EFFECT_DIRECTION_TOP_RIGHT" => Some(Self::TopRight),
                        "EFFECT_DIRECTION_LEFT" => Some(Self::Left),
                        "EFFECT_DIRECTION_CENTER" => Some(Self::Center),
                        "EFFECT_DIRECTION_RIGHT" => Some(Self::Right),
                        "EFFECT_DIRECTION_BOTTOM_LEFT" => Some(Self::BottomLeft),
                        "EFFECT_DIRECTION_BOTTOM" => Some(Self::Bottom),
                        "EFFECT_DIRECTION_BOTTOM_RIGHT" => Some(Self::BottomRight),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Type {
            #[prost(message, tag = "3")]
            Int(EffectInt),
            #[prost(message, tag = "4")]
            Float(EffectFloat),
            #[prost(message, tag = "5")]
            Color(EffectColor),
            #[prost(message, tag = "6")]
            Direction(EffectDirection),
            #[prost(message, tag = "7")]
            Double(EffectDouble),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Preset {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub effects: ::prost::alloc::vec::Vec<super::Effect>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transition {
    #[prost(double, tag = "1")]
    pub duration: f64,
    #[prost(message, optional, tag = "2")]
    pub favorite_uuid: ::core::option::Option<Uuid>,
    #[prost(message, optional, tag = "3")]
    pub effect: ::core::option::Option<Effect>,
}
/// Nested message and enum types in `Transition`.
pub mod transition {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Preset {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub transition: ::core::option::Option<super::Transition>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Url {
    #[prost(enumeration = "url::Platform", tag = "3")]
    pub platform: i32,
    #[prost(oneof = "url::Storage", tags = "1, 2")]
    pub storage: ::core::option::Option<url::Storage>,
    #[prost(oneof = "url::RelativeFilePath", tags = "4, 5")]
    pub relative_file_path: ::core::option::Option<url::RelativeFilePath>,
}
/// Nested message and enum types in `URL`.
pub mod url {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LocalRelativePath {
        #[prost(enumeration = "local_relative_path::Root", tag = "1")]
        pub root: i32,
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `LocalRelativePath`.
    pub mod local_relative_path {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Root {
            Unknown = 0,
            BootVolume = 1,
            UserHome = 2,
            UserDocuments = 3,
            UserDownloads = 4,
            UserMusic = 5,
            UserPictures = 6,
            UserVideos = 7,
            UserDesktop = 11,
            UserAppSupport = 8,
            Shared = 9,
            Show = 10,
            CurrentResource = 12,
        }
        impl Root {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Root::Unknown => "ROOT_UNKNOWN",
                    Root::BootVolume => "ROOT_BOOT_VOLUME",
                    Root::UserHome => "ROOT_USER_HOME",
                    Root::UserDocuments => "ROOT_USER_DOCUMENTS",
                    Root::UserDownloads => "ROOT_USER_DOWNLOADS",
                    Root::UserMusic => "ROOT_USER_MUSIC",
                    Root::UserPictures => "ROOT_USER_PICTURES",
                    Root::UserVideos => "ROOT_USER_VIDEOS",
                    Root::UserDesktop => "ROOT_USER_DESKTOP",
                    Root::UserAppSupport => "ROOT_USER_APP_SUPPORT",
                    Root::Shared => "ROOT_SHARED",
                    Root::Show => "ROOT_SHOW",
                    Root::CurrentResource => "ROOT_CURRENT_RESOURCE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ROOT_UNKNOWN" => Some(Self::Unknown),
                    "ROOT_BOOT_VOLUME" => Some(Self::BootVolume),
                    "ROOT_USER_HOME" => Some(Self::UserHome),
                    "ROOT_USER_DOCUMENTS" => Some(Self::UserDocuments),
                    "ROOT_USER_DOWNLOADS" => Some(Self::UserDownloads),
                    "ROOT_USER_MUSIC" => Some(Self::UserMusic),
                    "ROOT_USER_PICTURES" => Some(Self::UserPictures),
                    "ROOT_USER_VIDEOS" => Some(Self::UserVideos),
                    "ROOT_USER_DESKTOP" => Some(Self::UserDesktop),
                    "ROOT_USER_APP_SUPPORT" => Some(Self::UserAppSupport),
                    "ROOT_SHARED" => Some(Self::Shared),
                    "ROOT_SHOW" => Some(Self::Show),
                    "ROOT_CURRENT_RESOURCE" => Some(Self::CurrentResource),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExternalRelativePath {
        #[prost(message, optional, tag = "1")]
        pub macos: ::core::option::Option<external_relative_path::MacOsExternalVolume>,
        #[prost(message, optional, tag = "2")]
        pub win32: ::core::option::Option<external_relative_path::Win32ExternalVolume>,
        #[prost(string, tag = "3")]
        pub path: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ExternalRelativePath`.
    pub mod external_relative_path {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MacOsExternalVolume {
            #[prost(string, tag = "1")]
            pub volume_name: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Win32ExternalVolume {
            #[prost(string, tag = "1")]
            pub drive_letter: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub volume_name: ::prost::alloc::string::String,
            #[prost(bool, tag = "3")]
            pub network_share: bool,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Platform {
        Unknown = 0,
        Macos = 1,
        Win32 = 2,
        Web = 3,
    }
    impl Platform {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Platform::Unknown => "PLATFORM_UNKNOWN",
                Platform::Macos => "PLATFORM_MACOS",
                Platform::Win32 => "PLATFORM_WIN32",
                Platform::Web => "PLATFORM_WEB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PLATFORM_UNKNOWN" => Some(Self::Unknown),
                "PLATFORM_MACOS" => Some(Self::Macos),
                "PLATFORM_WIN32" => Some(Self::Win32),
                "PLATFORM_WEB" => Some(Self::Web),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Storage {
        #[prost(string, tag = "1")]
        AbsoluteString(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        RelativePath(::prost::alloc::string::String),
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RelativeFilePath {
        #[prost(message, tag = "4")]
        Local(LocalRelativePath),
        #[prost(message, tag = "5")]
        External(ExternalRelativePath),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrLs {
    #[prost(message, repeated, tag = "1")]
    pub urls: ::prost::alloc::vec::Vec<Url>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileProperties {
    #[prost(message, optional, tag = "1")]
    pub local_url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "2")]
    pub remote_properties: ::core::option::Option<file_properties::RemoteProperties>,
}
/// Nested message and enum types in `FileProperties`.
pub mod file_properties {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoteProperties {
        #[prost(message, optional, tag = "1")]
        pub procontent: ::core::option::Option<remote_properties::ProContent>,
    }
    /// Nested message and enum types in `RemoteProperties`.
    pub mod remote_properties {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ProContent {
            #[prost(string, tag = "1")]
            pub download_identifier: ::prost::alloc::string::String,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Font {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub size: f64,
    #[prost(bool, tag = "4")]
    pub italic: bool,
    #[prost(bool, tag = "8")]
    pub bold: bool,
    #[prost(string, tag = "9")]
    pub family: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub face: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntRange {
    #[prost(int32, tag = "1")]
    pub start: i32,
    #[prost(int32, tag = "2")]
    pub end: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Graphics {}
/// Nested message and enum types in `Graphics`.
pub mod graphics {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Element {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub bounds: ::core::option::Option<Rect>,
        #[prost(double, tag = "4")]
        pub rotation: f64,
        #[prost(double, tag = "5")]
        pub opacity: f64,
        #[prost(bool, tag = "6")]
        pub locked: bool,
        #[prost(bool, tag = "7")]
        pub aspect_ratio_locked: bool,
        #[prost(message, optional, tag = "8")]
        pub path: ::core::option::Option<Path>,
        #[prost(message, optional, tag = "9")]
        pub fill: ::core::option::Option<Fill>,
        #[prost(message, optional, tag = "10")]
        pub stroke: ::core::option::Option<Stroke>,
        #[prost(message, optional, tag = "11")]
        pub shadow: ::core::option::Option<Shadow>,
        #[prost(message, optional, tag = "12")]
        pub feather: ::core::option::Option<Feather>,
        #[prost(message, optional, tag = "13")]
        pub text: ::core::option::Option<Text>,
        #[prost(enumeration = "element::FlipMode", tag = "15")]
        pub flip_mode: i32,
        #[prost(bool, tag = "16")]
        pub hidden: bool,
        #[prost(oneof = "element::Mask", tags = "14")]
        pub mask: ::core::option::Option<element::Mask>,
    }
    /// Nested message and enum types in `Element`.
    pub mod element {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FlipMode {
            None = 0,
            Vertical = 1,
            Horizontal = 2,
            Both = 3,
        }
        impl FlipMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    FlipMode::None => "FLIP_MODE_NONE",
                    FlipMode::Vertical => "FLIP_MODE_VERTICAL",
                    FlipMode::Horizontal => "FLIP_MODE_HORIZONTAL",
                    FlipMode::Both => "FLIP_MODE_BOTH",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FLIP_MODE_NONE" => Some(Self::None),
                    "FLIP_MODE_VERTICAL" => Some(Self::Vertical),
                    "FLIP_MODE_HORIZONTAL" => Some(Self::Horizontal),
                    "FLIP_MODE_BOTH" => Some(Self::Both),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Mask {
            #[prost(message, tag = "14")]
            TextLineMask(super::text::LineFillMask),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Rect {
        #[prost(message, optional, tag = "1")]
        pub origin: ::core::option::Option<Point>,
        #[prost(message, optional, tag = "2")]
        pub size: ::core::option::Option<Size>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Point {
        #[prost(double, tag = "1")]
        pub x: f64,
        #[prost(double, tag = "2")]
        pub y: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Size {
        #[prost(double, tag = "1")]
        pub width: f64,
        #[prost(double, tag = "2")]
        pub height: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EdgeInsets {
        #[prost(double, tag = "1")]
        pub left: f64,
        #[prost(double, tag = "2")]
        pub right: f64,
        #[prost(double, tag = "3")]
        pub top: f64,
        #[prost(double, tag = "4")]
        pub bottom: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Path {
        #[prost(bool, tag = "1")]
        pub closed: bool,
        #[prost(message, repeated, tag = "2")]
        pub points: ::prost::alloc::vec::Vec<path::BezierPoint>,
        #[prost(message, optional, tag = "3")]
        pub shape: ::core::option::Option<path::Shape>,
    }
    /// Nested message and enum types in `Path`.
    pub mod path {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BezierPoint {
            #[prost(message, optional, tag = "1")]
            pub point: ::core::option::Option<super::Point>,
            #[prost(message, optional, tag = "2")]
            pub q0: ::core::option::Option<super::Point>,
            #[prost(message, optional, tag = "3")]
            pub q1: ::core::option::Option<super::Point>,
            #[prost(bool, tag = "4")]
            pub curved: bool,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Shape {
            #[prost(enumeration = "shape::Type", tag = "1")]
            pub r#type: i32,
            #[prost(oneof = "shape::AdditionalData", tags = "2, 3, 4, 5")]
            pub additional_data: ::core::option::Option<shape::AdditionalData>,
        }
        /// Nested message and enum types in `Shape`.
        pub mod shape {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RoundedRectangle {
                #[prost(double, tag = "1")]
                pub roundness: f64,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Arrow {
                #[prost(message, optional, tag = "1")]
                pub corner: ::core::option::Option<super::super::Point>,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Polygon {
                #[prost(uint32, tag = "1")]
                pub number_sides: u32,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Star {
                #[prost(double, tag = "1")]
                pub inner_radius: f64,
                #[prost(uint32, tag = "2")]
                pub number_points: u32,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                Unknown = 0,
                Rectangle = 1,
                Ellipse = 2,
                IsoscelesTriangle = 3,
                RightTriangle = 4,
                Rhombus = 5,
                Star = 6,
                Polygon = 7,
                Custom = 8,
                RightArrow = 9,
                DoubleArrow = 10,
                RoundedRectangle = 11,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Type::Unknown => "TYPE_UNKNOWN",
                        Type::Rectangle => "TYPE_RECTANGLE",
                        Type::Ellipse => "TYPE_ELLIPSE",
                        Type::IsoscelesTriangle => "TYPE_ISOSCELES_TRIANGLE",
                        Type::RightTriangle => "TYPE_RIGHT_TRIANGLE",
                        Type::Rhombus => "TYPE_RHOMBUS",
                        Type::Star => "TYPE_STAR",
                        Type::Polygon => "TYPE_POLYGON",
                        Type::Custom => "TYPE_CUSTOM",
                        Type::RightArrow => "TYPE_RIGHT_ARROW",
                        Type::DoubleArrow => "TYPE_DOUBLE_ARROW",
                        Type::RoundedRectangle => "TYPE_ROUNDED_RECTANGLE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TYPE_UNKNOWN" => Some(Self::Unknown),
                        "TYPE_RECTANGLE" => Some(Self::Rectangle),
                        "TYPE_ELLIPSE" => Some(Self::Ellipse),
                        "TYPE_ISOSCELES_TRIANGLE" => Some(Self::IsoscelesTriangle),
                        "TYPE_RIGHT_TRIANGLE" => Some(Self::RightTriangle),
                        "TYPE_RHOMBUS" => Some(Self::Rhombus),
                        "TYPE_STAR" => Some(Self::Star),
                        "TYPE_POLYGON" => Some(Self::Polygon),
                        "TYPE_CUSTOM" => Some(Self::Custom),
                        "TYPE_RIGHT_ARROW" => Some(Self::RightArrow),
                        "TYPE_DOUBLE_ARROW" => Some(Self::DoubleArrow),
                        "TYPE_ROUNDED_RECTANGLE" => Some(Self::RoundedRectangle),
                        _ => None,
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum AdditionalData {
                #[prost(message, tag = "2")]
                RoundedRectangle(RoundedRectangle),
                #[prost(message, tag = "3")]
                Polygon(Polygon),
                #[prost(message, tag = "4")]
                Star(Star),
                #[prost(message, tag = "5")]
                Arrow(Arrow),
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Fill {
        #[prost(bool, tag = "4")]
        pub enable: bool,
        #[prost(oneof = "fill::FillType", tags = "1, 2, 3, 5")]
        pub fill_type: ::core::option::Option<fill::FillType>,
    }
    /// Nested message and enum types in `Fill`.
    pub mod fill {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum FillType {
            #[prost(message, tag = "1")]
            Color(super::super::Color),
            #[prost(message, tag = "2")]
            Gradient(super::Gradient),
            #[prost(message, tag = "3")]
            Media(super::super::Media),
            #[prost(message, tag = "5")]
            BackgroundEffect(super::BackgroundEffect),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BackgroundEffect {
        #[prost(oneof = "background_effect::EffectType", tags = "2, 3")]
        pub effect_type: ::core::option::Option<background_effect::EffectType>,
    }
    /// Nested message and enum types in `BackgroundEffect`.
    pub mod background_effect {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BackgroundEffectBlur {
            #[prost(double, tag = "1")]
            pub saturation: f64,
            #[prost(double, tag = "2")]
            pub blur_amount: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BackgroundEffectInvert {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum EffectType {
            #[prost(message, tag = "2")]
            BackgroundBlur(BackgroundEffectBlur),
            #[prost(message, tag = "3")]
            BackgroundInvert(BackgroundEffectInvert),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Gradient {
        #[prost(enumeration = "gradient::Type", tag = "1")]
        pub r#type: i32,
        #[prost(double, tag = "2")]
        pub angle: f64,
        #[prost(double, tag = "3")]
        pub length: f64,
        #[prost(message, repeated, tag = "4")]
        pub stops: ::prost::alloc::vec::Vec<gradient::ColorStop>,
    }
    /// Nested message and enum types in `Gradient`.
    pub mod gradient {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ColorStop {
            #[prost(message, optional, tag = "1")]
            pub color: ::core::option::Option<super::super::Color>,
            #[prost(double, tag = "2")]
            pub position: f64,
            #[prost(double, tag = "3")]
            pub blend_point: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            Linear = 0,
            Radial = 1,
            Angle = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Linear => "TYPE_LINEAR",
                    Type::Radial => "TYPE_RADIAL",
                    Type::Angle => "TYPE_ANGLE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_LINEAR" => Some(Self::Linear),
                    "TYPE_RADIAL" => Some(Self::Radial),
                    "TYPE_ANGLE" => Some(Self::Angle),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Shadow {
        #[prost(enumeration = "shadow::Style", tag = "1")]
        pub style: i32,
        #[prost(double, tag = "2")]
        pub angle: f64,
        #[prost(double, tag = "3")]
        pub offset: f64,
        #[prost(double, tag = "4")]
        pub radius: f64,
        #[prost(message, optional, tag = "5")]
        pub color: ::core::option::Option<super::Color>,
        #[prost(double, tag = "6")]
        pub opacity: f64,
        #[prost(bool, tag = "7")]
        pub enable: bool,
    }
    /// Nested message and enum types in `Shadow`.
    pub mod shadow {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Style {
            Drop = 0,
        }
        impl Style {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Style::Drop => "STYLE_DROP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STYLE_DROP" => Some(Self::Drop),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Stroke {
        #[prost(enumeration = "stroke::Style", tag = "1")]
        pub style: i32,
        #[prost(double, tag = "2")]
        pub width: f64,
        #[prost(message, optional, tag = "3")]
        pub color: ::core::option::Option<super::Color>,
        #[prost(double, repeated, tag = "4")]
        pub pattern: ::prost::alloc::vec::Vec<f64>,
        #[prost(bool, tag = "5")]
        pub enable: bool,
    }
    /// Nested message and enum types in `Stroke`.
    pub mod stroke {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Style {
            SolidLine = 0,
            SquareDash = 1,
            ShortDash = 2,
            LongDash = 3,
        }
        impl Style {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Style::SolidLine => "STYLE_SOLID_LINE",
                    Style::SquareDash => "STYLE_SQUARE_DASH",
                    Style::ShortDash => "STYLE_SHORT_DASH",
                    Style::LongDash => "STYLE_LONG_DASH",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STYLE_SOLID_LINE" => Some(Self::SolidLine),
                    "STYLE_SQUARE_DASH" => Some(Self::SquareDash),
                    "STYLE_SHORT_DASH" => Some(Self::ShortDash),
                    "STYLE_LONG_DASH" => Some(Self::LongDash),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Feather {
        #[prost(enumeration = "feather::Style", tag = "1")]
        pub style: i32,
        #[prost(double, tag = "2")]
        pub radius: f64,
        #[prost(bool, tag = "3")]
        pub enable: bool,
    }
    /// Nested message and enum types in `Feather`.
    pub mod feather {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Style {
            Inside = 0,
            Center = 1,
            Outside = 2,
        }
        impl Style {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Style::Inside => "STYLE_INSIDE",
                    Style::Center => "STYLE_CENTER",
                    Style::Outside => "STYLE_OUTSIDE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STYLE_INSIDE" => Some(Self::Inside),
                    "STYLE_CENTER" => Some(Self::Center),
                    "STYLE_OUTSIDE" => Some(Self::Outside),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Text {
        #[prost(message, optional, tag = "3")]
        pub attributes: ::core::option::Option<text::Attributes>,
        #[prost(message, optional, tag = "4")]
        pub shadow: ::core::option::Option<Shadow>,
        #[prost(bytes = "vec", tag = "5")]
        pub rtf_data: ::prost::alloc::vec::Vec<u8>,
        #[prost(enumeration = "text::VerticalAlignment", tag = "6")]
        pub vertical_alignment: i32,
        #[prost(enumeration = "text::ScaleBehavior", tag = "7")]
        pub scale_behavior: i32,
        #[prost(message, optional, tag = "8")]
        pub margins: ::core::option::Option<EdgeInsets>,
        #[prost(bool, tag = "9")]
        pub is_superscript_standardized: bool,
        #[prost(enumeration = "text::Transform", tag = "10")]
        pub transform: i32,
        #[prost(string, tag = "11")]
        pub transform_delimiter: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "12")]
        pub chord_pro: ::core::option::Option<text::ChordPro>,
        #[prost(message, repeated, tag = "13")]
        pub alternate_texts: ::prost::alloc::vec::Vec<text::AlternateText>,
    }
    /// Nested message and enum types in `Text`.
    pub mod text {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LineFillMask {
            #[prost(bool, tag = "1")]
            pub enabled: bool,
            #[prost(double, tag = "2")]
            pub height_offset: f64,
            #[prost(double, tag = "3")]
            pub vertical_offset: f64,
            #[prost(enumeration = "line_fill_mask::LineMaskStyle", tag = "4")]
            pub mask_style: i32,
            #[prost(double, tag = "5")]
            pub width_offset: f64,
            #[prost(double, tag = "6")]
            pub horizontal_offset: f64,
        }
        /// Nested message and enum types in `LineFillMask`.
        pub mod line_fill_mask {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum LineMaskStyle {
                FullWidth = 0,
                LineWidth = 1,
                MaxLineWidth = 2,
            }
            impl LineMaskStyle {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        LineMaskStyle::FullWidth => "LINE_MASK_STYLE_FULL_WIDTH",
                        LineMaskStyle::LineWidth => "LINE_MASK_STYLE_LINE_WIDTH",
                        LineMaskStyle::MaxLineWidth => "LINE_MASK_STYLE_MAX_LINE_WIDTH",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "LINE_MASK_STYLE_FULL_WIDTH" => Some(Self::FullWidth),
                        "LINE_MASK_STYLE_LINE_WIDTH" => Some(Self::LineWidth),
                        "LINE_MASK_STYLE_MAX_LINE_WIDTH" => Some(Self::MaxLineWidth),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GradientFill {
            #[prost(message, optional, tag = "1")]
            pub gradient: ::core::option::Option<super::Gradient>,
            #[prost(bool, tag = "2")]
            pub stretch_to_document_bounds: bool,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CutOutFill {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MediaFill {
            #[prost(message, optional, tag = "1")]
            pub media: ::core::option::Option<super::super::Media>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ChordPro {
            #[prost(bool, tag = "1")]
            pub enabled: bool,
            #[prost(enumeration = "chord_pro::Notation", tag = "2")]
            pub notation: i32,
            #[prost(message, optional, tag = "3")]
            pub color: ::core::option::Option<super::super::Color>,
        }
        /// Nested message and enum types in `ChordPro`.
        pub mod chord_pro {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Notation {
                Chords = 0,
                Numbers = 1,
                Numerals = 2,
                DoReMi = 3,
            }
            impl Notation {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Notation::Chords => "NOTATION_CHORDS",
                        Notation::Numbers => "NOTATION_NUMBERS",
                        Notation::Numerals => "NOTATION_NUMERALS",
                        Notation::DoReMi => "NOTATION_DO_RE_MI",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "NOTATION_CHORDS" => Some(Self::Chords),
                        "NOTATION_NUMBERS" => Some(Self::Numbers),
                        "NOTATION_NUMERALS" => Some(Self::Numerals),
                        "NOTATION_DO_RE_MI" => Some(Self::DoReMi),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Attributes {
            #[prost(message, optional, tag = "1")]
            pub font: ::core::option::Option<super::super::Font>,
            #[prost(enumeration = "attributes::Capitalization", tag = "2")]
            pub capitalization: i32,
            #[prost(message, optional, tag = "4")]
            pub underline_style: ::core::option::Option<attributes::Underline>,
            #[prost(message, optional, tag = "5")]
            pub underline_color: ::core::option::Option<super::super::Color>,
            #[prost(message, optional, tag = "6")]
            pub paragraph_style: ::core::option::Option<attributes::Paragraph>,
            #[prost(double, tag = "7")]
            pub kerning: f64,
            #[prost(int32, tag = "8")]
            pub superscript: i32,
            #[prost(message, optional, tag = "9")]
            pub strikethrough_style: ::core::option::Option<attributes::Underline>,
            #[prost(message, optional, tag = "10")]
            pub strikethrough_color: ::core::option::Option<super::super::Color>,
            #[prost(double, tag = "11")]
            pub stroke_width: f64,
            #[prost(message, optional, tag = "12")]
            pub stroke_color: ::core::option::Option<super::super::Color>,
            #[prost(message, repeated, tag = "13")]
            pub custom_attributes: ::prost::alloc::vec::Vec<attributes::CustomAttribute>,
            #[prost(message, optional, tag = "15")]
            pub background_color: ::core::option::Option<super::super::Color>,
            #[prost(enumeration = "attributes::LigatureStyle", tag = "19")]
            pub ligature_style: i32,
            #[prost(oneof = "attributes::Fill", tags = "3, 14, 16, 17, 18")]
            pub fill: ::core::option::Option<attributes::Fill>,
        }
        /// Nested message and enum types in `Attributes`.
        pub mod attributes {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Underline {
                #[prost(enumeration = "underline::Style", tag = "1")]
                pub style: i32,
                #[prost(enumeration = "underline::Pattern", tag = "2")]
                pub pattern: i32,
                #[prost(bool, tag = "3")]
                pub by_word: bool,
            }
            /// Nested message and enum types in `Underline`.
            pub mod underline {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Style {
                    None = 0,
                    Single = 1,
                    Thick = 2,
                    Double = 3,
                }
                impl Style {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Style::None => "STYLE_NONE",
                            Style::Single => "STYLE_SINGLE",
                            Style::Thick => "STYLE_THICK",
                            Style::Double => "STYLE_DOUBLE",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "STYLE_NONE" => Some(Self::None),
                            "STYLE_SINGLE" => Some(Self::Single),
                            "STYLE_THICK" => Some(Self::Thick),
                            "STYLE_DOUBLE" => Some(Self::Double),
                            _ => None,
                        }
                    }
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Pattern {
                    Solid = 0,
                    Dot = 1,
                    Dash = 2,
                    DashDot = 3,
                    DashDotDot = 4,
                }
                impl Pattern {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Pattern::Solid => "PATTERN_SOLID",
                            Pattern::Dot => "PATTERN_DOT",
                            Pattern::Dash => "PATTERN_DASH",
                            Pattern::DashDot => "PATTERN_DASH_DOT",
                            Pattern::DashDotDot => "PATTERN_DASH_DOT_DOT",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "PATTERN_SOLID" => Some(Self::Solid),
                            "PATTERN_DOT" => Some(Self::Dot),
                            "PATTERN_DASH" => Some(Self::Dash),
                            "PATTERN_DASH_DOT" => Some(Self::DashDot),
                            "PATTERN_DASH_DOT_DOT" => Some(Self::DashDotDot),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Paragraph {
                #[prost(enumeration = "Alignment", tag = "1")]
                pub alignment: i32,
                #[prost(double, tag = "2")]
                pub first_line_head_indent: f64,
                #[prost(double, tag = "3")]
                pub head_indent: f64,
                #[prost(double, tag = "4")]
                pub tail_indent: f64,
                #[prost(double, tag = "5")]
                pub line_height_multiple: f64,
                #[prost(double, tag = "6")]
                pub maximum_line_height: f64,
                #[prost(double, tag = "7")]
                pub minimum_line_height: f64,
                #[prost(double, tag = "8")]
                pub line_spacing: f64,
                #[prost(double, tag = "9")]
                pub paragraph_spacing: f64,
                #[prost(double, tag = "10")]
                pub paragraph_spacing_before: f64,
                #[prost(message, repeated, tag = "11")]
                pub tab_stops: ::prost::alloc::vec::Vec<paragraph::TabStop>,
                #[prost(double, tag = "12")]
                pub default_tab_interval: f64,
                #[prost(message, optional, tag = "13")]
                pub text_list: ::core::option::Option<paragraph::TextList>,
                #[prost(message, repeated, tag = "14")]
                pub text_lists: ::prost::alloc::vec::Vec<paragraph::TextList>,
            }
            /// Nested message and enum types in `Paragraph`.
            pub mod paragraph {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TabStop {
                    #[prost(double, tag = "1")]
                    pub location: f64,
                    #[prost(enumeration = "super::Alignment", tag = "2")]
                    pub alignment: i32,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TextList {
                    #[prost(bool, tag = "1")]
                    pub is_enabled: bool,
                    #[prost(enumeration = "text_list::NumberType", tag = "2")]
                    pub number_type: i32,
                    #[prost(string, tag = "3")]
                    pub prefix: ::prost::alloc::string::String,
                    #[prost(string, tag = "4")]
                    pub postfix: ::prost::alloc::string::String,
                    #[prost(int32, tag = "5")]
                    pub starting_number: i32,
                }
                /// Nested message and enum types in `TextList`.
                pub mod text_list {
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration
                    )]
                    #[repr(i32)]
                    pub enum NumberType {
                        Box = 0,
                        Check = 1,
                        Circle = 2,
                        Diamond = 3,
                        Disc = 4,
                        Hyphen = 5,
                        Square = 6,
                        Decimal = 7,
                        LowercaseAlpha = 8,
                        UppercaseAlpha = 9,
                        LowercaseRoman = 10,
                        UppercaseRoman = 11,
                    }
                    impl NumberType {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                NumberType::Box => "NUMBER_TYPE_BOX",
                                NumberType::Check => "NUMBER_TYPE_CHECK",
                                NumberType::Circle => "NUMBER_TYPE_CIRCLE",
                                NumberType::Diamond => "NUMBER_TYPE_DIAMOND",
                                NumberType::Disc => "NUMBER_TYPE_DISC",
                                NumberType::Hyphen => "NUMBER_TYPE_HYPHEN",
                                NumberType::Square => "NUMBER_TYPE_SQUARE",
                                NumberType::Decimal => "NUMBER_TYPE_DECIMAL",
                                NumberType::LowercaseAlpha => "NUMBER_TYPE_LOWERCASE_ALPHA",
                                NumberType::UppercaseAlpha => "NUMBER_TYPE_UPPERCASE_ALPHA",
                                NumberType::LowercaseRoman => "NUMBER_TYPE_LOWERCASE_ROMAN",
                                NumberType::UppercaseRoman => "NUMBER_TYPE_UPPERCASE_ROMAN",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(
                            value: &str,
                        ) -> ::core::option::Option<Self> {
                            match value {
                                "NUMBER_TYPE_BOX" => Some(Self::Box),
                                "NUMBER_TYPE_CHECK" => Some(Self::Check),
                                "NUMBER_TYPE_CIRCLE" => Some(Self::Circle),
                                "NUMBER_TYPE_DIAMOND" => Some(Self::Diamond),
                                "NUMBER_TYPE_DISC" => Some(Self::Disc),
                                "NUMBER_TYPE_HYPHEN" => Some(Self::Hyphen),
                                "NUMBER_TYPE_SQUARE" => Some(Self::Square),
                                "NUMBER_TYPE_DECIMAL" => Some(Self::Decimal),
                                "NUMBER_TYPE_LOWERCASE_ALPHA" => Some(Self::LowercaseAlpha),
                                "NUMBER_TYPE_UPPERCASE_ALPHA" => Some(Self::UppercaseAlpha),
                                "NUMBER_TYPE_LOWERCASE_ROMAN" => Some(Self::LowercaseRoman),
                                "NUMBER_TYPE_UPPERCASE_ROMAN" => Some(Self::UppercaseRoman),
                                _ => None,
                            }
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct CustomAttribute {
                #[prost(message, optional, tag = "1")]
                pub range: ::core::option::Option<super::super::super::IntRange>,
                #[prost(
                    oneof = "custom_attribute::Attribute",
                    tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11"
                )]
                pub attribute: ::core::option::Option<custom_attribute::Attribute>,
            }
            /// Nested message and enum types in `CustomAttribute`.
            pub mod custom_attribute {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Attribute {
                    #[prost(enumeration = "super::Capitalization", tag = "2")]
                    Capitalization(i32),
                    #[prost(double, tag = "3")]
                    OriginalFontSize(f64),
                    #[prost(double, tag = "4")]
                    FontScaleFactor(f64),
                    #[prost(message, tag = "5")]
                    TextGradientFill(super::super::GradientFill),
                    #[prost(bool, tag = "6")]
                    ShouldPreserveForegroundColor(bool),
                    #[prost(string, tag = "7")]
                    Chord(::prost::alloc::string::String),
                    #[prost(message, tag = "8")]
                    CutOutFill(super::super::CutOutFill),
                    #[prost(message, tag = "9")]
                    MediaFill(super::super::MediaFill),
                    #[prost(message, tag = "10")]
                    BackgroundEffect(super::super::super::BackgroundEffect),
                    #[prost(enumeration = "super::CharacterSizeMode", tag = "11")]
                    CharacterSizeMode(i32),
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Capitalization {
                None = 0,
                AllCaps = 1,
                SmallCaps = 2,
                TitleCase = 3,
                StartCase = 4,
            }
            impl Capitalization {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Capitalization::None => "CAPITALIZATION_NONE",
                        Capitalization::AllCaps => "CAPITALIZATION_ALL_CAPS",
                        Capitalization::SmallCaps => "CAPITALIZATION_SMALL_CAPS",
                        Capitalization::TitleCase => "CAPITALIZATION_TITLE_CASE",
                        Capitalization::StartCase => "CAPITALIZATION_START_CASE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "CAPITALIZATION_NONE" => Some(Self::None),
                        "CAPITALIZATION_ALL_CAPS" => Some(Self::AllCaps),
                        "CAPITALIZATION_SMALL_CAPS" => Some(Self::SmallCaps),
                        "CAPITALIZATION_TITLE_CASE" => Some(Self::TitleCase),
                        "CAPITALIZATION_START_CASE" => Some(Self::StartCase),
                        _ => None,
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Alignment {
                Left = 0,
                Right = 1,
                Center = 2,
                Justified = 3,
                Natural = 4,
            }
            impl Alignment {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Alignment::Left => "ALIGNMENT_LEFT",
                        Alignment::Right => "ALIGNMENT_RIGHT",
                        Alignment::Center => "ALIGNMENT_CENTER",
                        Alignment::Justified => "ALIGNMENT_JUSTIFIED",
                        Alignment::Natural => "ALIGNMENT_NATURAL",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "ALIGNMENT_LEFT" => Some(Self::Left),
                        "ALIGNMENT_RIGHT" => Some(Self::Right),
                        "ALIGNMENT_CENTER" => Some(Self::Center),
                        "ALIGNMENT_JUSTIFIED" => Some(Self::Justified),
                        "ALIGNMENT_NATURAL" => Some(Self::Natural),
                        _ => None,
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum CharacterSizeMode {
                Normal = 0,
                ScaledByDocumentHeight = 1,
                ScaledByDocumentWidth = 2,
            }
            impl CharacterSizeMode {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        CharacterSizeMode::Normal => "CHARACTER_SIZE_MODE_NORMAL",
                        CharacterSizeMode::ScaledByDocumentHeight => {
                            "CHARACTER_SIZE_MODE_SCALED_BY_DOCUMENT_HEIGHT"
                        }
                        CharacterSizeMode::ScaledByDocumentWidth => {
                            "CHARACTER_SIZE_MODE_SCALED_BY_DOCUMENT_WIDTH"
                        }
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "CHARACTER_SIZE_MODE_NORMAL" => Some(Self::Normal),
                        "CHARACTER_SIZE_MODE_SCALED_BY_DOCUMENT_HEIGHT" => {
                            Some(Self::ScaledByDocumentHeight)
                        }
                        "CHARACTER_SIZE_MODE_SCALED_BY_DOCUMENT_WIDTH" => {
                            Some(Self::ScaledByDocumentWidth)
                        }
                        _ => None,
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum LigatureStyle {
                Default = 0,
                None = 1,
            }
            impl LigatureStyle {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        LigatureStyle::Default => "LIGATURE_STYLE_DEFAULT",
                        LigatureStyle::None => "LIGATURE_STYLE_NONE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "LIGATURE_STYLE_DEFAULT" => Some(Self::Default),
                        "LIGATURE_STYLE_NONE" => Some(Self::None),
                        _ => None,
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Fill {
                #[prost(message, tag = "3")]
                TextSolidFill(super::super::super::Color),
                #[prost(message, tag = "14")]
                TextGradientFill(super::GradientFill),
                #[prost(message, tag = "16")]
                CutOutFill(super::CutOutFill),
                #[prost(message, tag = "17")]
                MediaFill(super::MediaFill),
                #[prost(message, tag = "18")]
                BackgroundEffect(super::super::BackgroundEffect),
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AlternateText {
            #[prost(string, tag = "1")]
            pub key: ::prost::alloc::string::String,
            #[prost(oneof = "alternate_text::ContentType", tags = "2")]
            pub content_type: ::core::option::Option<alternate_text::ContentType>,
        }
        /// Nested message and enum types in `AlternateText`.
        pub mod alternate_text {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum ContentType {
                #[prost(string, tag = "2")]
                PlainText(::prost::alloc::string::String),
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum VerticalAlignment {
            Top = 0,
            Middle = 1,
            Bottom = 2,
        }
        impl VerticalAlignment {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    VerticalAlignment::Top => "VERTICAL_ALIGNMENT_TOP",
                    VerticalAlignment::Middle => "VERTICAL_ALIGNMENT_MIDDLE",
                    VerticalAlignment::Bottom => "VERTICAL_ALIGNMENT_BOTTOM",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "VERTICAL_ALIGNMENT_TOP" => Some(Self::Top),
                    "VERTICAL_ALIGNMENT_MIDDLE" => Some(Self::Middle),
                    "VERTICAL_ALIGNMENT_BOTTOM" => Some(Self::Bottom),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ScaleBehavior {
            None = 0,
            AdjustContainerHeight = 1,
            ScaleFontDown = 2,
            ScaleFontUp = 3,
            ScaleFontUpDown = 4,
        }
        impl ScaleBehavior {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ScaleBehavior::None => "SCALE_BEHAVIOR_NONE",
                    ScaleBehavior::AdjustContainerHeight => {
                        "SCALE_BEHAVIOR_ADJUST_CONTAINER_HEIGHT"
                    }
                    ScaleBehavior::ScaleFontDown => "SCALE_BEHAVIOR_SCALE_FONT_DOWN",
                    ScaleBehavior::ScaleFontUp => "SCALE_BEHAVIOR_SCALE_FONT_UP",
                    ScaleBehavior::ScaleFontUpDown => "SCALE_BEHAVIOR_SCALE_FONT_UP_DOWN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SCALE_BEHAVIOR_NONE" => Some(Self::None),
                    "SCALE_BEHAVIOR_ADJUST_CONTAINER_HEIGHT" => {
                        Some(Self::AdjustContainerHeight)
                    }
                    "SCALE_BEHAVIOR_SCALE_FONT_DOWN" => Some(Self::ScaleFontDown),
                    "SCALE_BEHAVIOR_SCALE_FONT_UP" => Some(Self::ScaleFontUp),
                    "SCALE_BEHAVIOR_SCALE_FONT_UP_DOWN" => Some(Self::ScaleFontUpDown),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Transform {
            None = 0,
            SingleLine = 1,
            OneWordPerLine = 2,
            OneCharacterPerLine = 3,
            ReplaceLineReturns = 4,
        }
        impl Transform {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Transform::None => "TRANSFORM_NONE",
                    Transform::SingleLine => "TRANSFORM_SINGLE_LINE",
                    Transform::OneWordPerLine => "TRANSFORM_ONE_WORD_PER_LINE",
                    Transform::OneCharacterPerLine => "TRANSFORM_ONE_CHARACTER_PER_LINE",
                    Transform::ReplaceLineReturns => "TRANSFORM_REPLACE_LINE_RETURNS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TRANSFORM_NONE" => Some(Self::None),
                    "TRANSFORM_SINGLE_LINE" => Some(Self::SingleLine),
                    "TRANSFORM_ONE_WORD_PER_LINE" => Some(Self::OneWordPerLine),
                    "TRANSFORM_ONE_CHARACTER_PER_LINE" => Some(Self::OneCharacterPerLine),
                    "TRANSFORM_REPLACE_LINE_RETURNS" => Some(Self::ReplaceLineReturns),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Media {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(message, optional, tag = "2")]
    pub url: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<media::Metadata>,
    #[prost(oneof = "media::TypeProperties", tags = "4, 5, 6, 7, 8")]
    pub type_properties: ::core::option::Option<media::TypeProperties>,
}
/// Nested message and enum types in `Media`.
pub mod media {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metadata {
        #[prost(string, tag = "1")]
        pub manufacture_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub manufacture_url: ::core::option::Option<super::Url>,
        #[prost(string, tag = "3")]
        pub information: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub artist: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub format: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VideoDevice {
        #[prost(enumeration = "video_device::Type", tag = "1")]
        pub r#type: i32,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub unique_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub model_id: ::prost::alloc::string::String,
        #[prost(uint32, tag = "5")]
        pub format_index: u32,
        #[prost(message, optional, tag = "6")]
        pub audio_routing: ::core::option::Option<super::digital_audio::device::Routing>,
        #[prost(message, optional, tag = "7")]
        pub aircast: ::core::option::Option<video_device::AirCast>,
    }
    /// Nested message and enum types in `VideoDevice`.
    pub mod video_device {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AirCast {
            #[prost(string, tag = "1")]
            pub service_name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub password: ::prost::alloc::string::String,
            #[prost(bool, tag = "3")]
            pub password_enabled: bool,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            Generic = 0,
            Directshow = 1,
            Blackmagic = 2,
            Aja = 3,
            Av = 4,
            Syphon = 5,
            Ndi = 6,
            Bluefish = 7,
            Aircast = 8,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Type::Generic => "TYPE_GENERIC",
                    Type::Directshow => "TYPE_DIRECTSHOW",
                    Type::Blackmagic => "TYPE_BLACKMAGIC",
                    Type::Aja => "TYPE_AJA",
                    Type::Av => "TYPE_AV",
                    Type::Syphon => "TYPE_SYPHON",
                    Type::Ndi => "TYPE_NDI",
                    Type::Bluefish => "TYPE_BLUEFISH",
                    Type::Aircast => "TYPE_AIRCAST",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_GENERIC" => Some(Self::Generic),
                    "TYPE_DIRECTSHOW" => Some(Self::Directshow),
                    "TYPE_BLACKMAGIC" => Some(Self::Blackmagic),
                    "TYPE_AJA" => Some(Self::Aja),
                    "TYPE_AV" => Some(Self::Av),
                    "TYPE_SYPHON" => Some(Self::Syphon),
                    "TYPE_NDI" => Some(Self::Ndi),
                    "TYPE_BLUEFISH" => Some(Self::Bluefish),
                    "TYPE_AIRCAST" => Some(Self::Aircast),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AudioDevice {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub unique_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub model_id: ::prost::alloc::string::String,
        #[prost(uint32, tag = "4")]
        pub channel_count: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Audio {}
    /// Nested message and enum types in `Audio`.
    pub mod audio {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Channel {
            #[prost(uint32, tag = "1")]
            pub index: u32,
            #[prost(bool, tag = "2")]
            pub muted: bool,
            #[prost(double, tag = "3")]
            pub volume: f64,
            #[prost(bool, tag = "4")]
            pub compress_limit: bool,
            #[prost(message, repeated, tag = "5")]
            pub outputs: ::prost::alloc::vec::Vec<channel::Output>,
        }
        /// Nested message and enum types in `Channel`.
        pub mod channel {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Output {
                #[prost(int32, tag = "2")]
                pub channel_index: i32,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AudioProperties {
        #[prost(double, tag = "1")]
        pub volume: f64,
        #[prost(message, repeated, tag = "2")]
        pub audio_channels: ::prost::alloc::vec::Vec<audio::Channel>,
        #[prost(bool, tag = "3")]
        pub is_custom_mapping: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransportProperties {
        #[prost(double, tag = "1")]
        pub play_rate: f64,
        #[prost(double, tag = "2")]
        pub in_point: f64,
        #[prost(double, tag = "3")]
        pub out_point: f64,
        #[prost(double, tag = "7")]
        pub fade_in_duration: f64,
        #[prost(double, tag = "8")]
        pub fade_out_duration: f64,
        #[prost(bool, tag = "9")]
        pub should_fade_in: bool,
        #[prost(bool, tag = "10")]
        pub should_fade_out: bool,
        #[prost(double, tag = "11")]
        pub end_point: f64,
        #[prost(enumeration = "transport_properties::PlaybackBehavior", tag = "12")]
        pub playback_behavior: i32,
        #[prost(double, tag = "13")]
        pub loop_time: f64,
        #[prost(uint32, tag = "14")]
        pub times_to_loop: u32,
        #[prost(enumeration = "transport_properties::RetriggerSetting", tag = "15")]
        pub retrigger: i32,
    }
    /// Nested message and enum types in `TransportProperties`.
    pub mod transport_properties {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PlaybackBehavior {
            Stop = 0,
            Loop = 1,
            LoopForCount = 2,
            LoopForTime = 3,
        }
        impl PlaybackBehavior {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    PlaybackBehavior::Stop => "PLAYBACK_BEHAVIOR_STOP",
                    PlaybackBehavior::Loop => "PLAYBACK_BEHAVIOR_LOOP",
                    PlaybackBehavior::LoopForCount => "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT",
                    PlaybackBehavior::LoopForTime => "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PLAYBACK_BEHAVIOR_STOP" => Some(Self::Stop),
                    "PLAYBACK_BEHAVIOR_LOOP" => Some(Self::Loop),
                    "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT" => Some(Self::LoopForCount),
                    "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME" => Some(Self::LoopForTime),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum RetriggerSetting {
            Unset = 0,
            Always = 1,
            Never = 2,
            Automatic = 3,
        }
        impl RetriggerSetting {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    RetriggerSetting::Unset => "RETRIGGER_SETTING_UNSET",
                    RetriggerSetting::Always => "RETRIGGER_SETTING_ALWAYS",
                    RetriggerSetting::Never => "RETRIGGER_SETTING_NEVER",
                    RetriggerSetting::Automatic => "RETRIGGER_SETTING_AUTOMATIC",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "RETRIGGER_SETTING_UNSET" => Some(Self::Unset),
                    "RETRIGGER_SETTING_ALWAYS" => Some(Self::Always),
                    "RETRIGGER_SETTING_NEVER" => Some(Self::Never),
                    "RETRIGGER_SETTING_AUTOMATIC" => Some(Self::Automatic),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DrawingProperties {
        #[prost(enumeration = "ScaleBehavior", tag = "1")]
        pub scale_behavior: i32,
        #[prost(bool, tag = "16")]
        pub is_blurred: bool,
        #[prost(enumeration = "ScaleAlignment", tag = "2")]
        pub scale_alignment: i32,
        #[prost(bool, tag = "3")]
        pub flipped_horizontally: bool,
        #[prost(bool, tag = "4")]
        pub flipped_vertically: bool,
        #[prost(message, optional, tag = "5")]
        pub natural_size: ::core::option::Option<super::graphics::Size>,
        #[prost(double, tag = "6")]
        pub custom_image_rotation: f64,
        #[prost(message, optional, tag = "7")]
        pub custom_image_bounds: ::core::option::Option<super::graphics::Rect>,
        #[prost(bool, tag = "8")]
        pub custom_image_aspect_locked: bool,
        #[prost(bool, tag = "9")]
        pub alpha_inverted: bool,
        #[prost(enumeration = "drawing_properties::NativeRotationType", tag = "10")]
        pub native_rotation: i32,
        #[prost(message, optional, tag = "11")]
        pub selected_effect_preset_uuid: ::core::option::Option<super::Uuid>,
        #[prost(message, repeated, tag = "12")]
        pub effects: ::prost::alloc::vec::Vec<super::Effect>,
        #[prost(bool, tag = "13")]
        pub crop_enable: bool,
        #[prost(message, optional, tag = "14")]
        pub crop_insets: ::core::option::Option<super::graphics::EdgeInsets>,
        #[prost(enumeration = "super::AlphaType", tag = "15")]
        pub alpha_type: i32,
    }
    /// Nested message and enum types in `DrawingProperties`.
    pub mod drawing_properties {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum NativeRotationType {
            RotateStandard = 0,
            Rotate90 = 90,
            Rotate180 = 180,
            Rotate270 = 270,
        }
        impl NativeRotationType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    NativeRotationType::RotateStandard => {
                        "NATIVE_ROTATION_TYPE_ROTATE_STANDARD"
                    }
                    NativeRotationType::Rotate90 => "NATIVE_ROTATION_TYPE_ROTATE_90",
                    NativeRotationType::Rotate180 => "NATIVE_ROTATION_TYPE_ROTATE_180",
                    NativeRotationType::Rotate270 => "NATIVE_ROTATION_TYPE_ROTATE_270",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NATIVE_ROTATION_TYPE_ROTATE_STANDARD" => Some(Self::RotateStandard),
                    "NATIVE_ROTATION_TYPE_ROTATE_90" => Some(Self::Rotate90),
                    "NATIVE_ROTATION_TYPE_ROTATE_180" => Some(Self::Rotate180),
                    "NATIVE_ROTATION_TYPE_ROTATE_270" => Some(Self::Rotate270),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VideoProperties {
        #[prost(double, tag = "1")]
        pub frame_rate: f64,
        #[prost(enumeration = "video_properties::FieldType", tag = "2")]
        pub field_type: i32,
        #[prost(double, tag = "3")]
        pub thumbnail_position: f64,
        #[prost(enumeration = "video_properties::EndBehavior", tag = "4")]
        pub end_behavior: i32,
        #[prost(bool, tag = "5")]
        pub soft_loop: bool,
        #[prost(double, tag = "6")]
        pub soft_loop_duration: f64,
    }
    /// Nested message and enum types in `VideoProperties`.
    pub mod video_properties {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum EndBehavior {
            Stop = 0,
            StopOnBlack = 1,
            StopOnClear = 2,
            FadeToBlack = 3,
            FadeToClear = 4,
        }
        impl EndBehavior {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    EndBehavior::Stop => "END_BEHAVIOR_STOP",
                    EndBehavior::StopOnBlack => "END_BEHAVIOR_STOP_ON_BLACK",
                    EndBehavior::StopOnClear => "END_BEHAVIOR_STOP_ON_CLEAR",
                    EndBehavior::FadeToBlack => "END_BEHAVIOR_FADE_TO_BLACK",
                    EndBehavior::FadeToClear => "END_BEHAVIOR_FADE_TO_CLEAR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "END_BEHAVIOR_STOP" => Some(Self::Stop),
                    "END_BEHAVIOR_STOP_ON_BLACK" => Some(Self::StopOnBlack),
                    "END_BEHAVIOR_STOP_ON_CLEAR" => Some(Self::StopOnClear),
                    "END_BEHAVIOR_FADE_TO_BLACK" => Some(Self::FadeToBlack),
                    "END_BEHAVIOR_FADE_TO_CLEAR" => Some(Self::FadeToClear),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FieldType {
            Unknown = 0,
            Progressive = 1,
            InterlacedUpperFirst = 2,
            InterlacedLowerFirst = 3,
        }
        impl FieldType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    FieldType::Unknown => "FIELD_TYPE_UNKNOWN",
                    FieldType::Progressive => "FIELD_TYPE_PROGRESSIVE",
                    FieldType::InterlacedUpperFirst => {
                        "FIELD_TYPE_INTERLACED_UPPER_FIRST"
                    }
                    FieldType::InterlacedLowerFirst => {
                        "FIELD_TYPE_INTERLACED_LOWER_FIRST"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FIELD_TYPE_UNKNOWN" => Some(Self::Unknown),
                    "FIELD_TYPE_PROGRESSIVE" => Some(Self::Progressive),
                    "FIELD_TYPE_INTERLACED_UPPER_FIRST" => {
                        Some(Self::InterlacedUpperFirst)
                    }
                    "FIELD_TYPE_INTERLACED_LOWER_FIRST" => {
                        Some(Self::InterlacedLowerFirst)
                    }
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveVideoProperties {
        #[prost(message, optional, tag = "1")]
        pub video_device: ::core::option::Option<VideoDevice>,
        #[prost(message, optional, tag = "2")]
        pub audio_device: ::core::option::Option<AudioDevice>,
        #[prost(int32, tag = "3")]
        pub live_video_index: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AudioTypeProperties {
        #[prost(message, optional, tag = "1")]
        pub audio: ::core::option::Option<AudioProperties>,
        #[prost(message, optional, tag = "2")]
        pub transport: ::core::option::Option<TransportProperties>,
        #[prost(message, optional, tag = "3")]
        pub file: ::core::option::Option<super::FileProperties>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageTypeProperties {
        #[prost(message, optional, tag = "1")]
        pub drawing: ::core::option::Option<DrawingProperties>,
        #[prost(message, optional, tag = "2")]
        pub file: ::core::option::Option<super::FileProperties>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VideoTypeProperties {
        #[prost(message, optional, tag = "1")]
        pub drawing: ::core::option::Option<DrawingProperties>,
        #[prost(message, optional, tag = "2")]
        pub audio: ::core::option::Option<AudioProperties>,
        #[prost(message, optional, tag = "3")]
        pub transport: ::core::option::Option<TransportProperties>,
        #[prost(message, optional, tag = "4")]
        pub video: ::core::option::Option<VideoProperties>,
        #[prost(message, optional, tag = "5")]
        pub file: ::core::option::Option<super::FileProperties>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LiveVideoTypeProperties {
        #[prost(message, optional, tag = "1")]
        pub drawing: ::core::option::Option<DrawingProperties>,
        #[prost(message, optional, tag = "2")]
        pub audio: ::core::option::Option<AudioProperties>,
        #[prost(message, optional, tag = "3")]
        pub live_video: ::core::option::Option<LiveVideoProperties>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WebContentTypeProperties {
        #[prost(message, optional, tag = "1")]
        pub drawing: ::core::option::Option<DrawingProperties>,
        #[prost(message, optional, tag = "2")]
        pub url: ::core::option::Option<super::Url>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScaleBehavior {
        Fit = 0,
        Fill = 1,
        Stretch = 2,
        Custom = 3,
    }
    impl ScaleBehavior {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ScaleBehavior::Fit => "SCALE_BEHAVIOR_FIT",
                ScaleBehavior::Fill => "SCALE_BEHAVIOR_FILL",
                ScaleBehavior::Stretch => "SCALE_BEHAVIOR_STRETCH",
                ScaleBehavior::Custom => "SCALE_BEHAVIOR_CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCALE_BEHAVIOR_FIT" => Some(Self::Fit),
                "SCALE_BEHAVIOR_FILL" => Some(Self::Fill),
                "SCALE_BEHAVIOR_STRETCH" => Some(Self::Stretch),
                "SCALE_BEHAVIOR_CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScaleAlignment {
        MiddleCenter = 0,
        TopLeft = 1,
        TopCenter = 2,
        TopRight = 3,
        MiddleRight = 4,
        BottomRight = 5,
        BottomCenter = 6,
        BottomLeft = 7,
        MiddleLeft = 8,
    }
    impl ScaleAlignment {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ScaleAlignment::MiddleCenter => "SCALE_ALIGNMENT_MIDDLE_CENTER",
                ScaleAlignment::TopLeft => "SCALE_ALIGNMENT_TOP_LEFT",
                ScaleAlignment::TopCenter => "SCALE_ALIGNMENT_TOP_CENTER",
                ScaleAlignment::TopRight => "SCALE_ALIGNMENT_TOP_RIGHT",
                ScaleAlignment::MiddleRight => "SCALE_ALIGNMENT_MIDDLE_RIGHT",
                ScaleAlignment::BottomRight => "SCALE_ALIGNMENT_BOTTOM_RIGHT",
                ScaleAlignment::BottomCenter => "SCALE_ALIGNMENT_BOTTOM_CENTER",
                ScaleAlignment::BottomLeft => "SCALE_ALIGNMENT_BOTTOM_LEFT",
                ScaleAlignment::MiddleLeft => "SCALE_ALIGNMENT_MIDDLE_LEFT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCALE_ALIGNMENT_MIDDLE_CENTER" => Some(Self::MiddleCenter),
                "SCALE_ALIGNMENT_TOP_LEFT" => Some(Self::TopLeft),
                "SCALE_ALIGNMENT_TOP_CENTER" => Some(Self::TopCenter),
                "SCALE_ALIGNMENT_TOP_RIGHT" => Some(Self::TopRight),
                "SCALE_ALIGNMENT_MIDDLE_RIGHT" => Some(Self::MiddleRight),
                "SCALE_ALIGNMENT_BOTTOM_RIGHT" => Some(Self::BottomRight),
                "SCALE_ALIGNMENT_BOTTOM_CENTER" => Some(Self::BottomCenter),
                "SCALE_ALIGNMENT_BOTTOM_LEFT" => Some(Self::BottomLeft),
                "SCALE_ALIGNMENT_MIDDLE_LEFT" => Some(Self::MiddleLeft),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TypeProperties {
        #[prost(message, tag = "4")]
        Audio(AudioTypeProperties),
        #[prost(message, tag = "5")]
        Image(ImageTypeProperties),
        #[prost(message, tag = "6")]
        Video(VideoTypeProperties),
        #[prost(message, tag = "7")]
        LiveVideo(LiveVideoTypeProperties),
        #[prost(message, tag = "8")]
        WebContent(WebContentTypeProperties),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoInput {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub user_description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub video_input_device: ::core::option::Option<media::VideoDevice>,
    #[prost(message, optional, tag = "4")]
    pub display_color: ::core::option::Option<Color>,
    #[prost(message, optional, tag = "5")]
    pub thumbnail_path: ::core::option::Option<Url>,
    #[prost(enumeration = "video_input::AudioDeviceType", tag = "8")]
    pub audio_type: i32,
    #[prost(enumeration = "AlphaType", tag = "9")]
    pub alpha_type: i32,
    #[prost(oneof = "video_input::AltAudioSource", tags = "6, 7")]
    pub alt_audio_source: ::core::option::Option<video_input::AltAudioSource>,
}
/// Nested message and enum types in `VideoInput`.
pub mod video_input {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SettingsDocument {
        #[prost(message, repeated, tag = "1")]
        pub inputs: ::prost::alloc::vec::Vec<super::VideoInput>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudioDeviceType {
        Default = 0,
        None = 1,
        Alternate = 2,
    }
    impl AudioDeviceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AudioDeviceType::Default => "AUDIO_DEVICE_TYPE_DEFAULT",
                AudioDeviceType::None => "AUDIO_DEVICE_TYPE_NONE",
                AudioDeviceType::Alternate => "AUDIO_DEVICE_TYPE_ALTERNATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIO_DEVICE_TYPE_DEFAULT" => Some(Self::Default),
                "AUDIO_DEVICE_TYPE_NONE" => Some(Self::None),
                "AUDIO_DEVICE_TYPE_ALTERNATE" => Some(Self::Alternate),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AltAudioSource {
        #[prost(message, tag = "6")]
        AudioDevice(super::digital_audio::Device),
        #[prost(message, tag = "7")]
        VideoDevice(super::media::VideoDevice),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioInput {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub user_description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub behavior_mode: ::core::option::Option<audio_input::BehaviorMode>,
    #[prost(oneof = "audio_input::Source", tags = "3, 4")]
    pub source: ::core::option::Option<audio_input::Source>,
}
/// Nested message and enum types in `AudioInput`.
pub mod audio_input {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BehaviorMode {
        #[prost(oneof = "behavior_mode::Mode", tags = "1, 2, 3, 4")]
        pub mode: ::core::option::Option<behavior_mode::Mode>,
    }
    /// Nested message and enum types in `BehaviorMode`.
    pub mod behavior_mode {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct On {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Off {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AutoOff {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AutoOn {
            #[prost(uint32, repeated, tag = "1")]
            pub linked_video_inputs: ::prost::alloc::vec::Vec<u32>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Mode {
            #[prost(message, tag = "1")]
            On(On),
            #[prost(message, tag = "2")]
            Off(Off),
            #[prost(message, tag = "3")]
            AutoOn(AutoOn),
            #[prost(message, tag = "4")]
            AutoOff(AutoOff),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "3")]
        AudioDevice(super::digital_audio::Device),
        #[prost(message, tag = "4")]
        VideoDevice(super::media::VideoDevice),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Background {
    #[prost(bool, tag = "3")]
    pub is_enabled: bool,
    #[prost(oneof = "background::Fill", tags = "1, 2")]
    pub fill: ::core::option::Option<background::Fill>,
}
/// Nested message and enum types in `Background`.
pub mod background {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Fill {
        #[prost(message, tag = "1")]
        Color(super::Color),
        #[prost(message, tag = "2")]
        Gradient(super::graphics::Gradient),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionElementType {
    #[prost(message, optional, tag = "1")]
    pub parameter_uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub parameter_name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "3")]
    pub parent_collection: ::core::option::Option<
        ::prost::alloc::boxed::Box<CollectionElementType>,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HotKey {
    #[prost(enumeration = "KeyCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub control_identifier: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyCode {
    Unknown = 0,
    AnsiA = 1,
    AnsiB = 2,
    AnsiC = 3,
    AnsiD = 4,
    AnsiE = 5,
    AnsiF = 6,
    AnsiG = 7,
    AnsiH = 8,
    AnsiI = 9,
    AnsiJ = 10,
    AnsiK = 11,
    AnsiL = 12,
    AnsiM = 13,
    AnsiN = 14,
    AnsiO = 15,
    AnsiP = 16,
    AnsiQ = 17,
    AnsiR = 18,
    AnsiS = 19,
    AnsiT = 20,
    AnsiU = 21,
    AnsiV = 22,
    AnsiW = 23,
    AnsiX = 24,
    AnsiY = 25,
    AnsiZ = 26,
    Ansi0 = 27,
    Ansi1 = 28,
    Ansi2 = 29,
    Ansi3 = 30,
    Ansi4 = 31,
    Ansi5 = 32,
    Ansi6 = 33,
    Ansi7 = 34,
    Ansi8 = 35,
    Ansi9 = 36,
    AnsiEqual = 37,
    AnsiMinus = 38,
    AnsiRightBracket = 39,
    AnsiLeftBracket = 40,
    AnsiQuote = 41,
    AnsiSemicolon = 42,
    AnsiBackslash = 43,
    AnsiComma = 44,
    AnsiSlash = 45,
    AnsiPeriod = 46,
    AnsiGrave = 47,
    AnsiKeypadDecimal = 48,
    AnsiKeypadPlus = 49,
    AnsiKeypadClear = 50,
    AnsiKeypadDivide = 51,
    AnsiKeypadEnter = 52,
    AnsiKeypadMinus = 53,
    AnsiKeypadEquals = 54,
    AnsiKeypad0 = 55,
    AnsiKeypad1 = 56,
    AnsiKeypad2 = 57,
    AnsiKeypad3 = 58,
    AnsiKeypad4 = 59,
    AnsiKeypad5 = 60,
    AnsiKeypad6 = 61,
    AnsiKeypad7 = 62,
    AnsiKeypad8 = 63,
    AnsiKeypad9 = 64,
    F1 = 65,
    F2 = 66,
    F3 = 67,
    F4 = 68,
    F5 = 69,
    F6 = 70,
    F7 = 71,
    F8 = 72,
    F9 = 73,
    F10 = 74,
    F11 = 75,
    F12 = 76,
    F13 = 77,
    F14 = 78,
    F15 = 79,
    F16 = 80,
    F17 = 81,
    F18 = 82,
    F19 = 83,
    F20 = 84,
    Function = 85,
    Return = 86,
    Tab = 87,
    Space = 88,
    Delete = 89,
    Escape = 90,
    Command = 91,
    Shift = 92,
    CapsLock = 93,
    Option = 94,
    Control = 95,
    RightShift = 96,
    RightOption = 97,
    RightControl = 98,
    VolumeUp = 99,
    VolumeDown = 100,
    Mute = 101,
    Help = 102,
    Home = 103,
    PageUp = 104,
    ForwardDelete = 105,
    End = 106,
    PageDown = 107,
    LeftArrow = 108,
    RightArrow = 109,
    DownArrow = 110,
    UpArrow = 111,
    IsoSelection = 112,
    JisYen = 113,
    JisUnderscore = 114,
    JisKeypadComma = 115,
    JisEisu = 116,
    JisKana = 117,
}
impl KeyCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            KeyCode::Unknown => "KEY_CODE_UNKNOWN",
            KeyCode::AnsiA => "KEY_CODE_ANSI_A",
            KeyCode::AnsiB => "KEY_CODE_ANSI_B",
            KeyCode::AnsiC => "KEY_CODE_ANSI_C",
            KeyCode::AnsiD => "KEY_CODE_ANSI_D",
            KeyCode::AnsiE => "KEY_CODE_ANSI_E",
            KeyCode::AnsiF => "KEY_CODE_ANSI_F",
            KeyCode::AnsiG => "KEY_CODE_ANSI_G",
            KeyCode::AnsiH => "KEY_CODE_ANSI_H",
            KeyCode::AnsiI => "KEY_CODE_ANSI_I",
            KeyCode::AnsiJ => "KEY_CODE_ANSI_J",
            KeyCode::AnsiK => "KEY_CODE_ANSI_K",
            KeyCode::AnsiL => "KEY_CODE_ANSI_L",
            KeyCode::AnsiM => "KEY_CODE_ANSI_M",
            KeyCode::AnsiN => "KEY_CODE_ANSI_N",
            KeyCode::AnsiO => "KEY_CODE_ANSI_O",
            KeyCode::AnsiP => "KEY_CODE_ANSI_P",
            KeyCode::AnsiQ => "KEY_CODE_ANSI_Q",
            KeyCode::AnsiR => "KEY_CODE_ANSI_R",
            KeyCode::AnsiS => "KEY_CODE_ANSI_S",
            KeyCode::AnsiT => "KEY_CODE_ANSI_T",
            KeyCode::AnsiU => "KEY_CODE_ANSI_U",
            KeyCode::AnsiV => "KEY_CODE_ANSI_V",
            KeyCode::AnsiW => "KEY_CODE_ANSI_W",
            KeyCode::AnsiX => "KEY_CODE_ANSI_X",
            KeyCode::AnsiY => "KEY_CODE_ANSI_Y",
            KeyCode::AnsiZ => "KEY_CODE_ANSI_Z",
            KeyCode::Ansi0 => "KEY_CODE_ANSI_0",
            KeyCode::Ansi1 => "KEY_CODE_ANSI_1",
            KeyCode::Ansi2 => "KEY_CODE_ANSI_2",
            KeyCode::Ansi3 => "KEY_CODE_ANSI_3",
            KeyCode::Ansi4 => "KEY_CODE_ANSI_4",
            KeyCode::Ansi5 => "KEY_CODE_ANSI_5",
            KeyCode::Ansi6 => "KEY_CODE_ANSI_6",
            KeyCode::Ansi7 => "KEY_CODE_ANSI_7",
            KeyCode::Ansi8 => "KEY_CODE_ANSI_8",
            KeyCode::Ansi9 => "KEY_CODE_ANSI_9",
            KeyCode::AnsiEqual => "KEY_CODE_ANSI_EQUAL",
            KeyCode::AnsiMinus => "KEY_CODE_ANSI_MINUS",
            KeyCode::AnsiRightBracket => "KEY_CODE_ANSI_RIGHT_BRACKET",
            KeyCode::AnsiLeftBracket => "KEY_CODE_ANSI_LEFT_BRACKET",
            KeyCode::AnsiQuote => "KEY_CODE_ANSI_QUOTE",
            KeyCode::AnsiSemicolon => "KEY_CODE_ANSI_SEMICOLON",
            KeyCode::AnsiBackslash => "KEY_CODE_ANSI_BACKSLASH",
            KeyCode::AnsiComma => "KEY_CODE_ANSI_COMMA",
            KeyCode::AnsiSlash => "KEY_CODE_ANSI_SLASH",
            KeyCode::AnsiPeriod => "KEY_CODE_ANSI_PERIOD",
            KeyCode::AnsiGrave => "KEY_CODE_ANSI_GRAVE",
            KeyCode::AnsiKeypadDecimal => "KEY_CODE_ANSI_KEYPAD_DECIMAL",
            KeyCode::AnsiKeypadPlus => "KEY_CODE_ANSI_KEYPAD_PLUS",
            KeyCode::AnsiKeypadClear => "KEY_CODE_ANSI_KEYPAD_CLEAR",
            KeyCode::AnsiKeypadDivide => "KEY_CODE_ANSI_KEYPAD_DIVIDE",
            KeyCode::AnsiKeypadEnter => "KEY_CODE_ANSI_KEYPAD_ENTER",
            KeyCode::AnsiKeypadMinus => "KEY_CODE_ANSI_KEYPAD_MINUS",
            KeyCode::AnsiKeypadEquals => "KEY_CODE_ANSI_KEYPAD_EQUALS",
            KeyCode::AnsiKeypad0 => "KEY_CODE_ANSI_KEYPAD_0",
            KeyCode::AnsiKeypad1 => "KEY_CODE_ANSI_KEYPAD_1",
            KeyCode::AnsiKeypad2 => "KEY_CODE_ANSI_KEYPAD_2",
            KeyCode::AnsiKeypad3 => "KEY_CODE_ANSI_KEYPAD_3",
            KeyCode::AnsiKeypad4 => "KEY_CODE_ANSI_KEYPAD_4",
            KeyCode::AnsiKeypad5 => "KEY_CODE_ANSI_KEYPAD_5",
            KeyCode::AnsiKeypad6 => "KEY_CODE_ANSI_KEYPAD_6",
            KeyCode::AnsiKeypad7 => "KEY_CODE_ANSI_KEYPAD_7",
            KeyCode::AnsiKeypad8 => "KEY_CODE_ANSI_KEYPAD_8",
            KeyCode::AnsiKeypad9 => "KEY_CODE_ANSI_KEYPAD_9",
            KeyCode::F1 => "KEY_CODE_F1",
            KeyCode::F2 => "KEY_CODE_F2",
            KeyCode::F3 => "KEY_CODE_F3",
            KeyCode::F4 => "KEY_CODE_F4",
            KeyCode::F5 => "KEY_CODE_F5",
            KeyCode::F6 => "KEY_CODE_F6",
            KeyCode::F7 => "KEY_CODE_F7",
            KeyCode::F8 => "KEY_CODE_F8",
            KeyCode::F9 => "KEY_CODE_F9",
            KeyCode::F10 => "KEY_CODE_F10",
            KeyCode::F11 => "KEY_CODE_F11",
            KeyCode::F12 => "KEY_CODE_F12",
            KeyCode::F13 => "KEY_CODE_F13",
            KeyCode::F14 => "KEY_CODE_F14",
            KeyCode::F15 => "KEY_CODE_F15",
            KeyCode::F16 => "KEY_CODE_F16",
            KeyCode::F17 => "KEY_CODE_F17",
            KeyCode::F18 => "KEY_CODE_F18",
            KeyCode::F19 => "KEY_CODE_F19",
            KeyCode::F20 => "KEY_CODE_F20",
            KeyCode::Function => "KEY_CODE_FUNCTION",
            KeyCode::Return => "KEY_CODE_RETURN",
            KeyCode::Tab => "KEY_CODE_TAB",
            KeyCode::Space => "KEY_CODE_SPACE",
            KeyCode::Delete => "KEY_CODE_DELETE",
            KeyCode::Escape => "KEY_CODE_ESCAPE",
            KeyCode::Command => "KEY_CODE_COMMAND",
            KeyCode::Shift => "KEY_CODE_SHIFT",
            KeyCode::CapsLock => "KEY_CODE_CAPS_LOCK",
            KeyCode::Option => "KEY_CODE_OPTION",
            KeyCode::Control => "KEY_CODE_CONTROL",
            KeyCode::RightShift => "KEY_CODE_RIGHT_SHIFT",
            KeyCode::RightOption => "KEY_CODE_RIGHT_OPTION",
            KeyCode::RightControl => "KEY_CODE_RIGHT_CONTROL",
            KeyCode::VolumeUp => "KEY_CODE_VOLUME_UP",
            KeyCode::VolumeDown => "KEY_CODE_VOLUME_DOWN",
            KeyCode::Mute => "KEY_CODE_MUTE",
            KeyCode::Help => "KEY_CODE_HELP",
            KeyCode::Home => "KEY_CODE_HOME",
            KeyCode::PageUp => "KEY_CODE_PAGE_UP",
            KeyCode::ForwardDelete => "KEY_CODE_FORWARD_DELETE",
            KeyCode::End => "KEY_CODE_END",
            KeyCode::PageDown => "KEY_CODE_PAGE_DOWN",
            KeyCode::LeftArrow => "KEY_CODE_LEFT_ARROW",
            KeyCode::RightArrow => "KEY_CODE_RIGHT_ARROW",
            KeyCode::DownArrow => "KEY_CODE_DOWN_ARROW",
            KeyCode::UpArrow => "KEY_CODE_UP_ARROW",
            KeyCode::IsoSelection => "KEY_CODE_ISO_SELECTION",
            KeyCode::JisYen => "KEY_CODE_JIS_YEN",
            KeyCode::JisUnderscore => "KEY_CODE_JIS_UNDERSCORE",
            KeyCode::JisKeypadComma => "KEY_CODE_JIS_KEYPAD_COMMA",
            KeyCode::JisEisu => "KEY_CODE_JIS_EISU",
            KeyCode::JisKana => "KEY_CODE_JIS_KANA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_CODE_UNKNOWN" => Some(Self::Unknown),
            "KEY_CODE_ANSI_A" => Some(Self::AnsiA),
            "KEY_CODE_ANSI_B" => Some(Self::AnsiB),
            "KEY_CODE_ANSI_C" => Some(Self::AnsiC),
            "KEY_CODE_ANSI_D" => Some(Self::AnsiD),
            "KEY_CODE_ANSI_E" => Some(Self::AnsiE),
            "KEY_CODE_ANSI_F" => Some(Self::AnsiF),
            "KEY_CODE_ANSI_G" => Some(Self::AnsiG),
            "KEY_CODE_ANSI_H" => Some(Self::AnsiH),
            "KEY_CODE_ANSI_I" => Some(Self::AnsiI),
            "KEY_CODE_ANSI_J" => Some(Self::AnsiJ),
            "KEY_CODE_ANSI_K" => Some(Self::AnsiK),
            "KEY_CODE_ANSI_L" => Some(Self::AnsiL),
            "KEY_CODE_ANSI_M" => Some(Self::AnsiM),
            "KEY_CODE_ANSI_N" => Some(Self::AnsiN),
            "KEY_CODE_ANSI_O" => Some(Self::AnsiO),
            "KEY_CODE_ANSI_P" => Some(Self::AnsiP),
            "KEY_CODE_ANSI_Q" => Some(Self::AnsiQ),
            "KEY_CODE_ANSI_R" => Some(Self::AnsiR),
            "KEY_CODE_ANSI_S" => Some(Self::AnsiS),
            "KEY_CODE_ANSI_T" => Some(Self::AnsiT),
            "KEY_CODE_ANSI_U" => Some(Self::AnsiU),
            "KEY_CODE_ANSI_V" => Some(Self::AnsiV),
            "KEY_CODE_ANSI_W" => Some(Self::AnsiW),
            "KEY_CODE_ANSI_X" => Some(Self::AnsiX),
            "KEY_CODE_ANSI_Y" => Some(Self::AnsiY),
            "KEY_CODE_ANSI_Z" => Some(Self::AnsiZ),
            "KEY_CODE_ANSI_0" => Some(Self::Ansi0),
            "KEY_CODE_ANSI_1" => Some(Self::Ansi1),
            "KEY_CODE_ANSI_2" => Some(Self::Ansi2),
            "KEY_CODE_ANSI_3" => Some(Self::Ansi3),
            "KEY_CODE_ANSI_4" => Some(Self::Ansi4),
            "KEY_CODE_ANSI_5" => Some(Self::Ansi5),
            "KEY_CODE_ANSI_6" => Some(Self::Ansi6),
            "KEY_CODE_ANSI_7" => Some(Self::Ansi7),
            "KEY_CODE_ANSI_8" => Some(Self::Ansi8),
            "KEY_CODE_ANSI_9" => Some(Self::Ansi9),
            "KEY_CODE_ANSI_EQUAL" => Some(Self::AnsiEqual),
            "KEY_CODE_ANSI_MINUS" => Some(Self::AnsiMinus),
            "KEY_CODE_ANSI_RIGHT_BRACKET" => Some(Self::AnsiRightBracket),
            "KEY_CODE_ANSI_LEFT_BRACKET" => Some(Self::AnsiLeftBracket),
            "KEY_CODE_ANSI_QUOTE" => Some(Self::AnsiQuote),
            "KEY_CODE_ANSI_SEMICOLON" => Some(Self::AnsiSemicolon),
            "KEY_CODE_ANSI_BACKSLASH" => Some(Self::AnsiBackslash),
            "KEY_CODE_ANSI_COMMA" => Some(Self::AnsiComma),
            "KEY_CODE_ANSI_SLASH" => Some(Self::AnsiSlash),
            "KEY_CODE_ANSI_PERIOD" => Some(Self::AnsiPeriod),
            "KEY_CODE_ANSI_GRAVE" => Some(Self::AnsiGrave),
            "KEY_CODE_ANSI_KEYPAD_DECIMAL" => Some(Self::AnsiKeypadDecimal),
            "KEY_CODE_ANSI_KEYPAD_PLUS" => Some(Self::AnsiKeypadPlus),
            "KEY_CODE_ANSI_KEYPAD_CLEAR" => Some(Self::AnsiKeypadClear),
            "KEY_CODE_ANSI_KEYPAD_DIVIDE" => Some(Self::AnsiKeypadDivide),
            "KEY_CODE_ANSI_KEYPAD_ENTER" => Some(Self::AnsiKeypadEnter),
            "KEY_CODE_ANSI_KEYPAD_MINUS" => Some(Self::AnsiKeypadMinus),
            "KEY_CODE_ANSI_KEYPAD_EQUALS" => Some(Self::AnsiKeypadEquals),
            "KEY_CODE_ANSI_KEYPAD_0" => Some(Self::AnsiKeypad0),
            "KEY_CODE_ANSI_KEYPAD_1" => Some(Self::AnsiKeypad1),
            "KEY_CODE_ANSI_KEYPAD_2" => Some(Self::AnsiKeypad2),
            "KEY_CODE_ANSI_KEYPAD_3" => Some(Self::AnsiKeypad3),
            "KEY_CODE_ANSI_KEYPAD_4" => Some(Self::AnsiKeypad4),
            "KEY_CODE_ANSI_KEYPAD_5" => Some(Self::AnsiKeypad5),
            "KEY_CODE_ANSI_KEYPAD_6" => Some(Self::AnsiKeypad6),
            "KEY_CODE_ANSI_KEYPAD_7" => Some(Self::AnsiKeypad7),
            "KEY_CODE_ANSI_KEYPAD_8" => Some(Self::AnsiKeypad8),
            "KEY_CODE_ANSI_KEYPAD_9" => Some(Self::AnsiKeypad9),
            "KEY_CODE_F1" => Some(Self::F1),
            "KEY_CODE_F2" => Some(Self::F2),
            "KEY_CODE_F3" => Some(Self::F3),
            "KEY_CODE_F4" => Some(Self::F4),
            "KEY_CODE_F5" => Some(Self::F5),
            "KEY_CODE_F6" => Some(Self::F6),
            "KEY_CODE_F7" => Some(Self::F7),
            "KEY_CODE_F8" => Some(Self::F8),
            "KEY_CODE_F9" => Some(Self::F9),
            "KEY_CODE_F10" => Some(Self::F10),
            "KEY_CODE_F11" => Some(Self::F11),
            "KEY_CODE_F12" => Some(Self::F12),
            "KEY_CODE_F13" => Some(Self::F13),
            "KEY_CODE_F14" => Some(Self::F14),
            "KEY_CODE_F15" => Some(Self::F15),
            "KEY_CODE_F16" => Some(Self::F16),
            "KEY_CODE_F17" => Some(Self::F17),
            "KEY_CODE_F18" => Some(Self::F18),
            "KEY_CODE_F19" => Some(Self::F19),
            "KEY_CODE_F20" => Some(Self::F20),
            "KEY_CODE_FUNCTION" => Some(Self::Function),
            "KEY_CODE_RETURN" => Some(Self::Return),
            "KEY_CODE_TAB" => Some(Self::Tab),
            "KEY_CODE_SPACE" => Some(Self::Space),
            "KEY_CODE_DELETE" => Some(Self::Delete),
            "KEY_CODE_ESCAPE" => Some(Self::Escape),
            "KEY_CODE_COMMAND" => Some(Self::Command),
            "KEY_CODE_SHIFT" => Some(Self::Shift),
            "KEY_CODE_CAPS_LOCK" => Some(Self::CapsLock),
            "KEY_CODE_OPTION" => Some(Self::Option),
            "KEY_CODE_CONTROL" => Some(Self::Control),
            "KEY_CODE_RIGHT_SHIFT" => Some(Self::RightShift),
            "KEY_CODE_RIGHT_OPTION" => Some(Self::RightOption),
            "KEY_CODE_RIGHT_CONTROL" => Some(Self::RightControl),
            "KEY_CODE_VOLUME_UP" => Some(Self::VolumeUp),
            "KEY_CODE_VOLUME_DOWN" => Some(Self::VolumeDown),
            "KEY_CODE_MUTE" => Some(Self::Mute),
            "KEY_CODE_HELP" => Some(Self::Help),
            "KEY_CODE_HOME" => Some(Self::Home),
            "KEY_CODE_PAGE_UP" => Some(Self::PageUp),
            "KEY_CODE_FORWARD_DELETE" => Some(Self::ForwardDelete),
            "KEY_CODE_END" => Some(Self::End),
            "KEY_CODE_PAGE_DOWN" => Some(Self::PageDown),
            "KEY_CODE_LEFT_ARROW" => Some(Self::LeftArrow),
            "KEY_CODE_RIGHT_ARROW" => Some(Self::RightArrow),
            "KEY_CODE_DOWN_ARROW" => Some(Self::DownArrow),
            "KEY_CODE_UP_ARROW" => Some(Self::UpArrow),
            "KEY_CODE_ISO_SELECTION" => Some(Self::IsoSelection),
            "KEY_CODE_JIS_YEN" => Some(Self::JisYen),
            "KEY_CODE_JIS_UNDERSCORE" => Some(Self::JisUnderscore),
            "KEY_CODE_JIS_KEYPAD_COMMA" => Some(Self::JisKeypadComma),
            "KEY_CODE_JIS_EISU" => Some(Self::JisEisu),
            "KEY_CODE_JIS_KANA" => Some(Self::JisKana),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Layer {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Color>,
    #[prost(bool, tag = "4")]
    pub muted: bool,
    #[prost(bool, tag = "5")]
    pub hidden: bool,
    #[prost(enumeration = "layer::BlendMode", tag = "6")]
    pub blend_mode: i32,
    #[prost(double, tag = "7")]
    pub opacity: f64,
    #[prost(message, optional, tag = "8")]
    pub selected_target_set_uuid: ::core::option::Option<Uuid>,
    #[prost(message, optional, tag = "9")]
    pub effects_preset_uuid: ::core::option::Option<Uuid>,
    #[prost(double, tag = "10")]
    pub effects_build_duration: f64,
    #[prost(message, optional, tag = "11")]
    pub layer_preset_uuid: ::core::option::Option<Uuid>,
    #[prost(message, optional, tag = "12")]
    pub hot_key: ::core::option::Option<HotKey>,
    #[prost(message, optional, tag = "13")]
    pub transition: ::core::option::Option<Transition>,
    #[prost(message, repeated, tag = "14")]
    pub effects: ::prost::alloc::vec::Vec<Effect>,
    #[prost(message, optional, tag = "15")]
    pub blend: ::core::option::Option<layer::Blending>,
}
/// Nested message and enum types in `Layer`.
pub mod layer {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Preset {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub layer: ::core::option::Option<super::Layer>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Blending {
        #[prost(oneof = "blending::BlendingType", tags = "1, 2")]
        pub blending_type: ::core::option::Option<blending::BlendingType>,
    }
    /// Nested message and enum types in `Blending`.
    pub mod blending {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Standard {
            #[prost(enumeration = "super::BlendMode", tag = "1")]
            pub mode: i32,
            #[prost(double, tag = "2")]
            pub opacity: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Matte {
            #[prost(oneof = "matte::MatteType", tags = "1, 2, 4")]
            pub matte_type: ::core::option::Option<matte::MatteType>,
        }
        /// Nested message and enum types in `Matte`.
        pub mod matte {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Alpha {
                #[prost(bool, tag = "1")]
                pub inverted: bool,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Luma {
                #[prost(bool, tag = "1")]
                pub inverted: bool,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct White {}
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum MatteType {
                #[prost(message, tag = "1")]
                Alpha(Alpha),
                #[prost(message, tag = "2")]
                Luma(Luma),
                #[prost(message, tag = "4")]
                White(White),
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum BlendingType {
            #[prost(message, tag = "1")]
            Standard(Standard),
            #[prost(message, tag = "2")]
            Matte(Matte),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BlendMode {
        Normal = 0,
        Dissolve = 1,
        Darken = 2,
        Multiply = 3,
        ColorBurn = 4,
        LinearBurn = 5,
        DarkerColor = 6,
        Lighten = 7,
        Screen = 8,
        ColorDodge = 9,
        LinearDodge = 10,
        LighterColor = 11,
        Overlay = 12,
        SoftLight = 13,
        HardLight = 14,
        VividLight = 15,
        LinearLight = 16,
        PinLight = 17,
        HardMix = 18,
        Difference = 19,
        Exclusion = 20,
        Subtract = 21,
        Divide = 22,
        Hue = 23,
        Saturation = 24,
        Color = 25,
        Luminosity = 26,
    }
    impl BlendMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BlendMode::Normal => "BLEND_MODE_NORMAL",
                BlendMode::Dissolve => "BLEND_MODE_DISSOLVE",
                BlendMode::Darken => "BLEND_MODE_DARKEN",
                BlendMode::Multiply => "BLEND_MODE_MULTIPLY",
                BlendMode::ColorBurn => "BLEND_MODE_COLOR_BURN",
                BlendMode::LinearBurn => "BLEND_MODE_LINEAR_BURN",
                BlendMode::DarkerColor => "BLEND_MODE_DARKER_COLOR",
                BlendMode::Lighten => "BLEND_MODE_LIGHTEN",
                BlendMode::Screen => "BLEND_MODE_SCREEN",
                BlendMode::ColorDodge => "BLEND_MODE_COLOR_DODGE",
                BlendMode::LinearDodge => "BLEND_MODE_LINEAR_DODGE",
                BlendMode::LighterColor => "BLEND_MODE_LIGHTER_COLOR",
                BlendMode::Overlay => "BLEND_MODE_OVERLAY",
                BlendMode::SoftLight => "BLEND_MODE_SOFT_LIGHT",
                BlendMode::HardLight => "BLEND_MODE_HARD_LIGHT",
                BlendMode::VividLight => "BLEND_MODE_VIVID_LIGHT",
                BlendMode::LinearLight => "BLEND_MODE_LINEAR_LIGHT",
                BlendMode::PinLight => "BLEND_MODE_PIN_LIGHT",
                BlendMode::HardMix => "BLEND_MODE_HARD_MIX",
                BlendMode::Difference => "BLEND_MODE_DIFFERENCE",
                BlendMode::Exclusion => "BLEND_MODE_EXCLUSION",
                BlendMode::Subtract => "BLEND_MODE_SUBTRACT",
                BlendMode::Divide => "BLEND_MODE_DIVIDE",
                BlendMode::Hue => "BLEND_MODE_HUE",
                BlendMode::Saturation => "BLEND_MODE_SATURATION",
                BlendMode::Color => "BLEND_MODE_COLOR",
                BlendMode::Luminosity => "BLEND_MODE_LUMINOSITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BLEND_MODE_NORMAL" => Some(Self::Normal),
                "BLEND_MODE_DISSOLVE" => Some(Self::Dissolve),
                "BLEND_MODE_DARKEN" => Some(Self::Darken),
                "BLEND_MODE_MULTIPLY" => Some(Self::Multiply),
                "BLEND_MODE_COLOR_BURN" => Some(Self::ColorBurn),
                "BLEND_MODE_LINEAR_BURN" => Some(Self::LinearBurn),
                "BLEND_MODE_DARKER_COLOR" => Some(Self::DarkerColor),
                "BLEND_MODE_LIGHTEN" => Some(Self::Lighten),
                "BLEND_MODE_SCREEN" => Some(Self::Screen),
                "BLEND_MODE_COLOR_DODGE" => Some(Self::ColorDodge),
                "BLEND_MODE_LINEAR_DODGE" => Some(Self::LinearDodge),
                "BLEND_MODE_LIGHTER_COLOR" => Some(Self::LighterColor),
                "BLEND_MODE_OVERLAY" => Some(Self::Overlay),
                "BLEND_MODE_SOFT_LIGHT" => Some(Self::SoftLight),
                "BLEND_MODE_HARD_LIGHT" => Some(Self::HardLight),
                "BLEND_MODE_VIVID_LIGHT" => Some(Self::VividLight),
                "BLEND_MODE_LINEAR_LIGHT" => Some(Self::LinearLight),
                "BLEND_MODE_PIN_LIGHT" => Some(Self::PinLight),
                "BLEND_MODE_HARD_MIX" => Some(Self::HardMix),
                "BLEND_MODE_DIFFERENCE" => Some(Self::Difference),
                "BLEND_MODE_EXCLUSION" => Some(Self::Exclusion),
                "BLEND_MODE_SUBTRACT" => Some(Self::Subtract),
                "BLEND_MODE_DIVIDE" => Some(Self::Divide),
                "BLEND_MODE_HUE" => Some(Self::Hue),
                "BLEND_MODE_SATURATION" => Some(Self::Saturation),
                "BLEND_MODE_COLOR" => Some(Self::Color),
                "BLEND_MODE_LUMINOSITY" => Some(Self::Luminosity),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    #[prost(uint32, tag = "1")]
    pub major_version: u32,
    #[prost(uint32, tag = "2")]
    pub minor_version: u32,
    #[prost(uint32, tag = "3")]
    pub patch_version: u32,
    #[prost(string, tag = "4")]
    pub build: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationInfo {
    #[prost(enumeration = "application_info::Platform", tag = "1")]
    pub platform: i32,
    #[prost(message, optional, tag = "2")]
    pub platform_version: ::core::option::Option<Version>,
    #[prost(enumeration = "application_info::Application", tag = "3")]
    pub application: i32,
    #[prost(message, optional, tag = "4")]
    pub application_version: ::core::option::Option<Version>,
}
/// Nested message and enum types in `ApplicationInfo`.
pub mod application_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Platform {
        Undefined = 0,
        Macos = 1,
        Windows = 2,
    }
    impl Platform {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Platform::Undefined => "PLATFORM_UNDEFINED",
                Platform::Macos => "PLATFORM_MACOS",
                Platform::Windows => "PLATFORM_WINDOWS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PLATFORM_UNDEFINED" => Some(Self::Undefined),
                "PLATFORM_MACOS" => Some(Self::Macos),
                "PLATFORM_WINDOWS" => Some(Self::Windows),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Application {
        Undefined = 0,
        Propresenter = 1,
        Pvp = 2,
        Provideoserver = 3,
        Scoreboard = 4,
    }
    impl Application {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Application::Undefined => "APPLICATION_UNDEFINED",
                Application::Propresenter => "APPLICATION_PROPRESENTER",
                Application::Pvp => "APPLICATION_PVP",
                Application::Provideoserver => "APPLICATION_PROVIDEOSERVER",
                Application::Scoreboard => "APPLICATION_SCOREBOARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPLICATION_UNDEFINED" => Some(Self::Undefined),
                "APPLICATION_PROPRESENTER" => Some(Self::Propresenter),
                "APPLICATION_PVP" => Some(Self::Pvp),
                "APPLICATION_PROVIDEOSERVER" => Some(Self::Provideoserver),
                "APPLICATION_SCOREBOARD" => Some(Self::Scoreboard),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateIdentification {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub slide_uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "4")]
    pub slide_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub slide_index: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Clock {
    #[prost(string, tag = "1")]
    pub format: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Clock`.
pub mod clock {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Format {
        #[prost(enumeration = "format::DateFormatterStyle", tag = "2")]
        pub date_type: i32,
        #[prost(enumeration = "format::DateFormatterStyle", tag = "3")]
        pub time_format: i32,
        #[prost(bool, tag = "4")]
        pub military_time_enabled: bool,
    }
    /// Nested message and enum types in `Format`.
    pub mod format {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum DateFormatterStyle {
            None = 0,
            Short = 1,
            Medium = 2,
            Long = 3,
            Full = 4,
        }
        impl DateFormatterStyle {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    DateFormatterStyle::None => "DATE_FORMATTER_STYLE_NONE",
                    DateFormatterStyle::Short => "DATE_FORMATTER_STYLE_SHORT",
                    DateFormatterStyle::Medium => "DATE_FORMATTER_STYLE_MEDIUM",
                    DateFormatterStyle::Long => "DATE_FORMATTER_STYLE_LONG",
                    DateFormatterStyle::Full => "DATE_FORMATTER_STYLE_FULL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DATE_FORMATTER_STYLE_NONE" => Some(Self::None),
                    "DATE_FORMATTER_STYLE_SHORT" => Some(Self::Short),
                    "DATE_FORMATTER_STYLE_MEDIUM" => Some(Self::Medium),
                    "DATE_FORMATTER_STYLE_LONG" => Some(Self::Long),
                    "DATE_FORMATTER_STYLE_FULL" => Some(Self::Full),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Timer {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub configuration: ::core::option::Option<timer::Configuration>,
}
/// Nested message and enum types in `Timer`.
pub mod timer {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Format {
        #[prost(enumeration = "format::Style", tag = "1")]
        pub hour: i32,
        #[prost(enumeration = "format::Style", tag = "2")]
        pub minute: i32,
        #[prost(enumeration = "format::Style", tag = "3")]
        pub second: i32,
        #[prost(enumeration = "format::Style", tag = "4")]
        pub millisecond: i32,
        #[prost(bool, tag = "5")]
        pub is_wall_clock_time: bool,
        #[prost(bool, tag = "6")]
        pub is_24_hour_time: bool,
        #[prost(bool, tag = "7")]
        pub show_milliseconds_under_minute_only: bool,
    }
    /// Nested message and enum types in `Format`.
    pub mod format {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Style {
            StyeNone = 0,
            Short = 1,
            Long = 2,
            RemoveShort = 3,
            RemoveLong = 4,
        }
        impl Style {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Style::StyeNone => "STYE_NONE",
                    Style::Short => "STYLE_SHORT",
                    Style::Long => "STYLE_LONG",
                    Style::RemoveShort => "STYLE_REMOVE_SHORT",
                    Style::RemoveLong => "STYLE_REMOVE_LONG",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STYE_NONE" => Some(Self::StyeNone),
                    "STYLE_SHORT" => Some(Self::Short),
                    "STYLE_LONG" => Some(Self::Long),
                    "STYLE_REMOVE_SHORT" => Some(Self::RemoveShort),
                    "STYLE_REMOVE_LONG" => Some(Self::RemoveLong),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Configuration {
        #[prost(bool, tag = "4")]
        pub allows_overrun: bool,
        #[prost(oneof = "configuration::TimerType", tags = "1, 2, 3")]
        pub timer_type: ::core::option::Option<configuration::TimerType>,
    }
    /// Nested message and enum types in `Configuration`.
    pub mod configuration {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TimerTypeCountdown {
            #[prost(double, tag = "1")]
            pub duration: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TimerTypeCountdownToTime {
            #[prost(double, tag = "1")]
            pub time_of_day: f64,
            #[prost(enumeration = "timer_type_countdown_to_time::TimePeriod", tag = "2")]
            pub period: i32,
        }
        /// Nested message and enum types in `TimerTypeCountdownToTime`.
        pub mod timer_type_countdown_to_time {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum TimePeriod {
                Am = 0,
                Pm = 1,
                TimePeriod24 = 2,
            }
            impl TimePeriod {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        TimePeriod::Am => "TIME_PERIOD_AM",
                        TimePeriod::Pm => "TIME_PERIOD_PM",
                        TimePeriod::TimePeriod24 => "TIME_PERIOD_24",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TIME_PERIOD_AM" => Some(Self::Am),
                        "TIME_PERIOD_PM" => Some(Self::Pm),
                        "TIME_PERIOD_24" => Some(Self::TimePeriod24),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TimerTypeElapsedTime {
            #[prost(double, tag = "1")]
            pub start_time: f64,
            #[prost(double, tag = "2")]
            pub end_time: f64,
            #[prost(bool, tag = "3")]
            pub has_end_time: bool,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum TimerType {
            #[prost(message, tag = "1")]
            Countdown(TimerTypeCountdown),
            #[prost(message, tag = "2")]
            CountdownToTime(TimerTypeCountdownToTime),
            #[prost(message, tag = "3")]
            ElapsedTime(TimerTypeElapsedTime),
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimersDocument {
    #[prost(message, optional, tag = "1")]
    pub application_info: ::core::option::Option<ApplicationInfo>,
    #[prost(message, optional, tag = "2")]
    pub clock: ::core::option::Option<Clock>,
    #[prost(message, repeated, tag = "3")]
    pub timers: ::prost::alloc::vec::Vec<Timer>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub time_to_remove: f64,
    #[prost(bool, tag = "4")]
    pub visible_on_network: bool,
    #[prost(message, optional, tag = "6")]
    pub template: ::core::option::Option<TemplateIdentification>,
    #[prost(enumeration = "message::ClearType", tag = "9")]
    pub clear_type: i32,
    #[prost(string, tag = "10")]
    pub message_text: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "11")]
    pub tokens: ::prost::alloc::vec::Vec<message::Token>,
    #[prost(message, repeated, tag = "12")]
    pub token_values: ::prost::alloc::vec::Vec<message::TokenValue>,
}
/// Nested message and enum types in `Message`.
pub mod message {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Token {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(oneof = "token::TokenType", tags = "2, 3, 4")]
        pub token_type: ::core::option::Option<token::TokenType>,
    }
    /// Nested message and enum types in `Token`.
    pub mod token {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TokenTypeText {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TokenTypeTimer {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub timer_uuid: ::core::option::Option<super::super::Uuid>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TokenTypeClock {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum TokenType {
            #[prost(message, tag = "2")]
            Text(TokenTypeText),
            #[prost(message, tag = "3")]
            Timer(TokenTypeTimer),
            #[prost(message, tag = "4")]
            Clock(TokenTypeClock),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TokenValue {
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "5")]
        pub token_name: ::prost::alloc::string::String,
        #[prost(oneof = "token_value::TokenValueType", tags = "2, 3, 4")]
        pub token_value_type: ::core::option::Option<token_value::TokenValueType>,
    }
    /// Nested message and enum types in `TokenValue`.
    pub mod token_value {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TokenValueText {
            #[prost(string, tag = "1")]
            pub value: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TokenValueTimer {
            #[prost(message, optional, tag = "1")]
            pub configuration: ::core::option::Option<
                super::super::timer::Configuration,
            >,
            #[prost(message, optional, tag = "2")]
            pub format: ::core::option::Option<super::super::timer::Format>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TokenValueClock {
            #[prost(message, optional, tag = "1")]
            pub format: ::core::option::Option<super::super::clock::Format>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum TokenValueType {
            #[prost(message, tag = "2")]
            Text(TokenValueText),
            #[prost(message, tag = "3")]
            Timer(TokenValueTimer),
            #[prost(message, tag = "4")]
            Clock(TokenValueClock),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClearType {
        Manual = 0,
        AfterTime = 1,
        AfterTimers = 2,
    }
    impl ClearType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ClearType::Manual => "CLEAR_TYPE_MANUAL",
                ClearType::AfterTime => "CLEAR_TYPE_AFTER_TIME",
                ClearType::AfterTimers => "CLEAR_TYPE_AFTER_TIMERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLEAR_TYPE_MANUAL" => Some(Self::Manual),
                "CLEAR_TYPE_AFTER_TIME" => Some(Self::AfterTime),
                "CLEAR_TYPE_AFTER_TIMERS" => Some(Self::AfterTimers),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageDocument {
    #[prost(message, optional, tag = "1")]
    pub application_info: ::core::option::Option<ApplicationInfo>,
    #[prost(message, repeated, tag = "2")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlignmentGuide {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(enumeration = "alignment_guide::GuidelineOrientation", tag = "2")]
    pub orientation: i32,
    #[prost(double, tag = "3")]
    pub location: f64,
}
/// Nested message and enum types in `AlignmentGuide`.
pub mod alignment_guide {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GuidelineOrientation {
        Horizontal = 0,
        Vertical = 1,
    }
    impl GuidelineOrientation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GuidelineOrientation::Horizontal => "GUIDELINE_ORIENTATION_HORIZONTAL",
                GuidelineOrientation::Vertical => "GUIDELINE_ORIENTATION_VERTICAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GUIDELINE_ORIENTATION_HORIZONTAL" => Some(Self::Horizontal),
                "GUIDELINE_ORIENTATION_VERTICAL" => Some(Self::Vertical),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Slide {
    #[prost(message, repeated, tag = "1")]
    pub elements: ::prost::alloc::vec::Vec<slide::Element>,
    #[prost(message, repeated, tag = "2")]
    pub element_build_order: ::prost::alloc::vec::Vec<Uuid>,
    #[prost(message, repeated, tag = "3")]
    pub guidelines: ::prost::alloc::vec::Vec<AlignmentGuide>,
    #[prost(bool, tag = "4")]
    pub draws_background_color: bool,
    #[prost(message, optional, tag = "5")]
    pub background_color: ::core::option::Option<Color>,
    #[prost(message, optional, tag = "6")]
    pub size: ::core::option::Option<graphics::Size>,
    #[prost(message, optional, tag = "7")]
    pub uuid: ::core::option::Option<Uuid>,
}
/// Nested message and enum types in `Slide`.
pub mod slide {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Element {
        #[prost(message, optional, tag = "1")]
        pub element: ::core::option::Option<super::graphics::Element>,
        #[prost(message, optional, tag = "2")]
        pub build_in: ::core::option::Option<element::Build>,
        #[prost(message, optional, tag = "3")]
        pub build_out: ::core::option::Option<element::Build>,
        #[prost(uint32, tag = "4")]
        pub info: u32,
        #[prost(enumeration = "element::TextRevealType", tag = "5")]
        pub reveal_type: i32,
        #[prost(message, repeated, tag = "6")]
        pub data_links: ::prost::alloc::vec::Vec<element::DataLink>,
        #[prost(message, repeated, tag = "7")]
        pub child_builds: ::prost::alloc::vec::Vec<element::ChildBuild>,
        #[prost(uint32, tag = "8")]
        pub reveal_from_index: u32,
        #[prost(message, optional, tag = "9")]
        pub text_scroller: ::core::option::Option<element::TextScroller>,
    }
    /// Nested message and enum types in `Element`.
    pub mod element {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Build {
            #[prost(message, optional, tag = "1")]
            pub uuid: ::core::option::Option<super::super::Uuid>,
            #[prost(message, optional, tag = "2")]
            pub element_uuid: ::core::option::Option<super::super::Uuid>,
            #[prost(enumeration = "build::Start", tag = "3")]
            pub start: i32,
            #[prost(double, tag = "4")]
            pub delay_time: f64,
            #[prost(message, optional, tag = "5")]
            pub transition: ::core::option::Option<super::super::Transition>,
        }
        /// Nested message and enum types in `Build`.
        pub mod build {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Start {
                OnClick = 0,
                WithPrevious = 1,
                AfterPrevious = 2,
                WithSlide = 3,
            }
            impl Start {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Start::OnClick => "START_ON_CLICK",
                        Start::WithPrevious => "START_WITH_PREVIOUS",
                        Start::AfterPrevious => "START_AFTER_PREVIOUS",
                        Start::WithSlide => "START_WITH_SLIDE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "START_ON_CLICK" => Some(Self::OnClick),
                        "START_WITH_PREVIOUS" => Some(Self::WithPrevious),
                        "START_AFTER_PREVIOUS" => Some(Self::AfterPrevious),
                        "START_WITH_SLIDE" => Some(Self::WithSlide),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ChildBuild {
            #[prost(message, optional, tag = "1")]
            pub uuid: ::core::option::Option<super::super::Uuid>,
            #[prost(enumeration = "build::Start", tag = "2")]
            pub start: i32,
            #[prost(double, tag = "3")]
            pub delay_time: f64,
            #[prost(uint32, tag = "4")]
            pub index: u32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DataLink {
            #[prost(
                oneof = "data_link::PropertyType",
                tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35"
            )]
            pub property_type: ::core::option::Option<data_link::PropertyType>,
        }
        /// Nested message and enum types in `DataLink`.
        pub mod data_link {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RssFeed {
                #[prost(message, optional, tag = "1")]
                pub url: ::core::option::Option<super::super::super::Url>,
                #[prost(enumeration = "rss_feed::ContentType", tag = "2")]
                pub content: i32,
                #[prost(string, tag = "3")]
                pub text_delimiter: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `RSSFeed`.
            pub mod rss_feed {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum ContentType {
                    TitleOnly = 0,
                    TitleAndDescription = 1,
                }
                impl ContentType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            ContentType::TitleOnly => "CONTENT_TYPE_TITLE_ONLY",
                            ContentType::TitleAndDescription => {
                                "CONTENT_TYPE_TITLE_AND_DESCRIPTION"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "CONTENT_TYPE_TITLE_ONLY" => Some(Self::TitleOnly),
                            "CONTENT_TYPE_TITLE_AND_DESCRIPTION" => {
                                Some(Self::TitleAndDescription)
                            }
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct FileFeed {
                #[prost(message, optional, tag = "1")]
                pub url: ::core::option::Option<super::super::super::Url>,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Ticker {
                #[prost(double, tag = "4")]
                pub play_rate: f64,
                #[prost(bool, tag = "5")]
                pub should_loop: bool,
                #[prost(double, tag = "6")]
                pub loop_delay: f64,
                #[prost(string, tag = "7")]
                pub text_delimiter: ::prost::alloc::string::String,
                #[prost(oneof = "ticker::SourceType", tags = "1, 2, 3")]
                pub source_type: ::core::option::Option<ticker::SourceType>,
            }
            /// Nested message and enum types in `Ticker`.
            pub mod ticker {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TextType {
                    #[prost(string, tag = "1")]
                    pub text: ::prost::alloc::string::String,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct RssType {
                    #[prost(message, optional, tag = "1")]
                    pub url: ::core::option::Option<super::super::super::super::Url>,
                    #[prost(enumeration = "rss_type::ContentType", tag = "2")]
                    pub content: i32,
                }
                /// Nested message and enum types in `RSSType`.
                pub mod rss_type {
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration
                    )]
                    #[repr(i32)]
                    pub enum ContentType {
                        TitleOnly = 0,
                        TitleAndDescription = 1,
                    }
                    impl ContentType {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                ContentType::TitleOnly => "CONTENT_TYPE_TITLE_ONLY",
                                ContentType::TitleAndDescription => {
                                    "CONTENT_TYPE_TITLE_AND_DESCRIPTION"
                                }
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(
                            value: &str,
                        ) -> ::core::option::Option<Self> {
                            match value {
                                "CONTENT_TYPE_TITLE_ONLY" => Some(Self::TitleOnly),
                                "CONTENT_TYPE_TITLE_AND_DESCRIPTION" => {
                                    Some(Self::TitleAndDescription)
                                }
                                _ => None,
                            }
                        }
                    }
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct FileType {
                    #[prost(message, optional, tag = "1")]
                    pub url: ::core::option::Option<super::super::super::super::Url>,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum SourceType {
                    #[prost(message, tag = "1")]
                    TextType(TextType),
                    #[prost(message, tag = "2")]
                    RssType(RssType),
                    #[prost(message, tag = "3")]
                    FileType(FileType),
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct AlternateElementText {
                #[prost(message, optional, tag = "1")]
                pub other_element_uuid: ::core::option::Option<
                    super::super::super::Uuid,
                >,
                #[prost(string, tag = "2")]
                pub other_element_name: ::prost::alloc::string::String,
                #[prost(uint32, tag = "3")]
                pub text_transform_options: u32,
                #[prost(
                    enumeration = "alternate_element_text::TextTransformOption",
                    tag = "4"
                )]
                pub text_transform: i32,
            }
            /// Nested message and enum types in `AlternateElementText`.
            pub mod alternate_element_text {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum TextTransformOption {
                    None = 0,
                    RemoveLineReturns = 1,
                    OneWordPerLine = 2,
                    OneCharacterPerLine = 3,
                }
                impl TextTransformOption {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            TextTransformOption::None => "TEXT_TRANSFORM_OPTION_NONE",
                            TextTransformOption::RemoveLineReturns => {
                                "TEXT_TRANSFORM_OPTION_REMOVE_LINE_RETURNS"
                            }
                            TextTransformOption::OneWordPerLine => {
                                "TEXT_TRANSFORM_OPTION_ONE_WORD_PER_LINE"
                            }
                            TextTransformOption::OneCharacterPerLine => {
                                "TEXT_TRANSFORM_OPTION_ONE_CHARACTER_PER_LINE"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "TEXT_TRANSFORM_OPTION_NONE" => Some(Self::None),
                            "TEXT_TRANSFORM_OPTION_REMOVE_LINE_RETURNS" => {
                                Some(Self::RemoveLineReturns)
                            }
                            "TEXT_TRANSFORM_OPTION_ONE_WORD_PER_LINE" => {
                                Some(Self::OneWordPerLine)
                            }
                            "TEXT_TRANSFORM_OPTION_ONE_CHARACTER_PER_LINE" => {
                                Some(Self::OneCharacterPerLine)
                            }
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct CcliText {}
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ColorTrigger {
                #[prost(double, tag = "1")]
                pub time: f64,
                #[prost(message, optional, tag = "2")]
                pub color: ::core::option::Option<super::super::super::Color>,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct TimerText {
                #[prost(message, optional, tag = "1")]
                pub timer_uuid: ::core::option::Option<super::super::super::Uuid>,
                #[prost(string, tag = "2")]
                pub timer_name: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub timer_format: ::core::option::Option<
                    super::super::super::timer::Format,
                >,
                #[prost(string, tag = "4")]
                pub timer_format_string: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "5")]
                pub color_triggers: ::prost::alloc::vec::Vec<ColorTrigger>,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ClockText {
                #[prost(string, tag = "1")]
                pub clock_format_string: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "5")]
                pub format: ::core::option::Option<super::super::super::clock::Format>,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ChordChart {}
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct OutputScreen {
                #[prost(message, optional, tag = "1")]
                pub screen_id: ::core::option::Option<super::super::super::Uuid>,
                #[prost(string, tag = "2")]
                pub screen_name: ::prost::alloc::string::String,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct PcoLive {
                #[prost(enumeration = "pco_live::Theme", tag = "2")]
                pub theme: i32,
                #[prost(enumeration = "pco_live::CountdownType", tag = "3")]
                pub countdown_type: i32,
            }
            /// Nested message and enum types in `PCOLive`.
            pub mod pco_live {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Theme {
                    PcoliveThemeLight = 0,
                    PcoliveThemeDark = 1,
                }
                impl Theme {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Theme::PcoliveThemeLight => "PCOLIVE_THEME_LIGHT",
                            Theme::PcoliveThemeDark => "PCOLIVE_THEME_DARK",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "PCOLIVE_THEME_LIGHT" => Some(Self::PcoliveThemeLight),
                            "PCOLIVE_THEME_DARK" => Some(Self::PcoliveThemeDark),
                            _ => None,
                        }
                    }
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum CountdownType {
                    FullItemLength = 0,
                    EndItemOnTime = 1,
                    EndServiceOnTime = 2,
                }
                impl CountdownType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            CountdownType::FullItemLength => {
                                "COUNTDOWN_TYPE_FULL_ITEM_LENGTH"
                            }
                            CountdownType::EndItemOnTime => {
                                "COUNTDOWN_TYPE_END_ITEM_ON_TIME"
                            }
                            CountdownType::EndServiceOnTime => {
                                "COUNTDOWN_TYPE_END_SERVICE_ON_TIME"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "COUNTDOWN_TYPE_FULL_ITEM_LENGTH" => {
                                Some(Self::FullItemLength)
                            }
                            "COUNTDOWN_TYPE_END_ITEM_ON_TIME" => {
                                Some(Self::EndItemOnTime)
                            }
                            "COUNTDOWN_TYPE_END_SERVICE_ON_TIME" => {
                                Some(Self::EndServiceOnTime)
                            }
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct AlternateElementFill {
                #[prost(message, optional, tag = "1")]
                pub other_element_uuid: ::core::option::Option<
                    super::super::super::Uuid,
                >,
                #[prost(string, tag = "2")]
                pub other_element_name: ::prost::alloc::string::String,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct VisibilityLink {
                #[prost(enumeration = "visibility_link::VisibilityCriterion", tag = "1")]
                pub visibility_criterion: i32,
                #[prost(message, repeated, tag = "2")]
                pub conditions: ::prost::alloc::vec::Vec<visibility_link::Condition>,
            }
            /// Nested message and enum types in `VisibilityLink`.
            pub mod visibility_link {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Condition {
                    #[prost(
                        oneof = "condition::ConditionType",
                        tags = "1, 2, 3, 4, 5, 6"
                    )]
                    pub condition_type: ::core::option::Option<condition::ConditionType>,
                }
                /// Nested message and enum types in `Condition`.
                pub mod condition {
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct ElementVisibility {
                        #[prost(message, optional, tag = "1")]
                        pub other_element_uuid: ::core::option::Option<
                            super::super::super::super::super::Uuid,
                        >,
                        #[prost(string, tag = "2")]
                        pub other_element_name: ::prost::alloc::string::String,
                        #[prost(
                            enumeration = "element_visibility::ElementVisibilityCriterion",
                            tag = "3"
                        )]
                        pub visibility_criterion: i32,
                    }
                    /// Nested message and enum types in `ElementVisibility`.
                    pub mod element_visibility {
                        #[derive(serde::Serialize, serde::Deserialize)]
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration
                        )]
                        #[repr(i32)]
                        pub enum ElementVisibilityCriterion {
                            HasText = 0,
                            HasNoText = 1,
                        }
                        impl ElementVisibilityCriterion {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    ElementVisibilityCriterion::HasText => {
                                        "ELEMENT_VISIBILITY_CRITERION_HAS_TEXT"
                                    }
                                    ElementVisibilityCriterion::HasNoText => {
                                        "ELEMENT_VISIBILITY_CRITERION_HAS_NO_TEXT"
                                    }
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(
                                value: &str,
                            ) -> ::core::option::Option<Self> {
                                match value {
                                    "ELEMENT_VISIBILITY_CRITERION_HAS_TEXT" => {
                                        Some(Self::HasText)
                                    }
                                    "ELEMENT_VISIBILITY_CRITERION_HAS_NO_TEXT" => {
                                        Some(Self::HasNoText)
                                    }
                                    _ => None,
                                }
                            }
                        }
                    }
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct TimerVisibility {
                        #[prost(message, optional, tag = "1")]
                        pub timer_uuid: ::core::option::Option<
                            super::super::super::super::super::Uuid,
                        >,
                        #[prost(string, tag = "2")]
                        pub timer_name: ::prost::alloc::string::String,
                        #[prost(
                            enumeration = "timer_visibility::TimerVisibilityCriterion",
                            tag = "3"
                        )]
                        pub visibility_criterion: i32,
                    }
                    /// Nested message and enum types in `TimerVisibility`.
                    pub mod timer_visibility {
                        #[derive(serde::Serialize, serde::Deserialize)]
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration
                        )]
                        #[repr(i32)]
                        pub enum TimerVisibilityCriterion {
                            HasTimeRemaining = 0,
                            HasExpired = 1,
                            IsRunning = 2,
                            NotRunning = 3,
                        }
                        impl TimerVisibilityCriterion {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    TimerVisibilityCriterion::HasTimeRemaining => {
                                        "TIMER_VISIBILITY_CRITERION_HAS_TIME_REMAINING"
                                    }
                                    TimerVisibilityCriterion::HasExpired => {
                                        "TIMER_VISIBILITY_CRITERION_HAS_EXPIRED"
                                    }
                                    TimerVisibilityCriterion::IsRunning => {
                                        "TIMER_VISIBILITY_CRITERION_IS_RUNNING"
                                    }
                                    TimerVisibilityCriterion::NotRunning => {
                                        "TIMER_VISIBILITY_CRITERION_NOT_RUNNING"
                                    }
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(
                                value: &str,
                            ) -> ::core::option::Option<Self> {
                                match value {
                                    "TIMER_VISIBILITY_CRITERION_HAS_TIME_REMAINING" => {
                                        Some(Self::HasTimeRemaining)
                                    }
                                    "TIMER_VISIBILITY_CRITERION_HAS_EXPIRED" => {
                                        Some(Self::HasExpired)
                                    }
                                    "TIMER_VISIBILITY_CRITERION_IS_RUNNING" => {
                                        Some(Self::IsRunning)
                                    }
                                    "TIMER_VISIBILITY_CRITERION_NOT_RUNNING" => {
                                        Some(Self::NotRunning)
                                    }
                                    _ => None,
                                }
                            }
                        }
                    }
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct VideoCountdownVisibility {
                        #[prost(
                            enumeration = "video_countdown_visibility::VideoCountdownVisibilityCriterion",
                            tag = "1"
                        )]
                        pub visibility_criterion: i32,
                    }
                    /// Nested message and enum types in `VideoCountdownVisibility`.
                    pub mod video_countdown_visibility {
                        #[derive(serde::Serialize, serde::Deserialize)]
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration
                        )]
                        #[repr(i32)]
                        pub enum VideoCountdownVisibilityCriterion {
                            HasTimeRemaining = 0,
                            HasExpired = 1,
                            IsRunning = 2,
                            NotRunning = 3,
                            Looping = 4,
                            NotLooping = 5,
                        }
                        impl VideoCountdownVisibilityCriterion {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    VideoCountdownVisibilityCriterion::HasTimeRemaining => {
                                        "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING"
                                    }
                                    VideoCountdownVisibilityCriterion::HasExpired => {
                                        "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED"
                                    }
                                    VideoCountdownVisibilityCriterion::IsRunning => {
                                        "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING"
                                    }
                                    VideoCountdownVisibilityCriterion::NotRunning => {
                                        "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING"
                                    }
                                    VideoCountdownVisibilityCriterion::Looping => {
                                        "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING"
                                    }
                                    VideoCountdownVisibilityCriterion::NotLooping => {
                                        "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING"
                                    }
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(
                                value: &str,
                            ) -> ::core::option::Option<Self> {
                                match value {
                                    "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING" => {
                                        Some(Self::HasTimeRemaining)
                                    }
                                    "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED" => {
                                        Some(Self::HasExpired)
                                    }
                                    "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING" => {
                                        Some(Self::IsRunning)
                                    }
                                    "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING" => {
                                        Some(Self::NotRunning)
                                    }
                                    "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING" => {
                                        Some(Self::Looping)
                                    }
                                    "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING" => {
                                        Some(Self::NotLooping)
                                    }
                                    _ => None,
                                }
                            }
                        }
                    }
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct AudioCountdownVisibility {
                        #[prost(
                            enumeration = "audio_countdown_visibility::AudioCountdownVisibilityCriterion",
                            tag = "1"
                        )]
                        pub visibility_criterion: i32,
                    }
                    /// Nested message and enum types in `AudioCountdownVisibility`.
                    pub mod audio_countdown_visibility {
                        #[derive(serde::Serialize, serde::Deserialize)]
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration
                        )]
                        #[repr(i32)]
                        pub enum AudioCountdownVisibilityCriterion {
                            HasTimeRemaining = 0,
                            HasExpired = 1,
                            IsRunning = 2,
                            NotRunning = 3,
                            Looping = 4,
                            NotLooping = 5,
                        }
                        impl AudioCountdownVisibilityCriterion {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    AudioCountdownVisibilityCriterion::HasTimeRemaining => {
                                        "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING"
                                    }
                                    AudioCountdownVisibilityCriterion::HasExpired => {
                                        "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED"
                                    }
                                    AudioCountdownVisibilityCriterion::IsRunning => {
                                        "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING"
                                    }
                                    AudioCountdownVisibilityCriterion::NotRunning => {
                                        "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING"
                                    }
                                    AudioCountdownVisibilityCriterion::Looping => {
                                        "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING"
                                    }
                                    AudioCountdownVisibilityCriterion::NotLooping => {
                                        "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING"
                                    }
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(
                                value: &str,
                            ) -> ::core::option::Option<Self> {
                                match value {
                                    "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING" => {
                                        Some(Self::HasTimeRemaining)
                                    }
                                    "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED" => {
                                        Some(Self::HasExpired)
                                    }
                                    "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING" => {
                                        Some(Self::IsRunning)
                                    }
                                    "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING" => {
                                        Some(Self::NotRunning)
                                    }
                                    "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING" => {
                                        Some(Self::Looping)
                                    }
                                    "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING" => {
                                        Some(Self::NotLooping)
                                    }
                                    _ => None,
                                }
                            }
                        }
                    }
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct CaptureSessionVisibility {
                        #[prost(
                            enumeration = "capture_session_visibility::CaptureSessionVisibilityCriterion",
                            tag = "1"
                        )]
                        pub visibility_criterion: i32,
                    }
                    /// Nested message and enum types in `CaptureSessionVisibility`.
                    pub mod capture_session_visibility {
                        #[derive(serde::Serialize, serde::Deserialize)]
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration
                        )]
                        #[repr(i32)]
                        pub enum CaptureSessionVisibilityCriterion {
                            Active = 0,
                            Inactive = 1,
                        }
                        impl CaptureSessionVisibilityCriterion {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    CaptureSessionVisibilityCriterion::Active => {
                                        "CAPTURE_SESSION_VISIBILITY_CRITERION_ACTIVE"
                                    }
                                    CaptureSessionVisibilityCriterion::Inactive => {
                                        "CAPTURE_SESSION_VISIBILITY_CRITERION_INACTIVE"
                                    }
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(
                                value: &str,
                            ) -> ::core::option::Option<Self> {
                                match value {
                                    "CAPTURE_SESSION_VISIBILITY_CRITERION_ACTIVE" => {
                                        Some(Self::Active)
                                    }
                                    "CAPTURE_SESSION_VISIBILITY_CRITERION_INACTIVE" => {
                                        Some(Self::Inactive)
                                    }
                                    _ => None,
                                }
                            }
                        }
                    }
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct VideoInputVisibility {
                        #[prost(int32, tag = "1")]
                        pub video_input_index: i32,
                        #[prost(
                            enumeration = "video_input_visibility::VideoInputVisibilityCriterion",
                            tag = "2"
                        )]
                        pub visibility_criterion: i32,
                    }
                    /// Nested message and enum types in `VideoInputVisibility`.
                    pub mod video_input_visibility {
                        #[derive(serde::Serialize, serde::Deserialize)]
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration
                        )]
                        #[repr(i32)]
                        pub enum VideoInputVisibilityCriterion {
                            Active = 0,
                            Inactive = 1,
                        }
                        impl VideoInputVisibilityCriterion {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    VideoInputVisibilityCriterion::Active => {
                                        "VIDEO_INPUT_VISIBILITY_CRITERION_ACTIVE"
                                    }
                                    VideoInputVisibilityCriterion::Inactive => {
                                        "VIDEO_INPUT_VISIBILITY_CRITERION_INACTIVE"
                                    }
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(
                                value: &str,
                            ) -> ::core::option::Option<Self> {
                                match value {
                                    "VIDEO_INPUT_VISIBILITY_CRITERION_ACTIVE" => {
                                        Some(Self::Active)
                                    }
                                    "VIDEO_INPUT_VISIBILITY_CRITERION_INACTIVE" => {
                                        Some(Self::Inactive)
                                    }
                                    _ => None,
                                }
                            }
                        }
                    }
                    #[derive(serde::Serialize, serde::Deserialize)]
                    #[allow(clippy::derive_partial_eq_without_eq)]
                    #[derive(Clone, PartialEq, ::prost::Oneof)]
                    pub enum ConditionType {
                        #[prost(message, tag = "1")]
                        ElementVisibility(ElementVisibility),
                        #[prost(message, tag = "2")]
                        TimerVisibility(TimerVisibility),
                        #[prost(message, tag = "3")]
                        VideoCountdownVisibility(VideoCountdownVisibility),
                        #[prost(message, tag = "4")]
                        CaptureSessionVisibility(CaptureSessionVisibility),
                        #[prost(message, tag = "5")]
                        VideoInputVisibility(VideoInputVisibility),
                        #[prost(message, tag = "6")]
                        AudioCountdownVisibility(AudioCountdownVisibility),
                    }
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum VisibilityCriterion {
                    All = 0,
                    Any = 1,
                    None = 2,
                }
                impl VisibilityCriterion {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            VisibilityCriterion::All => "VISIBILITY_CRITERION_ALL",
                            VisibilityCriterion::Any => "VISIBILITY_CRITERION_ANY",
                            VisibilityCriterion::None => "VISIBILITY_CRITERION_NONE",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "VISIBILITY_CRITERION_ALL" => Some(Self::All),
                            "VISIBILITY_CRITERION_ANY" => Some(Self::Any),
                            "VISIBILITY_CRITERION_NONE" => Some(Self::None),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SlideText {
                #[prost(enumeration = "SlideSourceType", tag = "1")]
                pub source_slide: i32,
                #[prost(enumeration = "slide_text::TextSourceOption", tag = "2")]
                pub source_option: i32,
                #[prost(bool, tag = "3")]
                pub preserve_notes_format: bool,
                #[prost(string, tag = "4")]
                pub name_to_match: ::prost::alloc::string::String,
                #[prost(
                    enumeration = "alternate_element_text::TextTransformOption",
                    tag = "5"
                )]
                pub element_text_transform: i32,
            }
            /// Nested message and enum types in `SlideText`.
            pub mod slide_text {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum TextSourceOption {
                    Text = 0,
                    Notes = 1,
                    ElementMatchingName = 2,
                }
                impl TextSourceOption {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            TextSourceOption::Text => "TEXT_SOURCE_OPTION_TEXT",
                            TextSourceOption::Notes => "TEXT_SOURCE_OPTION_NOTES",
                            TextSourceOption::ElementMatchingName => {
                                "TEXT_SOURCE_OPTION_ELEMENT_MATCHING_NAME"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "TEXT_SOURCE_OPTION_TEXT" => Some(Self::Text),
                            "TEXT_SOURCE_OPTION_NOTES" => Some(Self::Notes),
                            "TEXT_SOURCE_OPTION_ELEMENT_MATCHING_NAME" => {
                                Some(Self::ElementMatchingName)
                            }
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SlideImage {
                #[prost(enumeration = "SlideSourceType", tag = "1")]
                pub source_slide: i32,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct StageMessage {
                #[prost(bool, tag = "1")]
                pub should_flash: bool,
                #[prost(message, optional, tag = "2")]
                pub flash_color: ::core::option::Option<super::super::super::Color>,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct VideoCountdown {
                #[prost(message, optional, tag = "1")]
                pub timer_format: ::core::option::Option<
                    super::super::super::timer::Format,
                >,
                #[prost(string, tag = "2")]
                pub timer_format_string: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "3")]
                pub color_triggers: ::prost::alloc::vec::Vec<ColorTrigger>,
                #[prost(bool, tag = "4")]
                pub ignore_looping_videos: bool,
                #[prost(
                    enumeration = "video_countdown::VideoCountdownSource",
                    tag = "5"
                )]
                pub video_countdown_source: i32,
            }
            /// Nested message and enum types in `VideoCountdown`.
            pub mod video_countdown {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum VideoCountdownSource {
                    Presentation = 0,
                    Announcement = 1,
                }
                impl VideoCountdownSource {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            VideoCountdownSource::Presentation => {
                                "VIDEO_COUNTDOWN_SOURCE_PRESENTATION"
                            }
                            VideoCountdownSource::Announcement => {
                                "VIDEO_COUNTDOWN_SOURCE_ANNOUNCEMENT"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "VIDEO_COUNTDOWN_SOURCE_PRESENTATION" => {
                                Some(Self::Presentation)
                            }
                            "VIDEO_COUNTDOWN_SOURCE_ANNOUNCEMENT" => {
                                Some(Self::Announcement)
                            }
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct AudioCountdown {
                #[prost(message, optional, tag = "1")]
                pub timer_format: ::core::option::Option<
                    super::super::super::timer::Format,
                >,
                #[prost(string, tag = "2")]
                pub timer_format_string: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "3")]
                pub color_triggers: ::prost::alloc::vec::Vec<ColorTrigger>,
                #[prost(bool, tag = "4")]
                pub ignore_looping_audio: bool,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct GroupName {
                #[prost(enumeration = "GroupSourceType", tag = "1")]
                pub group_source: i32,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct GroupColor {
                #[prost(enumeration = "GroupSourceType", tag = "1")]
                pub group_source: i32,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SlideLabelText {
                #[prost(enumeration = "SlideLabelSource", tag = "1")]
                pub slide_label_source: i32,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SlideLabelColor {
                #[prost(enumeration = "SlideLabelSource", tag = "1")]
                pub slide_label_source: i32,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct PresentationNotes {}
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Presentation {
                #[prost(enumeration = "presentation::PresentationSource", tag = "1")]
                pub presentation_source: i32,
            }
            /// Nested message and enum types in `Presentation`.
            pub mod presentation {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum PresentationSource {
                    Presentation = 0,
                    Announcement = 1,
                }
                impl PresentationSource {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            PresentationSource::Presentation => {
                                "PRESENTATION_SOURCE_PRESENTATION"
                            }
                            PresentationSource::Announcement => {
                                "PRESENTATION_SOURCE_ANNOUNCEMENT"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "PRESENTATION_SOURCE_PRESENTATION" => {
                                Some(Self::Presentation)
                            }
                            "PRESENTATION_SOURCE_ANNOUNCEMENT" => {
                                Some(Self::Announcement)
                            }
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct PlaylistItem {
                #[prost(
                    enumeration = "playlist_item::PlaylistItemSourceType",
                    tag = "1"
                )]
                pub playlist_item_source: i32,
                #[prost(bool, tag = "2")]
                pub show_arrangement: bool,
            }
            /// Nested message and enum types in `PlaylistItem`.
            pub mod playlist_item {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum PlaylistItemSourceType {
                    Current = 0,
                    Next = 1,
                    CurrentHeader = 2,
                    NextHeader = 3,
                    ParentPlaylist = 4,
                }
                impl PlaylistItemSourceType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            PlaylistItemSourceType::Current => {
                                "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT"
                            }
                            PlaylistItemSourceType::Next => {
                                "PLAYLIST_ITEM_SOURCE_TYPE_NEXT"
                            }
                            PlaylistItemSourceType::CurrentHeader => {
                                "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT_HEADER"
                            }
                            PlaylistItemSourceType::NextHeader => {
                                "PLAYLIST_ITEM_SOURCE_TYPE_NEXT_HEADER"
                            }
                            PlaylistItemSourceType::ParentPlaylist => {
                                "PLAYLIST_ITEM_SOURCE_TYPE_PARENT_PLAYLIST"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT" => Some(Self::Current),
                            "PLAYLIST_ITEM_SOURCE_TYPE_NEXT" => Some(Self::Next),
                            "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT_HEADER" => {
                                Some(Self::CurrentHeader)
                            }
                            "PLAYLIST_ITEM_SOURCE_TYPE_NEXT_HEADER" => {
                                Some(Self::NextHeader)
                            }
                            "PLAYLIST_ITEM_SOURCE_TYPE_PARENT_PLAYLIST" => {
                                Some(Self::ParentPlaylist)
                            }
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct AutoAdvanceTimeRemaining {
                #[prost(
                    enumeration = "auto_advance_time_remaining::AutoAdvanceSource",
                    tag = "1"
                )]
                pub auto_advance_source: i32,
                #[prost(message, optional, tag = "2")]
                pub timer_format: ::core::option::Option<
                    super::super::super::timer::Format,
                >,
            }
            /// Nested message and enum types in `AutoAdvanceTimeRemaining`.
            pub mod auto_advance_time_remaining {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum AutoAdvanceSource {
                    Presentation = 0,
                    Announcement = 1,
                }
                impl AutoAdvanceSource {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            AutoAdvanceSource::Presentation => {
                                "AUTO_ADVANCE_SOURCE_PRESENTATION"
                            }
                            AutoAdvanceSource::Announcement => {
                                "AUTO_ADVANCE_SOURCE_ANNOUNCEMENT"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "AUTO_ADVANCE_SOURCE_PRESENTATION" => {
                                Some(Self::Presentation)
                            }
                            "AUTO_ADVANCE_SOURCE_ANNOUNCEMENT" => {
                                Some(Self::Announcement)
                            }
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct CaptureStatusText {
                #[prost(oneof = "capture_status_text::TextType", tags = "1, 2")]
                pub text_type: ::core::option::Option<capture_status_text::TextType>,
            }
            /// Nested message and enum types in `CaptureStatusText`.
            pub mod capture_status_text {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct StatusText {}
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ElapsedTime {
                    #[prost(message, optional, tag = "1")]
                    pub timer_format: ::core::option::Option<
                        super::super::super::super::timer::Format,
                    >,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum TextType {
                    #[prost(message, tag = "1")]
                    StatusText(StatusText),
                    #[prost(message, tag = "2")]
                    ElapsedTime(ElapsedTime),
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct CaptureStatusColor {}
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SlideCount {
                #[prost(enumeration = "slide_count::SlideCountSourceType", tag = "1")]
                pub slide_count_source_type: i32,
            }
            /// Nested message and enum types in `SlideCount`.
            pub mod slide_count {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum SlideCountSourceType {
                    Current = 0,
                    Remaining = 1,
                    Total = 2,
                }
                impl SlideCountSourceType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            SlideCountSourceType::Current => {
                                "SLIDE_COUNT_SOURCE_TYPE_CURRENT"
                            }
                            SlideCountSourceType::Remaining => {
                                "SLIDE_COUNT_SOURCE_TYPE_REMAINING"
                            }
                            SlideCountSourceType::Total => {
                                "SLIDE_COUNT_SOURCE_TYPE_TOTAL"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "SLIDE_COUNT_SOURCE_TYPE_CURRENT" => Some(Self::Current),
                            "SLIDE_COUNT_SOURCE_TYPE_REMAINING" => Some(Self::Remaining),
                            "SLIDE_COUNT_SOURCE_TYPE_TOTAL" => Some(Self::Total),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct PlaybackMarkerIdentifier {
                #[prost(
                    enumeration = "playback_marker_identifier::Destination",
                    tag = "1"
                )]
                pub destination: i32,
                #[prost(enumeration = "playback_marker_identifier::Type", tag = "2")]
                pub r#type: i32,
                #[prost(string, tag = "3")]
                pub name: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `PlaybackMarkerIdentifier`.
            pub mod playback_marker_identifier {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Type {
                    PlaybackMarkerIdentifierFirst = 0,
                    PlaybackMarkerIdentifierPrevious = 1,
                    PlaybackMarkerIdentifierNext = 2,
                    PlaybackMarkerIdentifierLast = 3,
                    PlaybackMarkerIdentifierName = 4,
                }
                impl Type {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Type::PlaybackMarkerIdentifierFirst => {
                                "PLAYBACK_MARKER_IDENTIFIER_FIRST"
                            }
                            Type::PlaybackMarkerIdentifierPrevious => {
                                "PLAYBACK_MARKER_IDENTIFIER_PREVIOUS"
                            }
                            Type::PlaybackMarkerIdentifierNext => {
                                "PLAYBACK_MARKER_IDENTIFIER_NEXT"
                            }
                            Type::PlaybackMarkerIdentifierLast => {
                                "PLAYBACK_MARKER_IDENTIFIER_LAST"
                            }
                            Type::PlaybackMarkerIdentifierName => {
                                "PLAYBACK_MARKER_IDENTIFIER_NAME"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "PLAYBACK_MARKER_IDENTIFIER_FIRST" => {
                                Some(Self::PlaybackMarkerIdentifierFirst)
                            }
                            "PLAYBACK_MARKER_IDENTIFIER_PREVIOUS" => {
                                Some(Self::PlaybackMarkerIdentifierPrevious)
                            }
                            "PLAYBACK_MARKER_IDENTIFIER_NEXT" => {
                                Some(Self::PlaybackMarkerIdentifierNext)
                            }
                            "PLAYBACK_MARKER_IDENTIFIER_LAST" => {
                                Some(Self::PlaybackMarkerIdentifierLast)
                            }
                            "PLAYBACK_MARKER_IDENTIFIER_NAME" => {
                                Some(Self::PlaybackMarkerIdentifierName)
                            }
                            _ => None,
                        }
                    }
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Destination {
                    PlaybackMarkerDestinationPresentation = 0,
                    PlaybackMarkerDestinationAnnouncement = 1,
                    PlaybackMarkerDestinationAudio = 2,
                }
                impl Destination {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Destination::PlaybackMarkerDestinationPresentation => {
                                "PLAYBACK_MARKER_DESTINATION_PRESENTATION"
                            }
                            Destination::PlaybackMarkerDestinationAnnouncement => {
                                "PLAYBACK_MARKER_DESTINATION_ANNOUNCEMENT"
                            }
                            Destination::PlaybackMarkerDestinationAudio => {
                                "PLAYBACK_MARKER_DESTINATION_AUDIO"
                            }
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "PLAYBACK_MARKER_DESTINATION_PRESENTATION" => {
                                Some(Self::PlaybackMarkerDestinationPresentation)
                            }
                            "PLAYBACK_MARKER_DESTINATION_ANNOUNCEMENT" => {
                                Some(Self::PlaybackMarkerDestinationAnnouncement)
                            }
                            "PLAYBACK_MARKER_DESTINATION_AUDIO" => {
                                Some(Self::PlaybackMarkerDestinationAudio)
                            }
                            _ => None,
                        }
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct PlaybackMarkerText {
                #[prost(message, optional, tag = "1")]
                pub identifier: ::core::option::Option<PlaybackMarkerIdentifier>,
                #[prost(bool, tag = "4")]
                pub should_use_marker_color: bool,
                #[prost(oneof = "playback_marker_text::TextType", tags = "2, 3")]
                pub text_type: ::core::option::Option<playback_marker_text::TextType>,
            }
            /// Nested message and enum types in `PlaybackMarkerText`.
            pub mod playback_marker_text {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Name {}
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Time {
                    #[prost(message, optional, tag = "1")]
                    pub format: ::core::option::Option<
                        super::super::super::super::timer::Format,
                    >,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum TextType {
                    #[prost(message, tag = "2")]
                    Name(Name),
                    #[prost(message, tag = "3")]
                    Time(Time),
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ChordProChart {}
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct TimecodeText {}
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct TimecodeStatus {}
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum SlideSourceType {
                CurrentSlide = 0,
                NextSlide = 1,
            }
            impl SlideSourceType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        SlideSourceType::CurrentSlide => {
                            "SLIDE_SOURCE_TYPE_CURRENT_SLIDE"
                        }
                        SlideSourceType::NextSlide => "SLIDE_SOURCE_TYPE_NEXT_SLIDE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SLIDE_SOURCE_TYPE_CURRENT_SLIDE" => Some(Self::CurrentSlide),
                        "SLIDE_SOURCE_TYPE_NEXT_SLIDE" => Some(Self::NextSlide),
                        _ => None,
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum GroupSourceType {
                CurrentSlide = 0,
                NextSlide = 1,
                NextGroup = 2,
            }
            impl GroupSourceType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        GroupSourceType::CurrentSlide => {
                            "GROUP_SOURCE_TYPE_CURRENT_SLIDE"
                        }
                        GroupSourceType::NextSlide => "GROUP_SOURCE_TYPE_NEXT_SLIDE",
                        GroupSourceType::NextGroup => "GROUP_SOURCE_TYPE_NEXT_GROUP",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "GROUP_SOURCE_TYPE_CURRENT_SLIDE" => Some(Self::CurrentSlide),
                        "GROUP_SOURCE_TYPE_NEXT_SLIDE" => Some(Self::NextSlide),
                        "GROUP_SOURCE_TYPE_NEXT_GROUP" => Some(Self::NextGroup),
                        _ => None,
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum SlideLabelSource {
                CurrentSlide = 0,
                NextSlide = 1,
            }
            impl SlideLabelSource {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        SlideLabelSource::CurrentSlide => {
                            "SLIDE_LABEL_SOURCE_CURRENT_SLIDE"
                        }
                        SlideLabelSource::NextSlide => "SLIDE_LABEL_SOURCE_NEXT_SLIDE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SLIDE_LABEL_SOURCE_CURRENT_SLIDE" => Some(Self::CurrentSlide),
                        "SLIDE_LABEL_SOURCE_NEXT_SLIDE" => Some(Self::NextSlide),
                        _ => None,
                    }
                }
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum PropertyType {
                #[prost(message, tag = "1")]
                Ticker(Ticker),
                #[prost(message, tag = "2")]
                AlternateText(AlternateElementText),
                #[prost(message, tag = "3")]
                TimerText(TimerText),
                #[prost(message, tag = "4")]
                ClockText(ClockText),
                #[prost(message, tag = "5")]
                ChordChart(ChordChart),
                #[prost(message, tag = "6")]
                OutputScreen(OutputScreen),
                #[prost(message, tag = "7")]
                PcoLive(PcoLive),
                #[prost(message, tag = "8")]
                AlternateFill(AlternateElementFill),
                #[prost(message, tag = "9")]
                VisibilityLink(VisibilityLink),
                #[prost(message, tag = "10")]
                SlideText(SlideText),
                #[prost(message, tag = "11")]
                StageMessage(StageMessage),
                #[prost(message, tag = "12")]
                VideoCountdown(VideoCountdown),
                #[prost(message, tag = "13")]
                SlideImage(SlideImage),
                #[prost(message, tag = "14")]
                CcliText(CcliText),
                #[prost(message, tag = "15")]
                GroupName(GroupName),
                #[prost(message, tag = "16")]
                GroupColor(GroupColor),
                #[prost(message, tag = "17")]
                PresentationNotes(PresentationNotes),
                #[prost(message, tag = "18")]
                PlaylistItem(PlaylistItem),
                #[prost(message, tag = "19")]
                AutoAdvanceTimeRemaining(AutoAdvanceTimeRemaining),
                #[prost(message, tag = "20")]
                CaptureStatusText(CaptureStatusText),
                #[prost(message, tag = "21")]
                CaptureStatusColor(CaptureStatusColor),
                #[prost(message, tag = "22")]
                SlideCount(SlideCount),
                #[prost(message, tag = "23")]
                AudioCountdown(AudioCountdown),
                #[prost(message, tag = "24")]
                Presentation(Presentation),
                #[prost(message, tag = "25")]
                SlideLabelText(SlideLabelText),
                #[prost(message, tag = "26")]
                SlideLabelColor(SlideLabelColor),
                #[prost(message, tag = "27")]
                RssFeed(RssFeed),
                #[prost(message, tag = "28")]
                FileFeed(FileFeed),
                #[prost(message, tag = "29")]
                ChordProChart(ChordProChart),
                #[prost(message, tag = "30")]
                PlaybackMarkerText(PlaybackMarkerText),
                #[prost(message, tag = "32")]
                PlaybackMarkerColor(PlaybackMarkerIdentifier),
                #[prost(message, tag = "33")]
                TimecodeText(TimecodeText),
                #[prost(message, tag = "34")]
                TimecodeStatus(TimecodeStatus),
                #[prost(message, tag = "35")]
                MessageText(super::super::super::Message),
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TextScroller {
            #[prost(bool, tag = "1")]
            pub should_scroll: bool,
            #[prost(double, tag = "2")]
            pub scroll_rate: f64,
            #[prost(bool, tag = "3")]
            pub should_repeat: bool,
            #[prost(double, tag = "4")]
            pub repeat_distance: f64,
            #[prost(enumeration = "text_scroller::Direction", tag = "5")]
            pub scrolling_direction: i32,
            #[prost(bool, tag = "6")]
            pub starts_off_screen: bool,
            #[prost(double, tag = "7")]
            pub fade_left: f64,
            #[prost(double, tag = "8")]
            pub fade_right: f64,
        }
        /// Nested message and enum types in `TextScroller`.
        pub mod text_scroller {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Direction {
                Left = 0,
                Right = 1,
                Up = 2,
                Down = 3,
            }
            impl Direction {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Direction::Left => "DIRECTION_LEFT",
                        Direction::Right => "DIRECTION_RIGHT",
                        Direction::Up => "DIRECTION_UP",
                        Direction::Down => "DIRECTION_DOWN",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "DIRECTION_LEFT" => Some(Self::Left),
                        "DIRECTION_RIGHT" => Some(Self::Right),
                        "DIRECTION_UP" => Some(Self::Up),
                        "DIRECTION_DOWN" => Some(Self::Down),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TextRevealType {
            None = 0,
            Bullet = 1,
            Underline = 2,
        }
        impl TextRevealType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    TextRevealType::None => "TEXT_REVEAL_TYPE_NONE",
                    TextRevealType::Bullet => "TEXT_REVEAL_TYPE_BULLET",
                    TextRevealType::Underline => "TEXT_REVEAL_TYPE_UNDERLINE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TEXT_REVEAL_TYPE_NONE" => Some(Self::None),
                    "TEXT_REVEAL_TYPE_BULLET" => Some(Self::Bullet),
                    "TEXT_REVEAL_TYPE_UNDERLINE" => Some(Self::Underline),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Info {
            None = 0,
            IsTemplateElement = 1,
            IsTextElement = 2,
            IsTextTicker = 4,
        }
        impl Info {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Info::None => "INFO_NONE",
                    Info::IsTemplateElement => "INFO_IS_TEMPLATE_ELEMENT",
                    Info::IsTextElement => "INFO_IS_TEXT_ELEMENT",
                    Info::IsTextTicker => "INFO_IS_TEXT_TICKER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "INFO_NONE" => Some(Self::None),
                    "INFO_IS_TEMPLATE_ELEMENT" => Some(Self::IsTemplateElement),
                    "INFO_IS_TEXT_ELEMENT" => Some(Self::IsTextElement),
                    "INFO_IS_TEXT_TICKER" => Some(Self::IsTextTicker),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropSlide {
    #[prost(message, optional, tag = "1")]
    pub base_slide: ::core::option::Option<Slide>,
    #[prost(message, optional, tag = "2")]
    pub transition: ::core::option::Option<Transition>,
    #[prost(bool, tag = "3")]
    pub auto_clear_enabled: bool,
    #[prost(double, tag = "4")]
    pub auto_clear_duration: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PresentationSlide {
    #[prost(message, optional, tag = "1")]
    pub base_slide: ::core::option::Option<Slide>,
    #[prost(message, optional, tag = "2")]
    pub notes: ::core::option::Option<presentation_slide::Notes>,
    #[prost(message, repeated, tag = "3")]
    pub template_guidelines: ::prost::alloc::vec::Vec<AlignmentGuide>,
    #[prost(message, optional, tag = "4")]
    pub chord_chart: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "5")]
    pub transition: ::core::option::Option<Transition>,
}
/// Nested message and enum types in `PresentationSlide`.
pub mod presentation_slide {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Notes {
        #[prost(bytes = "vec", tag = "1")]
        pub rtf_data: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "2")]
        pub attributes: ::core::option::Option<super::graphics::text::Attributes>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stage {}
/// Nested message and enum types in `Stage`.
pub mod stage {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Layout {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub slide: ::core::option::Option<super::Slide>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Document {
        #[prost(message, optional, tag = "1")]
        pub application_info: ::core::option::Option<super::ApplicationInfo>,
        #[prost(message, repeated, tag = "2")]
        pub layouts: ::prost::alloc::vec::Vec<Layout>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ScreenAssignment {
        #[prost(message, optional, tag = "1")]
        pub screen: ::core::option::Option<super::CollectionElementType>,
        #[prost(message, optional, tag = "2")]
        pub layout: ::core::option::Option<super::CollectionElementType>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub label: ::core::option::Option<action::Label>,
    #[prost(double, tag = "4")]
    pub delay_time: f64,
    #[prost(message, optional, tag = "5")]
    pub old_type: ::core::option::Option<action::OldType>,
    #[prost(bool, tag = "6")]
    pub is_enabled: bool,
    #[prost(message, optional, tag = "7")]
    pub layer_identification: ::core::option::Option<action::LayerIdentification>,
    #[prost(double, tag = "8")]
    pub duration: f64,
    #[prost(enumeration = "action::ActionType", tag = "9")]
    pub r#type: i32,
    #[prost(
        oneof = "action::ActionTypeData",
        tags = "16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 36, 37, 38, 39, 40, 41, 42, 43"
    )]
    pub action_type_data: ::core::option::Option<action::ActionTypeData>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OldType {
        #[prost(enumeration = "old_type::Category", tag = "1")]
        pub category: i32,
        #[prost(int32, tag = "2")]
        pub application_type: i32,
    }
    /// Nested message and enum types in `OldType`.
    pub mod old_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Category {
            Unknown = 0,
            Media = 1,
            Application = 2,
        }
        impl Category {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Category::Unknown => "CATEGORY_UNKNOWN",
                    Category::Media => "CATEGORY_MEDIA",
                    Category::Application => "CATEGORY_APPLICATION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CATEGORY_UNKNOWN" => Some(Self::Unknown),
                    "CATEGORY_MEDIA" => Some(Self::Media),
                    "CATEGORY_APPLICATION" => Some(Self::Application),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Label {
        #[prost(string, tag = "2")]
        pub text: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub color: ::core::option::Option<super::Color>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LayerIdentification {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlaylistItemType {
        #[prost(message, optional, tag = "1")]
        pub playlist_uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub playlist_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub item_uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "4")]
        pub item_name: ::prost::alloc::string::String,
        #[prost(bool, tag = "5")]
        pub select_playlist: bool,
        #[prost(bool, tag = "6")]
        pub always_retrigger: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlendModeType {
        #[prost(enumeration = "super::layer::BlendMode", tag = "1")]
        pub blend_mode: i32,
        #[prost(message, optional, tag = "2")]
        pub blend: ::core::option::Option<super::layer::Blending>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransitionType {
        #[prost(string, tag = "1")]
        pub transition_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub transition: ::core::option::Option<super::Transition>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DoubleType {
        #[prost(double, tag = "1")]
        pub value: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EffectsType {
        #[prost(message, repeated, tag = "1")]
        pub effects: ::prost::alloc::vec::Vec<super::Effect>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MediaType {
        #[prost(double, tag = "1")]
        pub transition_duration: f64,
        #[prost(message, optional, tag = "2")]
        pub selected_effect_preset_uuid: ::core::option::Option<super::Uuid>,
        #[prost(message, optional, tag = "3")]
        pub transition: ::core::option::Option<super::Transition>,
        #[prost(message, repeated, tag = "4")]
        pub effects: ::prost::alloc::vec::Vec<super::Effect>,
        #[prost(message, optional, tag = "5")]
        pub element: ::core::option::Option<super::Media>,
        #[prost(enumeration = "LayerType", tag = "10")]
        pub layer_type: i32,
        #[prost(bool, tag = "11")]
        pub always_retrigger: bool,
        #[prost(message, repeated, tag = "12")]
        pub markers: ::prost::alloc::vec::Vec<media_type::PlaybackMarker>,
        #[prost(oneof = "media_type::MediaType", tags = "6, 7, 8, 9")]
        pub media_type: ::core::option::Option<media_type::MediaType>,
    }
    /// Nested message and enum types in `MediaType`.
    pub mod media_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Image {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Video {
            #[prost(enumeration = "PlaybackBehavior", tag = "1")]
            pub playback_behavior: i32,
            #[prost(enumeration = "EndBehavior", tag = "2")]
            pub end_behavior: i32,
            #[prost(double, tag = "3")]
            pub loop_time: f64,
            #[prost(uint32, tag = "4")]
            pub times_to_loop: u32,
            #[prost(bool, tag = "5")]
            pub soft_loop: bool,
            #[prost(double, tag = "6")]
            pub soft_loop_duration: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Audio {
            #[prost(enumeration = "PlaybackBehavior", tag = "1")]
            pub playback_behavior: i32,
            #[prost(double, tag = "2")]
            pub loop_time: f64,
            #[prost(uint32, tag = "3")]
            pub times_to_loop: u32,
            #[prost(enumeration = "audio::MediaActionAudioType", tag = "4")]
            pub audio_type: i32,
        }
        /// Nested message and enum types in `Audio`.
        pub mod audio {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum MediaActionAudioType {
                Tune = 0,
                Sound = 1,
            }
            impl MediaActionAudioType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        MediaActionAudioType::Tune => "MEDIA_ACTION_AUDIO_TYPE_TUNE",
                        MediaActionAudioType::Sound => "MEDIA_ACTION_AUDIO_TYPE_SOUND",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "MEDIA_ACTION_AUDIO_TYPE_TUNE" => Some(Self::Tune),
                        "MEDIA_ACTION_AUDIO_TYPE_SOUND" => Some(Self::Sound),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LiveVideo {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PlaybackMarker {
            #[prost(message, optional, tag = "1")]
            pub uuid: ::core::option::Option<super::super::Uuid>,
            #[prost(double, tag = "2")]
            pub time: f64,
            #[prost(message, optional, tag = "3")]
            pub color: ::core::option::Option<super::super::Color>,
            #[prost(string, tag = "4")]
            pub name: ::prost::alloc::string::String,
            #[prost(message, repeated, tag = "5")]
            pub actions: ::prost::alloc::vec::Vec<super::super::Action>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PlaybackBehavior {
            Stop = 0,
            Loop = 1,
            LoopForCount = 2,
            LoopForTime = 3,
        }
        impl PlaybackBehavior {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    PlaybackBehavior::Stop => "PLAYBACK_BEHAVIOR_STOP",
                    PlaybackBehavior::Loop => "PLAYBACK_BEHAVIOR_LOOP",
                    PlaybackBehavior::LoopForCount => "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT",
                    PlaybackBehavior::LoopForTime => "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PLAYBACK_BEHAVIOR_STOP" => Some(Self::Stop),
                    "PLAYBACK_BEHAVIOR_LOOP" => Some(Self::Loop),
                    "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT" => Some(Self::LoopForCount),
                    "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME" => Some(Self::LoopForTime),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum EndBehavior {
            Stop = 0,
            StopOnBlack = 1,
            StopOnClear = 2,
            FadeToBlack = 3,
            FadeToClear = 4,
        }
        impl EndBehavior {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    EndBehavior::Stop => "END_BEHAVIOR_STOP",
                    EndBehavior::StopOnBlack => "END_BEHAVIOR_STOP_ON_BLACK",
                    EndBehavior::StopOnClear => "END_BEHAVIOR_STOP_ON_CLEAR",
                    EndBehavior::FadeToBlack => "END_BEHAVIOR_FADE_TO_BLACK",
                    EndBehavior::FadeToClear => "END_BEHAVIOR_FADE_TO_CLEAR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "END_BEHAVIOR_STOP" => Some(Self::Stop),
                    "END_BEHAVIOR_STOP_ON_BLACK" => Some(Self::StopOnBlack),
                    "END_BEHAVIOR_STOP_ON_CLEAR" => Some(Self::StopOnClear),
                    "END_BEHAVIOR_FADE_TO_BLACK" => Some(Self::FadeToBlack),
                    "END_BEHAVIOR_FADE_TO_CLEAR" => Some(Self::FadeToClear),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum MediaType {
            #[prost(message, tag = "6")]
            Image(Image),
            #[prost(message, tag = "7")]
            Video(Video),
            #[prost(message, tag = "8")]
            Audio(Audio),
            #[prost(message, tag = "9")]
            LiveVideo(LiveVideo),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SlideType {
        #[prost(oneof = "slide_type::Slide", tags = "2, 3")]
        pub slide: ::core::option::Option<slide_type::Slide>,
    }
    /// Nested message and enum types in `SlideType`.
    pub mod slide_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Slide {
            #[prost(message, tag = "2")]
            Presentation(super::super::PresentationSlide),
            #[prost(message, tag = "3")]
            Prop(super::super::PropSlide),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BackgroundType {
        #[prost(message, optional, tag = "1")]
        pub element: ::core::option::Option<super::Background>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimerType {
        #[prost(enumeration = "timer_type::TimerAction", tag = "2")]
        pub action_type: i32,
        #[prost(message, optional, tag = "4")]
        pub timer_identification: ::core::option::Option<super::CollectionElementType>,
        #[prost(message, optional, tag = "10")]
        pub timer_configuration: ::core::option::Option<super::timer::Configuration>,
        #[prost(double, tag = "11")]
        pub increment_amount: f64,
    }
    /// Nested message and enum types in `TimerType`.
    pub mod timer_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TimerAction {
            ActionStart = 0,
            ActionStop = 1,
            ActionReset = 2,
            ActionResetAndStart = 3,
            ActionStopAndReset = 4,
            ActionIncrement = 5,
        }
        impl TimerAction {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    TimerAction::ActionStart => "ACTION_START",
                    TimerAction::ActionStop => "ACTION_STOP",
                    TimerAction::ActionReset => "ACTION_RESET",
                    TimerAction::ActionResetAndStart => "ACTION_RESET_AND_START",
                    TimerAction::ActionStopAndReset => "ACTION_STOP_AND_RESET",
                    TimerAction::ActionIncrement => "ACTION_INCREMENT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ACTION_START" => Some(Self::ActionStart),
                    "ACTION_STOP" => Some(Self::ActionStop),
                    "ACTION_RESET" => Some(Self::ActionReset),
                    "ACTION_RESET_AND_START" => Some(Self::ActionResetAndStart),
                    "ACTION_STOP_AND_RESET" => Some(Self::ActionStopAndReset),
                    "ACTION_INCREMENT" => Some(Self::ActionIncrement),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClearType {
        #[prost(enumeration = "clear_type::ClearTargetLayer", tag = "2")]
        pub target_layer: i32,
        #[prost(enumeration = "ContentDestination", tag = "4")]
        pub content_destination: i32,
    }
    /// Nested message and enum types in `ClearType`.
    pub mod clear_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ClearTargetLayer {
            All = 0,
            Audio = 1,
            Background = 2,
            LiveVideo = 3,
            Prop = 4,
            Slide = 5,
            Logo = 6,
            Messages = 7,
            AudioEffects = 8,
        }
        impl ClearTargetLayer {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ClearTargetLayer::All => "CLEAR_TARGET_LAYER_ALL",
                    ClearTargetLayer::Audio => "CLEAR_TARGET_LAYER_AUDIO",
                    ClearTargetLayer::Background => "CLEAR_TARGET_LAYER_BACKGROUND",
                    ClearTargetLayer::LiveVideo => "CLEAR_TARGET_LAYER_LIVE_VIDEO",
                    ClearTargetLayer::Prop => "CLEAR_TARGET_LAYER_PROP",
                    ClearTargetLayer::Slide => "CLEAR_TARGET_LAYER_SLIDE",
                    ClearTargetLayer::Logo => "CLEAR_TARGET_LAYER_LOGO",
                    ClearTargetLayer::Messages => "CLEAR_TARGET_LAYER_MESSAGES",
                    ClearTargetLayer::AudioEffects => "CLEAR_TARGET_LAYER_AUDIO_EFFECTS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CLEAR_TARGET_LAYER_ALL" => Some(Self::All),
                    "CLEAR_TARGET_LAYER_AUDIO" => Some(Self::Audio),
                    "CLEAR_TARGET_LAYER_BACKGROUND" => Some(Self::Background),
                    "CLEAR_TARGET_LAYER_LIVE_VIDEO" => Some(Self::LiveVideo),
                    "CLEAR_TARGET_LAYER_PROP" => Some(Self::Prop),
                    "CLEAR_TARGET_LAYER_SLIDE" => Some(Self::Slide),
                    "CLEAR_TARGET_LAYER_LOGO" => Some(Self::Logo),
                    "CLEAR_TARGET_LAYER_MESSAGES" => Some(Self::Messages),
                    "CLEAR_TARGET_LAYER_AUDIO_EFFECTS" => Some(Self::AudioEffects),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClearGroupType {
        #[prost(message, optional, tag = "1")]
        pub identification: ::core::option::Option<super::CollectionElementType>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransportControlType {
        #[prost(oneof = "transport_control_type::Command", tags = "1, 2, 3")]
        pub command: ::core::option::Option<transport_control_type::Command>,
    }
    /// Nested message and enum types in `TransportControlType`.
    pub mod transport_control_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Play {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Pause {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JumpToTime {
            #[prost(double, tag = "1")]
            pub time: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Command {
            #[prost(message, tag = "1")]
            Play(Play),
            #[prost(message, tag = "2")]
            Pause(Pause),
            #[prost(message, tag = "3")]
            JumpToTime(JumpToTime),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StageLayoutType {
        #[prost(message, repeated, tag = "4")]
        pub stage_screen_assignments: ::prost::alloc::vec::Vec<
            super::stage::ScreenAssignment,
        >,
        #[prost(enumeration = "stage_layout_type::SlideTarget", tag = "5")]
        pub slide_target: i32,
    }
    /// Nested message and enum types in `StageLayoutType`.
    pub mod stage_layout_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SlideTarget {
            NoChange = 0,
            StageOnly = 1,
            All = 2,
        }
        impl SlideTarget {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    SlideTarget::NoChange => "SLIDE_TARGET_NO_CHANGE",
                    SlideTarget::StageOnly => "SLIDE_TARGET_STAGE_ONLY",
                    SlideTarget::All => "SLIDE_TARGET_ALL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SLIDE_TARGET_NO_CHANGE" => Some(Self::NoChange),
                    "SLIDE_TARGET_STAGE_ONLY" => Some(Self::StageOnly),
                    "SLIDE_TARGET_ALL" => Some(Self::All),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SlideDestinationType {
        #[prost(enumeration = "stage_layout_type::SlideTarget", tag = "1")]
        pub slide_target: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropType {
        #[prost(message, optional, tag = "3")]
        pub identification: ::core::option::Option<super::CollectionElementType>,
        #[prost(oneof = "prop_type::TriggerType", tags = "4, 5")]
        pub trigger_type: ::core::option::Option<prop_type::TriggerType>,
    }
    /// Nested message and enum types in `PropType`.
    pub mod prop_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PropTrigger {
            #[prost(bool, tag = "1")]
            pub auto_clear_enabled: bool,
            #[prost(bool, tag = "2")]
            pub auto_clear_follows_prop_duration: bool,
            #[prost(double, tag = "3")]
            pub auto_clear_duration: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PropClear {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum TriggerType {
            #[prost(message, tag = "4")]
            Trigger(PropTrigger),
            #[prost(message, tag = "5")]
            Clear(PropClear),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MaskType {
        #[prost(message, optional, tag = "3")]
        pub identification: ::core::option::Option<super::CollectionElementType>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MessageType {
        #[prost(message, optional, tag = "1")]
        pub message_identificaton: ::core::option::Option<super::CollectionElementType>,
        #[prost(message, repeated, tag = "3")]
        pub content: ::prost::alloc::vec::Vec<super::message::TokenValue>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CommunicationType {
        #[prost(message, optional, tag = "1")]
        pub device_identification: ::core::option::Option<super::CollectionElementType>,
        #[prost(string, tag = "2")]
        pub format: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "4")]
        pub commands: ::prost::alloc::vec::Vec<communication_type::Command>,
        #[prost(oneof = "communication_type::CommandTypeData", tags = "5, 6, 7, 8")]
        pub command_type_data: ::core::option::Option<
            communication_type::CommandTypeData,
        >,
    }
    /// Nested message and enum types in `CommunicationType`.
    pub mod communication_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Command {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub value: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "3")]
            pub replacement_range: ::core::option::Option<super::super::IntRange>,
            #[prost(string, repeated, tag = "4")]
            pub possible_values: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MidiCommand {
            #[prost(enumeration = "midi_command::State", tag = "1")]
            pub state: i32,
            #[prost(uint32, tag = "2")]
            pub channel: u32,
            #[prost(uint32, tag = "3")]
            pub note: u32,
            #[prost(uint32, tag = "4")]
            pub intensity: u32,
        }
        /// Nested message and enum types in `MIDICommand`.
        pub mod midi_command {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum State {
                On = 0,
                Off = 1,
            }
            impl State {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        State::On => "STATE_ON",
                        State::Off => "STATE_OFF",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "STATE_ON" => Some(Self::On),
                        "STATE_OFF" => Some(Self::Off),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GlobalCacheCommand {
            #[prost(enumeration = "global_cache_command::CommandAction", tag = "1")]
            pub command_action: i32,
            #[prost(uint32, tag = "2")]
            pub output: u32,
            #[prost(uint32, tag = "3")]
            pub interval: u32,
        }
        /// Nested message and enum types in `GlobalCacheCommand`.
        pub mod global_cache_command {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum CommandAction {
                On = 0,
                Off = 1,
                OnOffWithInterval = 2,
                OffOnWithInterval = 3,
            }
            impl CommandAction {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        CommandAction::On => "COMMAND_ACTION_ON",
                        CommandAction::Off => "COMMAND_ACTION_OFF",
                        CommandAction::OnOffWithInterval => {
                            "COMMAND_ACTION_ON_OFF_WITH_INTERVAL"
                        }
                        CommandAction::OffOnWithInterval => {
                            "COMMAND_ACTION_OFF_ON_WITH_INTERVAL"
                        }
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "COMMAND_ACTION_ON" => Some(Self::On),
                        "COMMAND_ACTION_OFF" => Some(Self::Off),
                        "COMMAND_ACTION_ON_OFF_WITH_INTERVAL" => {
                            Some(Self::OnOffWithInterval)
                        }
                        "COMMAND_ACTION_OFF_ON_WITH_INTERVAL" => {
                            Some(Self::OffOnWithInterval)
                        }
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Gvg100Command {
            #[prost(enumeration = "gvg100_command::CommandAction", tag = "1")]
            pub command_action: i32,
        }
        /// Nested message and enum types in `GVG100Command`.
        pub mod gvg100_command {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum CommandAction {
                FadeToBlack = 0,
                DskToggle = 1,
            }
            impl CommandAction {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        CommandAction::FadeToBlack => "COMMAND_ACTION_FADE_TO_BLACK",
                        CommandAction::DskToggle => "COMMAND_ACTION_DSK_TOGGLE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "COMMAND_ACTION_FADE_TO_BLACK" => Some(Self::FadeToBlack),
                        "COMMAND_ACTION_DSK_TOGGLE" => Some(Self::DskToggle),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SonyBvsCommand {
            #[prost(enumeration = "sony_bvs_command::CommandAction", tag = "1")]
            pub command_action: i32,
        }
        /// Nested message and enum types in `SonyBVSCommand`.
        pub mod sony_bvs_command {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum CommandAction {
                FadeToBlack = 0,
                KeyOn = 1,
                KeyOff = 2,
                DskOn = 3,
                DskOff = 4,
            }
            impl CommandAction {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        CommandAction::FadeToBlack => "COMMAND_ACTION_FADE_TO_BLACK",
                        CommandAction::KeyOn => "COMMAND_ACTION_KEY_ON",
                        CommandAction::KeyOff => "COMMAND_ACTION_KEY_OFF",
                        CommandAction::DskOn => "COMMAND_ACTION_DSK_ON",
                        CommandAction::DskOff => "COMMAND_ACTION_DSK_OFF",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "COMMAND_ACTION_FADE_TO_BLACK" => Some(Self::FadeToBlack),
                        "COMMAND_ACTION_KEY_ON" => Some(Self::KeyOn),
                        "COMMAND_ACTION_KEY_OFF" => Some(Self::KeyOff),
                        "COMMAND_ACTION_DSK_ON" => Some(Self::DskOn),
                        "COMMAND_ACTION_DSK_OFF" => Some(Self::DskOff),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum CommandTypeData {
            #[prost(message, tag = "5")]
            MidiCommand(MidiCommand),
            #[prost(message, tag = "6")]
            GlobalCacheCommand(GlobalCacheCommand),
            #[prost(message, tag = "7")]
            Gvg100Command(Gvg100Command),
            #[prost(message, tag = "8")]
            SonyBvsCommand(SonyBvsCommand),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MultiScreenType {
        #[prost(message, optional, tag = "3")]
        pub identification: ::core::option::Option<super::CollectionElementType>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DocumentType {
        #[prost(message, optional, tag = "1")]
        pub identification: ::core::option::Option<super::CollectionElementType>,
        #[prost(message, optional, tag = "2")]
        pub selected_arrangement: ::core::option::Option<super::Uuid>,
        #[prost(enumeration = "ContentDestination", tag = "3")]
        pub content_destination: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExternalPresentationType {
        #[prost(message, optional, tag = "1")]
        pub url: ::core::option::Option<super::Url>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AudienceLookType {
        #[prost(message, optional, tag = "1")]
        pub identification: ::core::option::Option<super::CollectionElementType>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AudioInputType {
        #[prost(int32, tag = "1")]
        pub index: i32,
        #[prost(bool, tag = "2")]
        pub override_mode: bool,
        #[prost(message, optional, tag = "3")]
        pub behavior_mode: ::core::option::Option<super::audio_input::BehaviorMode>,
        #[prost(bool, tag = "4")]
        pub override_volume: bool,
        #[prost(double, tag = "5")]
        pub volume: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MacroType {
        #[prost(message, optional, tag = "1")]
        pub identification: ::core::option::Option<super::CollectionElementType>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CaptureType {
        #[prost(oneof = "capture_type::CaptureAction", tags = "1, 2")]
        pub capture_action: ::core::option::Option<capture_type::CaptureAction>,
    }
    /// Nested message and enum types in `CaptureType`.
    pub mod capture_type {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CaptureStart {
            #[prost(message, optional, tag = "1")]
            pub preset_identification: ::core::option::Option<
                super::super::CollectionElementType,
            >,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CaptureStop {
            #[prost(bool, tag = "1")]
            pub shows_alert_before_stopping: bool,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum CaptureAction {
            #[prost(message, tag = "1")]
            Start(CaptureStart),
            #[prost(message, tag = "2")]
            Stop(CaptureStop),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContentDestination {
        Global = 0,
        Announcements = 1,
    }
    impl ContentDestination {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContentDestination::Global => "CONTENT_DESTINATION_GLOBAL",
                ContentDestination::Announcements => "CONTENT_DESTINATION_ANNOUNCEMENTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTENT_DESTINATION_GLOBAL" => Some(Self::Global),
                "CONTENT_DESTINATION_ANNOUNCEMENTS" => Some(Self::Announcements),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LayerType {
        Background = 0,
        Foreground = 1,
        Fill = 2,
        Input = 3,
    }
    impl LayerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LayerType::Background => "LAYER_TYPE_BACKGROUND",
                LayerType::Foreground => "LAYER_TYPE_FOREGROUND",
                LayerType::Fill => "LAYER_TYPE_FILL",
                LayerType::Input => "LAYER_TYPE_INPUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LAYER_TYPE_BACKGROUND" => Some(Self::Background),
                "LAYER_TYPE_FOREGROUND" => Some(Self::Foreground),
                "LAYER_TYPE_FILL" => Some(Self::Fill),
                "LAYER_TYPE_INPUT" => Some(Self::Input),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ActionType {
        Unknown = 0,
        StageLayout = 1,
        Media = 2,
        Timer = 3,
        Communication = 4,
        Clear = 5,
        Prop = 6,
        Mask = 7,
        Message = 8,
        SocialMedia = 9,
        Multiscreen = 10,
        PresentationSlide = 11,
        ForegroundMedia = 12,
        BackgroundMedia = 13,
        PresentationDocument = 14,
        PropSlide = 15,
        ExternalPresentation = 17,
        AudienceLook = 18,
        AudioInput = 19,
        AudioBinPlaylist = 20,
        MediaBinPlaylist = 21,
        SlideDestination = 22,
        Macro = 23,
        ClearGroup = 24,
        Capture = 25,
        LibraryPlaylist = 26,
    }
    impl ActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ActionType::Unknown => "ACTION_TYPE_UNKNOWN",
                ActionType::StageLayout => "ACTION_TYPE_STAGE_LAYOUT",
                ActionType::Media => "ACTION_TYPE_MEDIA",
                ActionType::Timer => "ACTION_TYPE_TIMER",
                ActionType::Communication => "ACTION_TYPE_COMMUNICATION",
                ActionType::Clear => "ACTION_TYPE_CLEAR",
                ActionType::Prop => "ACTION_TYPE_PROP",
                ActionType::Mask => "ACTION_TYPE_MASK",
                ActionType::Message => "ACTION_TYPE_MESSAGE",
                ActionType::SocialMedia => "ACTION_TYPE_SOCIAL_MEDIA",
                ActionType::Multiscreen => "ACTION_TYPE_MULTISCREEN",
                ActionType::PresentationSlide => "ACTION_TYPE_PRESENTATION_SLIDE",
                ActionType::ForegroundMedia => "ACTION_TYPE_FOREGROUND_MEDIA",
                ActionType::BackgroundMedia => "ACTION_TYPE_BACKGROUND_MEDIA",
                ActionType::PresentationDocument => "ACTION_TYPE_PRESENTATION_DOCUMENT",
                ActionType::PropSlide => "ACTION_TYPE_PROP_SLIDE",
                ActionType::ExternalPresentation => "ACTION_TYPE_EXTERNAL_PRESENTATION",
                ActionType::AudienceLook => "ACTION_TYPE_AUDIENCE_LOOK",
                ActionType::AudioInput => "ACTION_TYPE_AUDIO_INPUT",
                ActionType::AudioBinPlaylist => "ACTION_TYPE_AUDIO_BIN_PLAYLIST",
                ActionType::MediaBinPlaylist => "ACTION_TYPE_MEDIA_BIN_PLAYLIST",
                ActionType::SlideDestination => "ACTION_TYPE_SLIDE_DESTINATION",
                ActionType::Macro => "ACTION_TYPE_MACRO",
                ActionType::ClearGroup => "ACTION_TYPE_CLEAR_GROUP",
                ActionType::Capture => "ACTION_TYPE_CAPTURE",
                ActionType::LibraryPlaylist => "ACTION_TYPE_LIBRARY_PLAYLIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_TYPE_UNKNOWN" => Some(Self::Unknown),
                "ACTION_TYPE_STAGE_LAYOUT" => Some(Self::StageLayout),
                "ACTION_TYPE_MEDIA" => Some(Self::Media),
                "ACTION_TYPE_TIMER" => Some(Self::Timer),
                "ACTION_TYPE_COMMUNICATION" => Some(Self::Communication),
                "ACTION_TYPE_CLEAR" => Some(Self::Clear),
                "ACTION_TYPE_PROP" => Some(Self::Prop),
                "ACTION_TYPE_MASK" => Some(Self::Mask),
                "ACTION_TYPE_MESSAGE" => Some(Self::Message),
                "ACTION_TYPE_SOCIAL_MEDIA" => Some(Self::SocialMedia),
                "ACTION_TYPE_MULTISCREEN" => Some(Self::Multiscreen),
                "ACTION_TYPE_PRESENTATION_SLIDE" => Some(Self::PresentationSlide),
                "ACTION_TYPE_FOREGROUND_MEDIA" => Some(Self::ForegroundMedia),
                "ACTION_TYPE_BACKGROUND_MEDIA" => Some(Self::BackgroundMedia),
                "ACTION_TYPE_PRESENTATION_DOCUMENT" => Some(Self::PresentationDocument),
                "ACTION_TYPE_PROP_SLIDE" => Some(Self::PropSlide),
                "ACTION_TYPE_EXTERNAL_PRESENTATION" => Some(Self::ExternalPresentation),
                "ACTION_TYPE_AUDIENCE_LOOK" => Some(Self::AudienceLook),
                "ACTION_TYPE_AUDIO_INPUT" => Some(Self::AudioInput),
                "ACTION_TYPE_AUDIO_BIN_PLAYLIST" => Some(Self::AudioBinPlaylist),
                "ACTION_TYPE_MEDIA_BIN_PLAYLIST" => Some(Self::MediaBinPlaylist),
                "ACTION_TYPE_SLIDE_DESTINATION" => Some(Self::SlideDestination),
                "ACTION_TYPE_MACRO" => Some(Self::Macro),
                "ACTION_TYPE_CLEAR_GROUP" => Some(Self::ClearGroup),
                "ACTION_TYPE_CAPTURE" => Some(Self::Capture),
                "ACTION_TYPE_LIBRARY_PLAYLIST" => Some(Self::LibraryPlaylist),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ActionTypeData {
        #[prost(message, tag = "16")]
        CollectionElement(super::CollectionElementType),
        #[prost(message, tag = "17")]
        PlaylistItem(PlaylistItemType),
        #[prost(message, tag = "18")]
        BlendMode(BlendModeType),
        #[prost(message, tag = "19")]
        Transition(TransitionType),
        #[prost(message, tag = "20")]
        Media(MediaType),
        #[prost(message, tag = "21")]
        DoubleItem(DoubleType),
        #[prost(message, tag = "22")]
        Effects(EffectsType),
        #[prost(message, tag = "23")]
        Slide(SlideType),
        #[prost(message, tag = "24")]
        Background(BackgroundType),
        #[prost(message, tag = "25")]
        Timer(TimerType),
        #[prost(message, tag = "26")]
        Clear(ClearType),
        #[prost(message, tag = "27")]
        Stage(StageLayoutType),
        #[prost(message, tag = "28")]
        Prop(PropType),
        #[prost(message, tag = "29")]
        Mask(MaskType),
        #[prost(message, tag = "30")]
        Message(MessageType),
        #[prost(message, tag = "32")]
        Communication(CommunicationType),
        #[prost(message, tag = "33")]
        MultiScreen(MultiScreenType),
        #[prost(message, tag = "34")]
        PresentationDocument(DocumentType),
        #[prost(message, tag = "36")]
        ExternalPresentation(ExternalPresentationType),
        #[prost(message, tag = "37")]
        AudienceLook(AudienceLookType),
        #[prost(message, tag = "38")]
        AudioInput(AudioInputType),
        #[prost(message, tag = "39")]
        SlideDestination(SlideDestinationType),
        #[prost(message, tag = "40")]
        Macro(MacroType),
        #[prost(message, tag = "41")]
        ClearGroup(ClearGroupType),
        #[prost(message, tag = "42")]
        TransportControl(TransportControlType),
        #[prost(message, tag = "43")]
        Capture(CaptureType),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cue {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "cue::CompletionTargetType", tag = "3")]
    pub completion_target_type: i32,
    #[prost(message, optional, tag = "4")]
    pub completion_target_uuid: ::core::option::Option<Uuid>,
    #[prost(enumeration = "cue::CompletionActionType", tag = "5")]
    pub completion_action_type: i32,
    #[prost(message, optional, tag = "6")]
    pub completion_action_uuid: ::core::option::Option<Uuid>,
    #[prost(message, optional, tag = "7")]
    pub trigger_time: ::core::option::Option<cue::TimecodeTime>,
    #[prost(message, optional, tag = "8")]
    pub hot_key: ::core::option::Option<HotKey>,
    #[prost(message, repeated, tag = "10")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    #[prost(message, repeated, tag = "11")]
    pub pending_imports: ::prost::alloc::vec::Vec<cue::PendingImportsEntry>,
    #[prost(bool, tag = "12")]
    pub is_enabled: bool,
    #[prost(double, tag = "13")]
    pub completion_time: f64,
}
/// Nested message and enum types in `Cue`.
pub mod cue {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimecodeTime {
        #[prost(double, tag = "1")]
        pub time: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PendingImportsEntry {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<super::UrLs>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompletionTargetType {
        None = 0,
        Next = 1,
        Random = 2,
        Cue = 3,
        First = 4,
    }
    impl CompletionTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CompletionTargetType::None => "COMPLETION_TARGET_TYPE_NONE",
                CompletionTargetType::Next => "COMPLETION_TARGET_TYPE_NEXT",
                CompletionTargetType::Random => "COMPLETION_TARGET_TYPE_RANDOM",
                CompletionTargetType::Cue => "COMPLETION_TARGET_TYPE_CUE",
                CompletionTargetType::First => "COMPLETION_TARGET_TYPE_FIRST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPLETION_TARGET_TYPE_NONE" => Some(Self::None),
                "COMPLETION_TARGET_TYPE_NEXT" => Some(Self::Next),
                "COMPLETION_TARGET_TYPE_RANDOM" => Some(Self::Random),
                "COMPLETION_TARGET_TYPE_CUE" => Some(Self::Cue),
                "COMPLETION_TARGET_TYPE_FIRST" => Some(Self::First),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompletionActionType {
        First = 0,
        Last = 1,
        AfterAction = 2,
        AfterTime = 3,
    }
    impl CompletionActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CompletionActionType::First => "COMPLETION_ACTION_TYPE_FIRST",
                CompletionActionType::Last => "COMPLETION_ACTION_TYPE_LAST",
                CompletionActionType::AfterAction => {
                    "COMPLETION_ACTION_TYPE_AFTER_ACTION"
                }
                CompletionActionType::AfterTime => "COMPLETION_ACTION_TYPE_AFTER_TIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPLETION_ACTION_TYPE_FIRST" => Some(Self::First),
                "COMPLETION_ACTION_TYPE_LAST" => Some(Self::Last),
                "COMPLETION_ACTION_TYPE_AFTER_ACTION" => Some(Self::AfterAction),
                "COMPLETION_ACTION_TYPE_AFTER_TIME" => Some(Self::AfterTime),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MusicKeyScale {
    #[prost(enumeration = "music_key_scale::MusicKey", tag = "1")]
    pub music_key: i32,
    #[prost(enumeration = "music_key_scale::MusicScale", tag = "2")]
    pub music_scale: i32,
}
/// Nested message and enum types in `MusicKeyScale`.
pub mod music_key_scale {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MusicKey {
        AFlat = 0,
        A = 1,
        ASharp = 2,
        BFlat = 3,
        B = 4,
        BSharp = 5,
        CFlat = 6,
        C = 7,
        CSharp = 8,
        DFlat = 9,
        D = 10,
        DSharp = 11,
        EFlat = 12,
        E = 13,
        ESharp = 14,
        FFlat = 15,
        F = 16,
        FSharp = 17,
        GFlat = 18,
        G = 19,
        GSharp = 20,
    }
    impl MusicKey {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MusicKey::AFlat => "MUSIC_KEY_A_FLAT",
                MusicKey::A => "MUSIC_KEY_A",
                MusicKey::ASharp => "MUSIC_KEY_A_SHARP",
                MusicKey::BFlat => "MUSIC_KEY_B_FLAT",
                MusicKey::B => "MUSIC_KEY_B",
                MusicKey::BSharp => "MUSIC_KEY_B_SHARP",
                MusicKey::CFlat => "MUSIC_KEY_C_FLAT",
                MusicKey::C => "MUSIC_KEY_C",
                MusicKey::CSharp => "MUSIC_KEY_C_SHARP",
                MusicKey::DFlat => "MUSIC_KEY_D_FLAT",
                MusicKey::D => "MUSIC_KEY_D",
                MusicKey::DSharp => "MUSIC_KEY_D_SHARP",
                MusicKey::EFlat => "MUSIC_KEY_E_FLAT",
                MusicKey::E => "MUSIC_KEY_E",
                MusicKey::ESharp => "MUSIC_KEY_E_SHARP",
                MusicKey::FFlat => "MUSIC_KEY_F_FLAT",
                MusicKey::F => "MUSIC_KEY_F",
                MusicKey::FSharp => "MUSIC_KEY_F_SHARP",
                MusicKey::GFlat => "MUSIC_KEY_G_FLAT",
                MusicKey::G => "MUSIC_KEY_G",
                MusicKey::GSharp => "MUSIC_KEY_G_SHARP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MUSIC_KEY_A_FLAT" => Some(Self::AFlat),
                "MUSIC_KEY_A" => Some(Self::A),
                "MUSIC_KEY_A_SHARP" => Some(Self::ASharp),
                "MUSIC_KEY_B_FLAT" => Some(Self::BFlat),
                "MUSIC_KEY_B" => Some(Self::B),
                "MUSIC_KEY_B_SHARP" => Some(Self::BSharp),
                "MUSIC_KEY_C_FLAT" => Some(Self::CFlat),
                "MUSIC_KEY_C" => Some(Self::C),
                "MUSIC_KEY_C_SHARP" => Some(Self::CSharp),
                "MUSIC_KEY_D_FLAT" => Some(Self::DFlat),
                "MUSIC_KEY_D" => Some(Self::D),
                "MUSIC_KEY_D_SHARP" => Some(Self::DSharp),
                "MUSIC_KEY_E_FLAT" => Some(Self::EFlat),
                "MUSIC_KEY_E" => Some(Self::E),
                "MUSIC_KEY_E_SHARP" => Some(Self::ESharp),
                "MUSIC_KEY_F_FLAT" => Some(Self::FFlat),
                "MUSIC_KEY_F" => Some(Self::F),
                "MUSIC_KEY_F_SHARP" => Some(Self::FSharp),
                "MUSIC_KEY_G_FLAT" => Some(Self::GFlat),
                "MUSIC_KEY_G" => Some(Self::G),
                "MUSIC_KEY_G_SHARP" => Some(Self::GSharp),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MusicScale {
        Major = 0,
        Minor = 1,
    }
    impl MusicScale {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MusicScale::Major => "MUSIC_SCALE_MAJOR",
                MusicScale::Minor => "MUSIC_SCALE_MINOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MUSIC_SCALE_MAJOR" => Some(Self::Major),
                "MUSIC_SCALE_MINOR" => Some(Self::Minor),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Timestamp {
    #[prost(int64, tag = "1")]
    pub seconds: i64,
    #[prost(int32, tag = "2")]
    pub nanos: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Color>,
    #[prost(message, optional, tag = "4")]
    pub hot_key: ::core::option::Option<HotKey>,
    #[prost(message, optional, tag = "5")]
    pub application_group_identifier: ::core::option::Option<Uuid>,
    #[prost(string, tag = "6")]
    pub application_group_name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProGroupsDocument {
    #[prost(message, repeated, tag = "1")]
    pub groups: ::prost::alloc::vec::Vec<Group>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Presentation {
    #[prost(message, optional, tag = "1")]
    pub application_info: ::core::option::Option<ApplicationInfo>,
    #[prost(message, optional, tag = "2")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub last_date_used: ::core::option::Option<Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub last_modified_date: ::core::option::Option<Timestamp>,
    #[prost(string, tag = "6")]
    pub category: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub notes: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub background: ::core::option::Option<Background>,
    #[prost(message, optional, tag = "9")]
    pub chord_chart: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "10")]
    pub selected_arrangement: ::core::option::Option<Uuid>,
    #[prost(message, repeated, tag = "11")]
    pub arrangements: ::prost::alloc::vec::Vec<presentation::Arrangement>,
    #[prost(message, repeated, tag = "12")]
    pub cue_groups: ::prost::alloc::vec::Vec<presentation::CueGroup>,
    #[prost(message, repeated, tag = "13")]
    pub cues: ::prost::alloc::vec::Vec<Cue>,
    #[prost(message, optional, tag = "14")]
    pub ccli: ::core::option::Option<presentation::Ccli>,
    #[prost(message, optional, tag = "15")]
    pub bible_reference: ::core::option::Option<presentation::BibleReference>,
    #[prost(message, optional, tag = "17")]
    pub timeline: ::core::option::Option<presentation::Timeline>,
    #[prost(message, optional, tag = "18")]
    pub transition: ::core::option::Option<Transition>,
    #[prost(enumeration = "action::ContentDestination", tag = "19")]
    pub content_destination: i32,
    #[prost(message, optional, tag = "21")]
    pub multi_tracks_licensing: ::core::option::Option<
        presentation::MultiTracksLicensing,
    >,
    #[prost(string, tag = "22")]
    pub music_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "23")]
    pub music: ::core::option::Option<presentation::Music>,
    #[prost(oneof = "presentation::SlideShow", tags = "20")]
    pub slide_show: ::core::option::Option<presentation::SlideShow>,
}
/// Nested message and enum types in `Presentation`.
pub mod presentation {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Ccli {
        #[prost(string, tag = "1")]
        pub author: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub artist_credits: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub song_title: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub publisher: ::prost::alloc::string::String,
        #[prost(uint32, tag = "5")]
        pub copyright_year: u32,
        #[prost(uint32, tag = "6")]
        pub song_number: u32,
        #[prost(bool, tag = "7")]
        pub display: bool,
        #[prost(string, tag = "8")]
        pub album: ::prost::alloc::string::String,
        #[prost(bytes = "vec", tag = "9")]
        pub artwork: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BibleReference {
        #[prost(uint32, tag = "1")]
        pub book_index: u32,
        #[prost(string, tag = "2")]
        pub book_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub chapter_range: ::core::option::Option<super::IntRange>,
        #[prost(message, optional, tag = "4")]
        pub verse_range: ::core::option::Option<super::IntRange>,
        #[prost(string, tag = "5")]
        pub translation_name: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub translation_display_abbreviation: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub translation_internal_abbreviation: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub book_key: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Timeline {
        #[prost(message, repeated, tag = "1")]
        pub cues: ::prost::alloc::vec::Vec<timeline::Cue>,
        #[prost(double, tag = "5")]
        pub duration: f64,
        #[prost(bool, tag = "6")]
        pub r#loop: bool,
        #[prost(message, optional, tag = "8")]
        pub audio_action: ::core::option::Option<super::Action>,
        #[prost(bool, tag = "9")]
        pub timecode_enable: bool,
        #[prost(double, tag = "10")]
        pub timecode_offset: f64,
        #[prost(message, repeated, tag = "11")]
        pub cues_v2: ::prost::alloc::vec::Vec<timeline::Cue>,
    }
    /// Nested message and enum types in `Timeline`.
    pub mod timeline {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Cue {
            #[prost(double, tag = "1")]
            pub trigger_time: f64,
            #[prost(string, tag = "3")]
            pub name: ::prost::alloc::string::String,
            #[prost(oneof = "cue::TriggerInfo", tags = "2, 4")]
            pub trigger_info: ::core::option::Option<cue::TriggerInfo>,
        }
        /// Nested message and enum types in `Cue`.
        pub mod cue {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum TriggerInfo {
                #[prost(message, tag = "2")]
                CueId(super::super::super::Uuid),
                #[prost(message, tag = "4")]
                Action(super::super::super::Action),
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Arrangement {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub group_identifiers: ::prost::alloc::vec::Vec<super::Uuid>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CueGroup {
        #[prost(message, optional, tag = "1")]
        pub group: ::core::option::Option<super::Group>,
        #[prost(message, repeated, tag = "2")]
        pub cue_identifiers: ::prost::alloc::vec::Vec<super::Uuid>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MultiTracksLicensing {
        #[prost(int64, tag = "1")]
        pub song_identifier: i64,
        #[prost(string, tag = "2")]
        pub customer_identifier: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub expiration_date: ::core::option::Option<super::Timestamp>,
        #[prost(message, optional, tag = "4")]
        pub license_expiration: ::core::option::Option<super::Timestamp>,
        #[prost(enumeration = "multi_tracks_licensing::Subscription", tag = "5")]
        pub subscription: i32,
    }
    /// Nested message and enum types in `MultiTracksLicensing`.
    pub mod multi_tracks_licensing {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Subscription {
            ChartPro = 0,
            SlidePro = 1,
        }
        impl Subscription {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Subscription::ChartPro => "SUBSCRIPTION_CHART_PRO",
                    Subscription::SlidePro => "SUBSCRIPTION_SLIDE_PRO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUBSCRIPTION_CHART_PRO" => Some(Self::ChartPro),
                    "SUBSCRIPTION_SLIDE_PRO" => Some(Self::SlidePro),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Music {
        #[prost(string, tag = "1")]
        pub original_music_key: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub user_music_key: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub original: ::core::option::Option<super::MusicKeyScale>,
        #[prost(message, optional, tag = "4")]
        pub user: ::core::option::Option<super::MusicKeyScale>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SlideShow {
        #[prost(double, tag = "20")]
        SlideShowDuration(f64),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanningCenterPlan {
    #[prost(uint32, tag = "1")]
    pub plan_id_num: u32,
    #[prost(uint32, tag = "2")]
    pub parent_id_num: u32,
    #[prost(string, tag = "3")]
    pub series_title: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub plan_title: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub date_list: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub created_date: ::core::option::Option<Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_date: ::core::option::Option<Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub last_update_check_date: ::core::option::Option<Timestamp>,
    #[prost(string, tag = "9")]
    pub plan_id_str: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub parent_id_str: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PlanningCenterPlan`.
pub mod planning_center_plan {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlanItem {
        #[prost(enumeration = "plan_item::PlanItemType", tag = "1")]
        pub item_type: i32,
        #[prost(uint32, tag = "2")]
        pub pco_id_num: u32,
        #[prost(uint32, tag = "3")]
        pub service_id_num: u32,
        #[prost(uint32, tag = "4")]
        pub parent_id_num: u32,
        #[prost(string, tag = "5")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "6")]
        pub attachments: ::prost::alloc::vec::Vec<plan_item::Attachment>,
        #[prost(message, optional, tag = "7")]
        pub update_date: ::core::option::Option<super::Timestamp>,
        #[prost(message, optional, tag = "8")]
        pub linked_song: ::core::option::Option<plan_item::SongItem>,
        #[prost(string, tag = "9")]
        pub pco_id_str: ::prost::alloc::string::String,
        #[prost(string, tag = "10")]
        pub service_id_str: ::prost::alloc::string::String,
        #[prost(string, tag = "11")]
        pub parent_id_str: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `PlanItem`.
    pub mod plan_item {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Attachment {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub url: ::core::option::Option<super::super::Url>,
            #[prost(message, optional, tag = "3")]
            pub created_date: ::core::option::Option<super::super::Timestamp>,
            #[prost(message, optional, tag = "4")]
            pub linked_path: ::core::option::Option<super::super::Url>,
            #[prost(uint32, tag = "5")]
            pub pco_id_num: u32,
            #[prost(bool, tag = "6")]
            pub needs_update: bool,
            #[prost(message, optional, tag = "7")]
            pub update_date: ::core::option::Option<super::super::Timestamp>,
            #[prost(string, tag = "8")]
            pub pco_id_str: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SongItem {
            #[prost(uint32, tag = "1")]
            pub pco_id_num: u32,
            #[prost(uint32, tag = "2")]
            pub arrangement_id_num: u32,
            #[prost(message, optional, tag = "3")]
            pub ccli: ::core::option::Option<super::super::presentation::Ccli>,
            #[prost(message, optional, tag = "4")]
            pub sequence: ::core::option::Option<song_item::Sequence>,
            #[prost(string, tag = "5")]
            pub pco_id_str: ::prost::alloc::string::String,
            #[prost(string, tag = "6")]
            pub arrangement_id_str: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `SongItem`.
        pub mod song_item {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Sequence {
                #[prost(uint32, tag = "1")]
                pub pco_id_num: u32,
                #[prost(string, tag = "2")]
                pub name: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "3")]
                pub group_names: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
                #[prost(string, tag = "4")]
                pub pco_id_str: ::prost::alloc::string::String,
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PlanItemType {
            Item = 0,
            Song = 1,
            Media = 2,
            Header = 3,
        }
        impl PlanItemType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    PlanItemType::Item => "PLAN_ITEM_TYPE_ITEM",
                    PlanItemType::Song => "PLAN_ITEM_TYPE_SONG",
                    PlanItemType::Media => "PLAN_ITEM_TYPE_MEDIA",
                    PlanItemType::Header => "PLAN_ITEM_TYPE_HEADER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PLAN_ITEM_TYPE_ITEM" => Some(Self::Item),
                    "PLAN_ITEM_TYPE_SONG" => Some(Self::Song),
                    "PLAN_ITEM_TYPE_MEDIA" => Some(Self::Media),
                    "PLAN_ITEM_TYPE_HEADER" => Some(Self::Header),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Playlist {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "playlist::Type", tag = "3")]
    pub r#type: i32,
    #[prost(bool, tag = "4")]
    pub expanded: bool,
    #[prost(message, optional, tag = "5")]
    pub targeted_layer_uuid: ::core::option::Option<Uuid>,
    #[prost(message, optional, tag = "6")]
    pub smart_directory_path: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "7")]
    pub hot_key: ::core::option::Option<HotKey>,
    #[prost(message, repeated, tag = "8")]
    pub cues: ::prost::alloc::vec::Vec<Cue>,
    #[prost(message, repeated, tag = "9")]
    pub children: ::prost::alloc::vec::Vec<Playlist>,
    #[prost(bool, tag = "10")]
    pub timecode_enabled: bool,
    #[prost(enumeration = "playlist::TimingType", tag = "11")]
    pub timing: i32,
    #[prost(message, optional, tag = "16")]
    pub startup_info: ::core::option::Option<playlist::StartupInfo>,
    #[prost(oneof = "playlist::ChildrenType", tags = "12, 13")]
    pub children_type: ::core::option::Option<playlist::ChildrenType>,
    #[prost(oneof = "playlist::LinkData", tags = "14, 15")]
    pub link_data: ::core::option::Option<playlist::LinkData>,
}
/// Nested message and enum types in `Playlist`.
pub mod playlist {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlaylistArray {
        #[prost(message, repeated, tag = "1")]
        pub playlists: ::prost::alloc::vec::Vec<super::Playlist>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlaylistItems {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::PlaylistItem>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FolderDirectory {
        #[prost(message, optional, tag = "1")]
        pub smart_directory: ::core::option::Option<super::Url>,
        #[prost(enumeration = "folder_directory::ImportBehavior", tag = "2")]
        pub import_behavior: i32,
    }
    /// Nested message and enum types in `FolderDirectory`.
    pub mod folder_directory {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ImportBehavior {
            Background = 0,
            Foreground = 1,
        }
        impl ImportBehavior {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ImportBehavior::Background => "IMPORT_BEHAVIOR_BACKGROUND",
                    ImportBehavior::Foreground => "IMPORT_BEHAVIOR_FOREGROUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "IMPORT_BEHAVIOR_BACKGROUND" => Some(Self::Background),
                    "IMPORT_BEHAVIOR_FOREGROUND" => Some(Self::Foreground),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tag {
        #[prost(message, optional, tag = "1")]
        pub color: ::core::option::Option<super::Color>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub uuid: ::core::option::Option<super::Uuid>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartupInfo {
        #[prost(bool, tag = "1")]
        pub trigger_on_startup: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Playlist = 1,
        Group = 2,
        Smart = 3,
        Root = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unknown => "TYPE_UNKNOWN",
                Type::Playlist => "TYPE_PLAYLIST",
                Type::Group => "TYPE_GROUP",
                Type::Smart => "TYPE_SMART",
                Type::Root => "TYPE_ROOT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "TYPE_PLAYLIST" => Some(Self::Playlist),
                "TYPE_GROUP" => Some(Self::Group),
                "TYPE_SMART" => Some(Self::Smart),
                "TYPE_ROOT" => Some(Self::Root),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimingType {
        None = 0,
        Timecode = 1,
        TimeOfDay = 2,
    }
    impl TimingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TimingType::None => "TIMING_TYPE_NONE",
                TimingType::Timecode => "TIMING_TYPE_TIMECODE",
                TimingType::TimeOfDay => "TIMING_TYPE_TIME_OF_DAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIMING_TYPE_NONE" => Some(Self::None),
                "TIMING_TYPE_TIMECODE" => Some(Self::Timecode),
                "TIMING_TYPE_TIME_OF_DAY" => Some(Self::TimeOfDay),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ChildrenType {
        #[prost(message, tag = "12")]
        Playlists(PlaylistArray),
        #[prost(message, tag = "13")]
        Items(PlaylistItems),
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum LinkData {
        #[prost(message, tag = "14")]
        SmartDirectory(FolderDirectory),
        #[prost(message, tag = "15")]
        PcoPlan(super::PlanningCenterPlan),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaylistItem {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub tags: ::prost::alloc::vec::Vec<Uuid>,
    #[prost(bool, tag = "9")]
    pub is_hidden: bool,
    #[prost(oneof = "playlist_item::ItemType", tags = "3, 4, 5, 6, 8")]
    pub item_type: ::core::option::Option<playlist_item::ItemType>,
}
/// Nested message and enum types in `PlaylistItem`.
pub mod playlist_item {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Header {
        #[prost(message, optional, tag = "1")]
        pub color: ::core::option::Option<super::Color>,
        #[prost(message, repeated, tag = "2")]
        pub actions: ::prost::alloc::vec::Vec<super::Action>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Presentation {
        #[prost(message, optional, tag = "1")]
        pub document_path: ::core::option::Option<super::Url>,
        #[prost(message, optional, tag = "2")]
        pub arrangement: ::core::option::Option<super::Uuid>,
        #[prost(enumeration = "super::action::ContentDestination", tag = "3")]
        pub content_destination: i32,
        #[prost(message, optional, tag = "4")]
        pub user_music_key: ::core::option::Option<super::MusicKeyScale>,
        #[prost(string, tag = "5")]
        pub arrangement_name: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlanningCenter {
        #[prost(message, optional, tag = "1")]
        pub item: ::core::option::Option<super::planning_center_plan::PlanItem>,
        #[prost(message, optional, boxed, tag = "2")]
        pub linked_data: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::PlaylistItem>,
        >,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Placeholder {
        #[prost(message, optional, boxed, tag = "1")]
        pub linked_data: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::PlaylistItem>,
        >,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ItemType {
        #[prost(message, tag = "3")]
        Header(Header),
        #[prost(message, tag = "4")]
        Presentation(Presentation),
        #[prost(message, tag = "5")]
        Cue(super::Cue),
        #[prost(message, tag = "6")]
        PlanningCenter(::prost::alloc::boxed::Box<PlanningCenter>),
        #[prost(message, tag = "8")]
        Placeholder(::prost::alloc::boxed::Box<Placeholder>),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProLabelsDocument {
    #[prost(message, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<action::Label>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Template {}
/// Nested message and enum types in `Template`.
pub mod template {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Slide {
        #[prost(message, optional, tag = "1")]
        pub base_slide: ::core::option::Option<super::Slide>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub actions: ::prost::alloc::vec::Vec<super::Action>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Document {
        #[prost(message, optional, tag = "1")]
        pub application_info: ::core::option::Option<super::ApplicationInfo>,
        #[prost(message, repeated, tag = "3")]
        pub slides: ::prost::alloc::vec::Vec<Slide>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcliDocument {
    #[prost(message, optional, tag = "1")]
    pub application_info: ::core::option::Option<ApplicationInfo>,
    #[prost(bool, tag = "2")]
    pub enable_ccli_display: bool,
    #[prost(string, tag = "3")]
    pub ccli_license: ::prost::alloc::string::String,
    #[prost(enumeration = "ccli_document::DisplayType", tag = "4")]
    pub display_type: i32,
    #[prost(message, optional, tag = "5")]
    pub template: ::core::option::Option<template::Slide>,
}
/// Nested message and enum types in `CCLIDocument`.
pub mod ccli_document {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DisplayType {
        FirstSlide = 0,
        LastSlide = 1,
        FirstAndLastSlide = 2,
        AllSlides = 3,
    }
    impl DisplayType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DisplayType::FirstSlide => "DISPLAY_TYPE_FIRST_SLIDE",
                DisplayType::LastSlide => "DISPLAY_TYPE_LAST_SLIDE",
                DisplayType::FirstAndLastSlide => "DISPLAY_TYPE_FIRST_AND_LAST_SLIDE",
                DisplayType::AllSlides => "DISPLAY_TYPE_ALL_SLIDES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISPLAY_TYPE_FIRST_SLIDE" => Some(Self::FirstSlide),
                "DISPLAY_TYPE_LAST_SLIDE" => Some(Self::LastSlide),
                "DISPLAY_TYPE_FIRST_AND_LAST_SLIDE" => Some(Self::FirstAndLastSlide),
                "DISPLAY_TYPE_ALL_SLIDES" => Some(Self::AllSlides),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyrightLayout {
    #[prost(message, repeated, tag = "2")]
    pub tokens: ::prost::alloc::vec::Vec<copyright_layout::Token>,
}
/// Nested message and enum types in `CopyrightLayout`.
pub mod copyright_layout {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Token {
        #[prost(enumeration = "TokenType", tag = "1")]
        pub token_type: i32,
        #[prost(string, tag = "2")]
        pub text: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TokenType {
        Text = 0,
        Artist = 1,
        Author = 2,
        Publisher = 3,
        Title = 4,
        CopyrightYear = 5,
        LicenseNumber = 6,
        SongNumber = 7,
    }
    impl TokenType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TokenType::Text => "Text",
                TokenType::Artist => "Artist",
                TokenType::Author => "Author",
                TokenType::Publisher => "Publisher",
                TokenType::Title => "Title",
                TokenType::CopyrightYear => "CopyrightYear",
                TokenType::LicenseNumber => "LicenseNumber",
                TokenType::SongNumber => "SongNumber",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Text" => Some(Self::Text),
                "Artist" => Some(Self::Artist),
                "Author" => Some(Self::Author),
                "Publisher" => Some(Self::Publisher),
                "Title" => Some(Self::Title),
                "CopyrightYear" => Some(Self::CopyrightYear),
                "LicenseNumber" => Some(Self::LicenseNumber),
                "SongNumber" => Some(Self::SongNumber),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MacrosDocument {
    #[prost(message, optional, tag = "1")]
    pub application_info: ::core::option::Option<ApplicationInfo>,
    #[prost(message, repeated, tag = "2")]
    pub macros: ::prost::alloc::vec::Vec<macros_document::Macro>,
    #[prost(message, repeated, tag = "3")]
    pub macro_collections: ::prost::alloc::vec::Vec<macros_document::MacroCollection>,
}
/// Nested message and enum types in `MacrosDocument`.
pub mod macros_document {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Macro {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub color: ::core::option::Option<super::Color>,
        #[prost(message, repeated, tag = "4")]
        pub actions: ::prost::alloc::vec::Vec<super::Action>,
        #[prost(bool, tag = "5")]
        pub trigger_on_startup: bool,
        #[prost(enumeration = "r#macro::ImageType", tag = "6")]
        pub image_type: i32,
        #[prost(bytes = "vec", tag = "7")]
        pub image_data: ::prost::alloc::vec::Vec<u8>,
    }
    /// Nested message and enum types in `Macro`.
    pub mod r#macro {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ImageType {
            Default = 0,
            One = 1,
            Two = 2,
            Three = 3,
            Four = 4,
            Five = 5,
            Six = 6,
            Seven = 7,
            Eight = 8,
            Nine = 9,
            Zero = 10,
            Arrow = 11,
            Audio = 12,
            Bell = 13,
            Bulb = 14,
            Cloud = 15,
            Cupcake = 16,
            Exclamation = 17,
            Flask = 18,
            Flower = 19,
            Glasses = 20,
            Hashtag = 21,
            Hat = 22,
            Heart = 23,
            Megaphone = 24,
            Message = 25,
            Paperclip = 26,
            Play = 27,
            Slide = 28,
            Star = 29,
            Sun = 30,
            Sunglasses = 31,
            Target = 32,
            Timer = 33,
            VideoInput = 34,
            XClear = 35,
            LetterA = 36,
            LetterB = 37,
            LetterC = 38,
            LetterD = 39,
            LetterE = 40,
            LetterF = 41,
            LetterG = 42,
            LetterH = 43,
            LetterI = 44,
            LetterJ = 45,
            LetterK = 46,
            LetterL = 47,
            LetterM = 48,
            LetterN = 49,
            LetterO = 50,
            LetterP = 51,
            LetterQ = 52,
            LetterR = 53,
            LetterS = 54,
            LetterT = 55,
            LetterU = 56,
            LetterV = 57,
            LetterW = 58,
            LetterX = 59,
            LetterY = 60,
            LetterZ = 61,
            Custom = 62,
        }
        impl ImageType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ImageType::Default => "ImageTypeDefault",
                    ImageType::One => "ImageTypeOne",
                    ImageType::Two => "ImageTypeTwo",
                    ImageType::Three => "ImageTypeThree",
                    ImageType::Four => "ImageTypeFour",
                    ImageType::Five => "ImageTypeFive",
                    ImageType::Six => "ImageTypeSix",
                    ImageType::Seven => "ImageTypeSeven",
                    ImageType::Eight => "ImageTypeEight",
                    ImageType::Nine => "ImageTypeNine",
                    ImageType::Zero => "ImageTypeZero",
                    ImageType::Arrow => "ImageTypeArrow",
                    ImageType::Audio => "ImageTypeAudio",
                    ImageType::Bell => "ImageTypeBell",
                    ImageType::Bulb => "ImageTypeBulb",
                    ImageType::Cloud => "ImageTypeCloud",
                    ImageType::Cupcake => "ImageTypeCupcake",
                    ImageType::Exclamation => "ImageTypeExclamation",
                    ImageType::Flask => "ImageTypeFlask",
                    ImageType::Flower => "ImageTypeFlower",
                    ImageType::Glasses => "ImageTypeGlasses",
                    ImageType::Hashtag => "ImageTypeHashtag",
                    ImageType::Hat => "ImageTypeHat",
                    ImageType::Heart => "ImageTypeHeart",
                    ImageType::Megaphone => "ImageTypeMegaphone",
                    ImageType::Message => "ImageTypeMessage",
                    ImageType::Paperclip => "ImageTypePaperclip",
                    ImageType::Play => "ImageTypePlay",
                    ImageType::Slide => "ImageTypeSlide",
                    ImageType::Star => "ImageTypeStar",
                    ImageType::Sun => "ImageTypeSun",
                    ImageType::Sunglasses => "ImageTypeSunglasses",
                    ImageType::Target => "ImageTypeTarget",
                    ImageType::Timer => "ImageTypeTimer",
                    ImageType::VideoInput => "ImageTypeVideoInput",
                    ImageType::XClear => "ImageTypeXClear",
                    ImageType::LetterA => "ImageTypeLetterA",
                    ImageType::LetterB => "ImageTypeLetterB",
                    ImageType::LetterC => "ImageTypeLetterC",
                    ImageType::LetterD => "ImageTypeLetterD",
                    ImageType::LetterE => "ImageTypeLetterE",
                    ImageType::LetterF => "ImageTypeLetterF",
                    ImageType::LetterG => "ImageTypeLetterG",
                    ImageType::LetterH => "ImageTypeLetterH",
                    ImageType::LetterI => "ImageTypeLetterI",
                    ImageType::LetterJ => "ImageTypeLetterJ",
                    ImageType::LetterK => "ImageTypeLetterK",
                    ImageType::LetterL => "ImageTypeLetterL",
                    ImageType::LetterM => "ImageTypeLetterM",
                    ImageType::LetterN => "ImageTypeLetterN",
                    ImageType::LetterO => "ImageTypeLetterO",
                    ImageType::LetterP => "ImageTypeLetterP",
                    ImageType::LetterQ => "ImageTypeLetterQ",
                    ImageType::LetterR => "ImageTypeLetterR",
                    ImageType::LetterS => "ImageTypeLetterS",
                    ImageType::LetterT => "ImageTypeLetterT",
                    ImageType::LetterU => "ImageTypeLetterU",
                    ImageType::LetterV => "ImageTypeLetterV",
                    ImageType::LetterW => "ImageTypeLetterW",
                    ImageType::LetterX => "ImageTypeLetterX",
                    ImageType::LetterY => "ImageTypeLetterY",
                    ImageType::LetterZ => "ImageTypeLetterZ",
                    ImageType::Custom => "ImageTypeCustom",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ImageTypeDefault" => Some(Self::Default),
                    "ImageTypeOne" => Some(Self::One),
                    "ImageTypeTwo" => Some(Self::Two),
                    "ImageTypeThree" => Some(Self::Three),
                    "ImageTypeFour" => Some(Self::Four),
                    "ImageTypeFive" => Some(Self::Five),
                    "ImageTypeSix" => Some(Self::Six),
                    "ImageTypeSeven" => Some(Self::Seven),
                    "ImageTypeEight" => Some(Self::Eight),
                    "ImageTypeNine" => Some(Self::Nine),
                    "ImageTypeZero" => Some(Self::Zero),
                    "ImageTypeArrow" => Some(Self::Arrow),
                    "ImageTypeAudio" => Some(Self::Audio),
                    "ImageTypeBell" => Some(Self::Bell),
                    "ImageTypeBulb" => Some(Self::Bulb),
                    "ImageTypeCloud" => Some(Self::Cloud),
                    "ImageTypeCupcake" => Some(Self::Cupcake),
                    "ImageTypeExclamation" => Some(Self::Exclamation),
                    "ImageTypeFlask" => Some(Self::Flask),
                    "ImageTypeFlower" => Some(Self::Flower),
                    "ImageTypeGlasses" => Some(Self::Glasses),
                    "ImageTypeHashtag" => Some(Self::Hashtag),
                    "ImageTypeHat" => Some(Self::Hat),
                    "ImageTypeHeart" => Some(Self::Heart),
                    "ImageTypeMegaphone" => Some(Self::Megaphone),
                    "ImageTypeMessage" => Some(Self::Message),
                    "ImageTypePaperclip" => Some(Self::Paperclip),
                    "ImageTypePlay" => Some(Self::Play),
                    "ImageTypeSlide" => Some(Self::Slide),
                    "ImageTypeStar" => Some(Self::Star),
                    "ImageTypeSun" => Some(Self::Sun),
                    "ImageTypeSunglasses" => Some(Self::Sunglasses),
                    "ImageTypeTarget" => Some(Self::Target),
                    "ImageTypeTimer" => Some(Self::Timer),
                    "ImageTypeVideoInput" => Some(Self::VideoInput),
                    "ImageTypeXClear" => Some(Self::XClear),
                    "ImageTypeLetterA" => Some(Self::LetterA),
                    "ImageTypeLetterB" => Some(Self::LetterB),
                    "ImageTypeLetterC" => Some(Self::LetterC),
                    "ImageTypeLetterD" => Some(Self::LetterD),
                    "ImageTypeLetterE" => Some(Self::LetterE),
                    "ImageTypeLetterF" => Some(Self::LetterF),
                    "ImageTypeLetterG" => Some(Self::LetterG),
                    "ImageTypeLetterH" => Some(Self::LetterH),
                    "ImageTypeLetterI" => Some(Self::LetterI),
                    "ImageTypeLetterJ" => Some(Self::LetterJ),
                    "ImageTypeLetterK" => Some(Self::LetterK),
                    "ImageTypeLetterL" => Some(Self::LetterL),
                    "ImageTypeLetterM" => Some(Self::LetterM),
                    "ImageTypeLetterN" => Some(Self::LetterN),
                    "ImageTypeLetterO" => Some(Self::LetterO),
                    "ImageTypeLetterP" => Some(Self::LetterP),
                    "ImageTypeLetterQ" => Some(Self::LetterQ),
                    "ImageTypeLetterR" => Some(Self::LetterR),
                    "ImageTypeLetterS" => Some(Self::LetterS),
                    "ImageTypeLetterT" => Some(Self::LetterT),
                    "ImageTypeLetterU" => Some(Self::LetterU),
                    "ImageTypeLetterV" => Some(Self::LetterV),
                    "ImageTypeLetterW" => Some(Self::LetterW),
                    "ImageTypeLetterX" => Some(Self::LetterX),
                    "ImageTypeLetterY" => Some(Self::LetterY),
                    "ImageTypeLetterZ" => Some(Self::LetterZ),
                    "ImageTypeCustom" => Some(Self::Custom),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MacroCollection {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub items: ::prost::alloc::vec::Vec<macro_collection::Item>,
    }
    /// Nested message and enum types in `MacroCollection`.
    pub mod macro_collection {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Item {
            #[prost(oneof = "item::ItemType", tags = "1")]
            pub item_type: ::core::option::Option<item::ItemType>,
        }
        /// Nested message and enum types in `Item`.
        pub mod item {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum ItemType {
                #[prost(message, tag = "1")]
                MacroId(super::super::super::Uuid),
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProClockSource {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub connected: bool,
    #[prost(bool, tag = "4")]
    pub active: bool,
    #[prost(enumeration = "pro_clock_source::Type", tag = "5")]
    pub r#type: i32,
}
/// Nested message and enum types in `ProClockSource`.
pub mod pro_clock_source {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unkown = 0,
        Input = 1,
        Output = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unkown => "TYPE_UNKOWN",
                Type::Input => "TYPE_INPUT",
                Type::Output => "TYPE_OUTPUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKOWN" => Some(Self::Unkown),
                "TYPE_INPUT" => Some(Self::Input),
                "TYPE_OUTPUT" => Some(Self::Output),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Preferences {
    #[prost(message, optional, tag = "1")]
    pub general: ::core::option::Option<preferences::General>,
    #[prost(message, optional, tag = "2")]
    pub screens: ::core::option::Option<preferences::Screens>,
    #[prost(message, optional, tag = "3")]
    pub import: ::core::option::Option<preferences::Import>,
    #[prost(message, optional, tag = "4")]
    pub groups: ::core::option::Option<preferences::Groups>,
    #[prost(message, optional, tag = "5")]
    pub network: ::core::option::Option<preferences::Network>,
    #[prost(message, optional, tag = "6")]
    pub sync: ::core::option::Option<preferences::Sync>,
    #[prost(message, optional, tag = "7")]
    pub advanced: ::core::option::Option<preferences::Advanced>,
    #[prost(message, optional, tag = "8")]
    pub updates: ::core::option::Option<preferences::Updates>,
}
/// Nested message and enum types in `Preferences`.
pub mod preferences {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct General {
        #[prost(bool, tag = "1")]
        pub house_of_worship_integrations: bool,
        #[prost(bool, tag = "2")]
        pub crash_reports: bool,
        #[prost(bool, tag = "3")]
        pub analytics: bool,
        #[prost(string, tag = "4")]
        pub logo_path: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub language: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Screens {
        #[prost(bool, tag = "1")]
        pub enable_at_launch: bool,
        #[prost(bool, tag = "2")]
        pub show_performance_stats: bool,
        #[prost(bool, tag = "3")]
        pub ignore_background_colors: bool,
        #[prost(message, optional, tag = "4")]
        pub clock_source: ::core::option::Option<super::ProClockSource>,
        #[prost(bool, tag = "5")]
        pub show_keynote_and_powerpoint: bool,
        #[prost(bool, tag = "6")]
        pub disable_blackmagic_sync_groups: bool,
        #[prost(bool, tag = "7")]
        pub use_directx_rendering: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Import {
        #[prost(enumeration = "super::media::ScaleBehavior", tag = "1")]
        pub foreground_scaling: i32,
        #[prost(bool, tag = "6")]
        pub foreground_is_blurred: bool,
        #[prost(enumeration = "super::media::ScaleBehavior", tag = "2")]
        pub background_scaling: i32,
        #[prost(bool, tag = "7")]
        pub background_is_blurred: bool,
        #[prost(message, optional, tag = "3")]
        pub image: ::core::option::Option<import::Image>,
        #[prost(message, optional, tag = "4")]
        pub video: ::core::option::Option<import::Video>,
        #[prost(message, optional, tag = "5")]
        pub audio: ::core::option::Option<import::Audio>,
    }
    /// Nested message and enum types in `Import`.
    pub mod import {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Image {
            #[prost(enumeration = "super::super::action::LayerType", tag = "1")]
            pub layer_type: i32,
            #[prost(message, optional, tag = "2")]
            pub duration: ::core::option::Option<image::Duration>,
            #[prost(enumeration = "super::super::cue::CompletionTargetType", tag = "3")]
            pub next_behavior: i32,
        }
        /// Nested message and enum types in `Image`.
        pub mod image {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Duration {
                #[prost(oneof = "duration::DurationType", tags = "1, 2, 3")]
                pub duration_type: ::core::option::Option<duration::DurationType>,
            }
            /// Nested message and enum types in `Duration`.
            pub mod duration {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct None {}
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Time {
                    #[prost(double, tag = "1")]
                    pub time: f64,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Random {
                    #[prost(double, tag = "1")]
                    pub minimum_time: f64,
                    #[prost(double, tag = "2")]
                    pub maximum_time: f64,
                }
                #[derive(serde::Serialize, serde::Deserialize)]
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum DurationType {
                    #[prost(message, tag = "1")]
                    None(None),
                    #[prost(message, tag = "2")]
                    Time(Time),
                    #[prost(message, tag = "3")]
                    Random(Random),
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Video {
            #[prost(enumeration = "super::super::action::LayerType", tag = "1")]
            pub layer_type: i32,
            #[prost(
                enumeration = "super::super::media::transport_properties::PlaybackBehavior",
                tag = "2"
            )]
            pub playback_behavior: i32,
            #[prost(
                enumeration = "super::super::media::video_properties::EndBehavior",
                tag = "3"
            )]
            pub end_behavior: i32,
            #[prost(enumeration = "super::super::cue::CompletionTargetType", tag = "4")]
            pub next_behavior: i32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Audio {
            #[prost(
                enumeration = "super::super::media::transport_properties::PlaybackBehavior",
                tag = "1"
            )]
            pub playback_behavior: i32,
            #[prost(enumeration = "super::super::cue::CompletionTargetType", tag = "2")]
            pub next_behavior: i32,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Groups {
        #[prost(message, optional, tag = "1")]
        pub groups: ::core::option::Option<super::ProGroupsDocument>,
        #[prost(message, optional, tag = "2")]
        pub labels: ::core::option::Option<super::ProLabelsDocument>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Network {
        #[prost(message, optional, tag = "1")]
        pub network: ::core::option::Option<network::Network>,
        #[prost(message, optional, tag = "2")]
        pub remotes: ::core::option::Option<network::Remotes>,
        #[prost(message, optional, tag = "3")]
        pub link: ::core::option::Option<network::Link>,
    }
    /// Nested message and enum types in `Network`.
    pub mod network {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Network {
            #[prost(bool, tag = "1")]
            pub enable: bool,
            #[prost(string, tag = "2")]
            pub name: ::prost::alloc::string::String,
            #[prost(uint32, tag = "3")]
            pub port: u32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Remotes {
            #[prost(message, optional, tag = "1")]
            pub pro_remote: ::core::option::Option<remotes::ProRemote>,
            #[prost(message, optional, tag = "2")]
            pub stage_app: ::core::option::Option<remotes::StageApp>,
        }
        /// Nested message and enum types in `Remotes`.
        pub mod remotes {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ProRemote {
                #[prost(bool, tag = "1")]
                pub enable: bool,
                #[prost(bool, tag = "2")]
                pub enable_controller: bool,
                #[prost(string, tag = "3")]
                pub controller_password: ::prost::alloc::string::String,
                #[prost(bool, tag = "4")]
                pub enable_observer: bool,
                #[prost(string, tag = "5")]
                pub observer_password: ::prost::alloc::string::String,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct StageApp {
                #[prost(bool, tag = "1")]
                pub enable: bool,
                #[prost(string, tag = "2")]
                pub password: ::prost::alloc::string::String,
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Link {
            #[prost(bool, tag = "1")]
            pub enable: bool,
            #[prost(string, tag = "2")]
            pub link_group: ::prost::alloc::string::String,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Sync {
        #[prost(string, tag = "1")]
        pub repository: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub include_libraries: bool,
        #[prost(bool, tag = "3")]
        pub include_media: bool,
        #[prost(bool, tag = "4")]
        pub include_playlists: bool,
        #[prost(bool, tag = "5")]
        pub include_themes: bool,
        #[prost(bool, tag = "6")]
        pub include_support_files: bool,
        #[prost(enumeration = "sync::SyncDirection", tag = "7")]
        pub direction: i32,
        #[prost(bool, tag = "8")]
        pub replace_destination_files: bool,
    }
    /// Nested message and enum types in `Sync`.
    pub mod sync {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SyncDirection {
            SyncDown = 0,
            SyncUp = 1,
        }
        impl SyncDirection {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    SyncDirection::SyncDown => "SYNC_DOWN",
                    SyncDirection::SyncUp => "SYNC_UP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SYNC_DOWN" => Some(Self::SyncDown),
                    "SYNC_UP" => Some(Self::SyncUp),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Advanced {
        #[prost(bool, tag = "1")]
        pub suppress_auto_start: bool,
        #[prost(enumeration = "advanced::AudioForegroundMediaBehavior", tag = "2")]
        pub presentation_audio_behavior: i32,
        #[prost(enumeration = "advanced::AudioForegroundMediaBehavior", tag = "3")]
        pub announcements_audio_behavior: i32,
        #[prost(message, optional, tag = "4")]
        pub ndi_discovery: ::core::option::Option<advanced::NdiDiscovery>,
        #[prost(string, tag = "5")]
        pub support_files_path: ::prost::alloc::string::String,
        #[prost(bool, tag = "6")]
        pub manage_media_automatically: bool,
        #[prost(message, optional, tag = "7")]
        pub search_paths: ::core::option::Option<advanced::SearchPaths>,
    }
    /// Nested message and enum types in `Advanced`.
    pub mod advanced {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct NdiDiscovery {
            #[prost(bool, tag = "1")]
            pub show_local_sources: bool,
            #[prost(string, tag = "2")]
            pub receive_groups: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub additional_search_ips: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SearchPaths {
            #[prost(bool, tag = "1")]
            pub automatically_relink: bool,
            #[prost(message, repeated, tag = "2")]
            pub paths: ::prost::alloc::vec::Vec<search_paths::Path>,
        }
        /// Nested message and enum types in `SearchPaths`.
        pub mod search_paths {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Path {
                #[prost(bool, tag = "1")]
                pub enable: bool,
                #[prost(string, tag = "2")]
                pub name: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub path: ::prost::alloc::string::String,
                #[prost(
                    enumeration = "super::super::super::url::local_relative_path::Root",
                    tag = "4"
                )]
                pub url_root: i32,
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AudioForegroundMediaBehavior {
            IgnoreForegroundMedia = 0,
            ClearForAllMedia = 1,
            ClearIfAudio = 2,
            PauseForAllMedia = 3,
            PauseIfAudio = 4,
        }
        impl AudioForegroundMediaBehavior {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    AudioForegroundMediaBehavior::IgnoreForegroundMedia => {
                        "IGNORE_FOREGROUND_MEDIA"
                    }
                    AudioForegroundMediaBehavior::ClearForAllMedia => {
                        "CLEAR_FOR_ALL_MEDIA"
                    }
                    AudioForegroundMediaBehavior::ClearIfAudio => "CLEAR_IF_AUDIO",
                    AudioForegroundMediaBehavior::PauseForAllMedia => {
                        "PAUSE_FOR_ALL_MEDIA"
                    }
                    AudioForegroundMediaBehavior::PauseIfAudio => "PAUSE_IF_AUDIO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "IGNORE_FOREGROUND_MEDIA" => Some(Self::IgnoreForegroundMedia),
                    "CLEAR_FOR_ALL_MEDIA" => Some(Self::ClearForAllMedia),
                    "CLEAR_IF_AUDIO" => Some(Self::ClearIfAudio),
                    "PAUSE_FOR_ALL_MEDIA" => Some(Self::PauseForAllMedia),
                    "PAUSE_IF_AUDIO" => Some(Self::PauseIfAudio),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Updates {
        #[prost(bool, tag = "1")]
        pub notify_when_available: bool,
        #[prost(enumeration = "updates::Channel", tag = "2")]
        pub update_channel: i32,
    }
    /// Nested message and enum types in `Updates`.
    pub mod updates {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Channel {
            Production = 0,
            Beta = 1,
        }
        impl Channel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Channel::Production => "production",
                    Channel::Beta => "beta",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "production" => Some(Self::Production),
                    "beta" => Some(Self::Beta),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPattern {
    #[prost(enumeration = "test_pattern::Type", tag = "1")]
    pub r#type: i32,
    #[prost(oneof = "test_pattern::PatternProperties", tags = "2, 3, 4")]
    pub pattern_properties: ::core::option::Option<test_pattern::PatternProperties>,
}
/// Nested message and enum types in `TestPattern`.
pub mod test_pattern {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlendGrid {
        #[prost(bool, tag = "1")]
        pub draw_grid: bool,
        #[prost(bool, tag = "2")]
        pub draw_circles: bool,
        #[prost(bool, tag = "3")]
        pub draw_lines: bool,
        #[prost(bool, tag = "4")]
        pub invert_colors: bool,
        #[prost(double, tag = "5")]
        pub grid_spacing: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomColor {
        #[prost(message, optional, tag = "1")]
        pub color: ::core::option::Option<super::Color>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IntensityColor {
        #[prost(double, tag = "1")]
        pub intensity: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        BlendGrid = 1,
        ColorBars = 2,
        Focus = 3,
        GrayScale = 4,
        BlackColor = 5,
        WhiteColor = 6,
        CustomColor = 7,
        Text = 8,
        VideoSync = 9,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unknown => "TYPE_UNKNOWN",
                Type::BlendGrid => "TYPE_BLEND_GRID",
                Type::ColorBars => "TYPE_COLOR_BARS",
                Type::Focus => "TYPE_FOCUS",
                Type::GrayScale => "TYPE_GRAY_SCALE",
                Type::BlackColor => "TYPE_BLACK_COLOR",
                Type::WhiteColor => "TYPE_WHITE_COLOR",
                Type::CustomColor => "TYPE_CUSTOM_COLOR",
                Type::Text => "TYPE_TEXT",
                Type::VideoSync => "TYPE_VIDEO_SYNC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "TYPE_BLEND_GRID" => Some(Self::BlendGrid),
                "TYPE_COLOR_BARS" => Some(Self::ColorBars),
                "TYPE_FOCUS" => Some(Self::Focus),
                "TYPE_GRAY_SCALE" => Some(Self::GrayScale),
                "TYPE_BLACK_COLOR" => Some(Self::BlackColor),
                "TYPE_WHITE_COLOR" => Some(Self::WhiteColor),
                "TYPE_CUSTOM_COLOR" => Some(Self::CustomColor),
                "TYPE_TEXT" => Some(Self::Text),
                "TYPE_VIDEO_SYNC" => Some(Self::VideoSync),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PatternProperties {
        #[prost(message, tag = "2")]
        BlendGrid(BlendGrid),
        #[prost(message, tag = "3")]
        CustomColor(CustomColor),
        #[prost(message, tag = "4")]
        Intensity(IntensityColor),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPatternDefinition {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name_localization_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub properties: ::prost::alloc::vec::Vec<test_pattern_definition::Property>,
    #[prost(bool, tag = "4")]
    pub show_delay_settings: bool,
    #[prost(bool, tag = "5")]
    pub is_default: bool,
}
/// Nested message and enum types in `TestPatternDefinition`.
pub mod test_pattern_definition {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ColorProperty {
        #[prost(message, optional, tag = "1")]
        pub value: ::core::option::Option<super::Color>,
        #[prost(bool, tag = "2")]
        pub allow_alpha: bool,
        #[prost(message, repeated, tag = "3")]
        pub default_colors: ::prost::alloc::vec::Vec<super::Color>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DoubleProperty {
        #[prost(double, tag = "1")]
        pub value: f64,
        #[prost(double, tag = "2")]
        pub min: f64,
        #[prost(double, tag = "3")]
        pub max: f64,
        #[prost(double, tag = "4")]
        pub step: f64,
        #[prost(string, tag = "5")]
        pub units: ::prost::alloc::string::String,
        #[prost(enumeration = "double_property::ViewType", tag = "6")]
        pub view_type: i32,
    }
    /// Nested message and enum types in `DoubleProperty`.
    pub mod double_property {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ViewType {
            Stepper = 0,
            Slider = 1,
            SpeedSlider = 2,
        }
        impl ViewType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ViewType::Stepper => "VIEW_TYPE_STEPPER",
                    ViewType::Slider => "VIEW_TYPE_SLIDER",
                    ViewType::SpeedSlider => "VIEW_TYPE_SPEED_SLIDER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "VIEW_TYPE_STEPPER" => Some(Self::Stepper),
                    "VIEW_TYPE_SLIDER" => Some(Self::Slider),
                    "VIEW_TYPE_SPEED_SLIDER" => Some(Self::SpeedSlider),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IntProperty {
        #[prost(int32, tag = "1")]
        pub value: i32,
        #[prost(int32, tag = "2")]
        pub min: i32,
        #[prost(int32, tag = "3")]
        pub max: i32,
        #[prost(string, tag = "5")]
        pub units: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BoolProperty {
        #[prost(bool, tag = "1")]
        pub value: bool,
        #[prost(message, repeated, tag = "2")]
        pub dependent_properties: ::prost::alloc::vec::Vec<Property>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringProperty {
        #[prost(string, tag = "1")]
        pub value: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub min_chars: i32,
        #[prost(int32, tag = "3")]
        pub max_chars: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FontProperty {
        #[prost(message, optional, tag = "1")]
        pub font: ::core::option::Option<super::Font>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SelectorProperty {
        #[prost(int32, tag = "1")]
        pub selected_index: i32,
        #[prost(string, repeated, tag = "2")]
        pub value_localization_keys: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Property {
        #[prost(string, tag = "1")]
        pub name_localization_key: ::prost::alloc::string::String,
        #[prost(oneof = "property::PropertyType", tags = "3, 4, 5, 6, 7, 8, 9")]
        pub property_type: ::core::option::Option<property::PropertyType>,
    }
    /// Nested message and enum types in `Property`.
    pub mod property {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum PropertyType {
            #[prost(message, tag = "3")]
            ColorProperty(super::ColorProperty),
            #[prost(message, tag = "4")]
            DoubleProperty(super::DoubleProperty),
            #[prost(message, tag = "5")]
            IntProperty(super::IntProperty),
            #[prost(message, tag = "6")]
            BoolProperty(super::BoolProperty),
            #[prost(message, tag = "7")]
            StringProperty(super::StringProperty),
            #[prost(message, tag = "8")]
            FontProperty(super::FontProperty),
            #[prost(message, tag = "9")]
            SelectorProperty(super::SelectorProperty),
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPatternRenderSettings {
    #[prost(message, optional, tag = "1")]
    pub pattern: ::core::option::Option<TestPatternDefinition>,
    #[prost(string, tag = "3")]
    pub screen_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub outputs: ::prost::alloc::vec::Vec<test_pattern_render_settings::Output>,
    #[prost(enumeration = "LogoType", tag = "5")]
    pub logo_type: i32,
    #[prost(string, tag = "6")]
    pub logo_file: ::prost::alloc::string::String,
    #[prost(int32, tag = "7")]
    pub render_width: i32,
    #[prost(int32, tag = "8")]
    pub render_height: i32,
    #[prost(bool, tag = "9")]
    pub enable_audio: bool,
}
/// Nested message and enum types in `TestPatternRenderSettings`.
pub mod test_pattern_render_settings {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Output {
        #[prost(int32, tag = "1")]
        pub x: i32,
        #[prost(int32, tag = "2")]
        pub y: i32,
        #[prost(int32, tag = "3")]
        pub width: i32,
        #[prost(int32, tag = "4")]
        pub height: i32,
        #[prost(string, tag = "5")]
        pub name: ::prost::alloc::string::String,
        #[prost(double, tag = "6")]
        pub frame_rate: f64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPatternState {
    #[prost(message, optional, tag = "1")]
    pub pattern: ::core::option::Option<TestPatternDefinition>,
    #[prost(bool, tag = "2")]
    pub show_pattern: bool,
    #[prost(enumeration = "test_pattern_state::DisplayLocation", tag = "3")]
    pub display_location: i32,
    #[prost(message, optional, tag = "4")]
    pub specific_screen: ::core::option::Option<Uuid>,
    #[prost(bool, tag = "5")]
    pub identify_screens: bool,
    #[prost(enumeration = "LogoType", tag = "6")]
    pub logo_type: i32,
    #[prost(message, optional, tag = "7")]
    pub user_logo_location: ::core::option::Option<Url>,
}
/// Nested message and enum types in `TestPatternState`.
pub mod test_pattern_state {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DisplayLocation {
        AllScreens = 0,
        AudienceScreens = 1,
        StageScreens = 2,
        SpecificScreen = 3,
    }
    impl DisplayLocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DisplayLocation::AllScreens => "DISPLAY_LOCATION_ALL_SCREENS",
                DisplayLocation::AudienceScreens => "DISPLAY_LOCATION_AUDIENCE_SCREENS",
                DisplayLocation::StageScreens => "DISPLAY_LOCATION_STAGE_SCREENS",
                DisplayLocation::SpecificScreen => "DISPLAY_LOCATION_SPECIFIC_SCREEN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISPLAY_LOCATION_ALL_SCREENS" => Some(Self::AllScreens),
                "DISPLAY_LOCATION_AUDIENCE_SCREENS" => Some(Self::AudienceScreens),
                "DISPLAY_LOCATION_STAGE_SCREENS" => Some(Self::StageScreens),
                "DISPLAY_LOCATION_SPECIFIC_SCREEN" => Some(Self::SpecificScreen),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPatternDocument {
    #[prost(message, optional, tag = "1")]
    pub state: ::core::option::Option<test_pattern_document::TestPatternStateData>,
    #[prost(message, repeated, tag = "2")]
    pub patterns: ::prost::alloc::vec::Vec<test_pattern_document::TestPatternData>,
}
/// Nested message and enum types in `TestPatternDocument`.
pub mod test_pattern_document {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TestPatternStateData {
        #[prost(message, optional, tag = "1")]
        pub test_pattern_id: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub test_pattern_name_localization_key: ::prost::alloc::string::String,
        #[prost(enumeration = "super::test_pattern_state::DisplayLocation", tag = "3")]
        pub display_location: i32,
        #[prost(message, optional, tag = "4")]
        pub specific_screen: ::core::option::Option<super::Uuid>,
        #[prost(bool, tag = "5")]
        pub identify_screens: bool,
        #[prost(enumeration = "super::LogoType", tag = "6")]
        pub logo_type: i32,
        #[prost(message, optional, tag = "7")]
        pub user_logo_location: ::core::option::Option<super::Url>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TestPatternData {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name_localization_key: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub properties: ::prost::alloc::vec::Vec<test_pattern_data::Property>,
    }
    /// Nested message and enum types in `TestPatternData`.
    pub mod test_pattern_data {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ColorProperty {
            #[prost(message, optional, tag = "1")]
            pub value: ::core::option::Option<super::super::Color>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DoubleProperty {
            #[prost(double, tag = "1")]
            pub value: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct IntProperty {
            #[prost(int32, tag = "1")]
            pub value: i32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BoolProperty {
            #[prost(bool, tag = "1")]
            pub value: bool,
            #[prost(message, repeated, tag = "2")]
            pub dependent_properties: ::prost::alloc::vec::Vec<Property>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct StringProperty {
            #[prost(string, tag = "1")]
            pub value: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FontProperty {
            #[prost(message, optional, tag = "1")]
            pub value: ::core::option::Option<super::super::Font>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SelectorProperty {
            #[prost(int32, tag = "1")]
            pub value: i32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Property {
            #[prost(string, tag = "1")]
            pub name_localization_key: ::prost::alloc::string::String,
            #[prost(oneof = "property::PropertyType", tags = "2, 3, 4, 5, 6, 7, 8")]
            pub property_type: ::core::option::Option<property::PropertyType>,
        }
        /// Nested message and enum types in `Property`.
        pub mod property {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum PropertyType {
                #[prost(message, tag = "2")]
                ColorProperty(super::ColorProperty),
                #[prost(message, tag = "3")]
                DoubleProperty(super::DoubleProperty),
                #[prost(message, tag = "4")]
                IntProperty(super::IntProperty),
                #[prost(message, tag = "5")]
                BoolProperty(super::BoolProperty),
                #[prost(message, tag = "6")]
                StringProperty(super::StringProperty),
                #[prost(message, tag = "7")]
                FontProperty(super::FontProperty),
                #[prost(message, tag = "8")]
                SelectorProperty(super::SelectorProperty),
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogoType {
    None = 0,
    Propresenter = 1,
    User = 2,
}
impl LogoType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LogoType::None => "LOGO_TYPE_NONE",
            LogoType::Propresenter => "LOGO_TYPE_PROPRESENTER",
            LogoType::User => "LOGO_TYPE_USER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOGO_TYPE_NONE" => Some(Self::None),
            "LOGO_TYPE_PROPRESENTER" => Some(Self::Propresenter),
            "LOGO_TYPE_USER" => Some(Self::User),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPatternRequest {
    #[prost(oneof = "test_pattern_request::Request", tags = "1, 2, 3, 4")]
    pub request: ::core::option::Option<test_pattern_request::Request>,
}
/// Nested message and enum types in `TestPatternRequest`.
pub mod test_pattern_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GetDefinitions {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GetCurrentState {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GetThumbnail {
        #[prost(message, optional, tag = "1")]
        pub pattern: ::core::option::Option<super::TestPatternDefinition>,
        #[prost(int32, tag = "2")]
        pub width: i32,
        #[prost(int32, tag = "3")]
        pub height: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "1")]
        GetDefinitions(GetDefinitions),
        #[prost(message, tag = "2")]
        SetCurrentState(super::TestPatternState),
        #[prost(message, tag = "3")]
        GetCurrentState(GetCurrentState),
        #[prost(message, tag = "4")]
        GetThumbnail(GetThumbnail),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPatternResponse {
    #[prost(oneof = "test_pattern_response::Response", tags = "1, 2, 3")]
    pub response: ::core::option::Option<test_pattern_response::Response>,
}
/// Nested message and enum types in `TestPatternResponse`.
pub mod test_pattern_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GetDefinitions {
        #[prost(message, repeated, tag = "1")]
        pub patterns: ::prost::alloc::vec::Vec<super::TestPatternDefinition>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GetThumbnail {
        #[prost(message, optional, tag = "1")]
        pub pattern: ::core::option::Option<super::Uuid>,
        #[prost(bytes = "vec", tag = "2")]
        pub image: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        GetDefinitions(GetDefinitions),
        #[prost(message, tag = "2")]
        GetCurrentState(super::TestPatternState),
        #[prost(message, tag = "3")]
        GetThumbnail(GetThumbnail),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropDocument {
    #[prost(message, optional, tag = "1")]
    pub application_info: ::core::option::Option<ApplicationInfo>,
    #[prost(message, repeated, tag = "2")]
    pub cues: ::prost::alloc::vec::Vec<Cue>,
    #[prost(message, optional, tag = "3")]
    pub transition: ::core::option::Option<Transition>,
    #[prost(message, repeated, tag = "4")]
    pub prop_collections: ::prost::alloc::vec::Vec<prop_document::PropCollection>,
}
/// Nested message and enum types in `PropDocument`.
pub mod prop_document {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PropCollection {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub items: ::prost::alloc::vec::Vec<prop_collection::Item>,
        #[prost(bool, tag = "4")]
        pub single_prop_enabled: bool,
    }
    /// Nested message and enum types in `PropCollection`.
    pub mod prop_collection {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Item {
            #[prost(oneof = "item::ItemType", tags = "1")]
            pub item_type: ::core::option::Option<item::ItemType>,
        }
        /// Nested message and enum types in `Item`.
        pub mod item {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum ItemType {
                #[prost(message, tag = "1")]
                PropCueUuid(super::super::super::Uuid),
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaylistDocument {
    #[prost(message, optional, tag = "1")]
    pub application_info: ::core::option::Option<ApplicationInfo>,
    #[prost(enumeration = "playlist_document::Type", tag = "2")]
    pub r#type: i32,
    #[prost(message, optional, tag = "3")]
    pub root_node: ::core::option::Option<Playlist>,
    #[prost(message, repeated, tag = "4")]
    pub tags: ::prost::alloc::vec::Vec<playlist::Tag>,
    #[prost(message, optional, tag = "5")]
    pub live_video_playlist: ::core::option::Option<Playlist>,
    #[prost(message, optional, tag = "6")]
    pub downloads_playlist: ::core::option::Option<Playlist>,
}
/// Nested message and enum types in `PlaylistDocument`.
pub mod playlist_document {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Presentation = 1,
        Media = 2,
        Audio = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unknown => "TYPE_UNKNOWN",
                Type::Presentation => "TYPE_PRESENTATION",
                Type::Media => "TYPE_MEDIA",
                Type::Audio => "TYPE_AUDIO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "TYPE_PRESENTATION" => Some(Self::Presentation),
                "TYPE_MEDIA" => Some(Self::Media),
                "TYPE_AUDIO" => Some(Self::Audio),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingsDocument {
    #[prost(message, repeated, tag = "2")]
    pub labels: ::prost::alloc::vec::Vec<action::Label>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Recording {}
/// Nested message and enum types in `Recording`.
pub mod recording {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SettingsDocument {
        #[prost(message, repeated, tag = "1")]
        pub streams: ::prost::alloc::vec::Vec<Stream>,
        #[prost(message, repeated, tag = "2")]
        pub presets: ::prost::alloc::vec::Vec<Preset>,
        #[prost(message, optional, tag = "3")]
        pub active_preset: ::core::option::Option<Preset>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Preset {
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub streams: ::prost::alloc::vec::Vec<Stream>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Stream {
        #[prost(message, optional, tag = "1")]
        pub id: ::core::option::Option<super::Uuid>,
        #[prost(message, optional, tag = "3")]
        pub encoder: ::core::option::Option<stream::Encoder>,
        #[prost(message, repeated, tag = "4")]
        pub destinations: ::prost::alloc::vec::Vec<stream::Destination>,
        #[prost(message, repeated, tag = "5")]
        pub audio_map: ::prost::alloc::vec::Vec<super::digital_audio::device::Map>,
        #[prost(bool, tag = "6")]
        pub is_audio_custom_mapped: bool,
        #[prost(oneof = "stream::Source", tags = "2")]
        pub source: ::core::option::Option<stream::Source>,
    }
    /// Nested message and enum types in `Stream`.
    pub mod stream {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Encoder {
            #[prost(enumeration = "Codec", tag = "1")]
            pub codec: i32,
            #[prost(uint32, tag = "2")]
            pub video_width: u32,
            #[prost(uint32, tag = "3")]
            pub video_height: u32,
            #[prost(bool, tag = "4")]
            pub is_interlaced: bool,
            #[prost(enumeration = "FrameRate", tag = "5")]
            pub frame_rate: i32,
            #[prost(uint32, tag = "6")]
            pub video_bitrate: u32,
            #[prost(uint32, tag = "7")]
            pub audio_bitrate: u32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OutputScreenSource {
            #[prost(message, optional, tag = "1")]
            pub screen_id: ::core::option::Option<super::super::Uuid>,
            #[prost(string, tag = "2")]
            pub screen_name: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DiskDestination {
            #[prost(message, optional, tag = "1")]
            pub location: ::core::option::Option<super::super::Url>,
            #[prost(enumeration = "Container", tag = "2")]
            pub container: i32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RtmpDestination {
            #[prost(string, tag = "1")]
            pub address: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub key: ::prost::alloc::string::String,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Destination {
            #[prost(oneof = "destination::Destination", tags = "1, 2, 3")]
            pub destination: ::core::option::Option<destination::Destination>,
        }
        /// Nested message and enum types in `Destination`.
        pub mod destination {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Resi {
                #[prost(message, optional, tag = "1")]
                pub destination_group_id: ::core::option::Option<
                    super::super::super::Uuid,
                >,
                #[prost(message, optional, tag = "2")]
                pub encoder_profile_id: ::core::option::Option<
                    super::super::super::Uuid,
                >,
            }
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Destination {
                #[prost(message, tag = "1")]
                Disk(super::DiskDestination),
                #[prost(message, tag = "2")]
                Rtmp(super::RtmpDestination),
                #[prost(message, tag = "3")]
                Resi(Resi),
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Container {
            Unknown = 0,
            Mov = 1,
            Mp4 = 2,
        }
        impl Container {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Container::Unknown => "CONTAINER_UNKNOWN",
                    Container::Mov => "CONTAINER_MOV",
                    Container::Mp4 => "CONTAINER_MP4",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONTAINER_UNKNOWN" => Some(Self::Unknown),
                    "CONTAINER_MOV" => Some(Self::Mov),
                    "CONTAINER_MP4" => Some(Self::Mp4),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Codec {
            Automatic = 0,
            H264 = 1,
            H265 = 2,
            Prores422Proxy = 3,
            Prores422Lt = 4,
            Prores422 = 5,
            Prores422Hq = 6,
            Prores4444 = 7,
            Prores4444Xq = 8,
            Hap = 9,
            HapAlpha = 10,
            HapQ = 11,
            HapQAlpha = 12,
            Notch = 13,
            H264Software = 14,
            H265Software = 15,
        }
        impl Codec {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Codec::Automatic => "CODEC_AUTOMATIC",
                    Codec::H264 => "CODEC_H264",
                    Codec::H265 => "CODEC_H265",
                    Codec::Prores422Proxy => "CODEC_PRORES_422_PROXY",
                    Codec::Prores422Lt => "CODEC_PRORES_422_LT",
                    Codec::Prores422 => "CODEC_PRORES_422",
                    Codec::Prores422Hq => "CODEC_PRORES_422_HQ",
                    Codec::Prores4444 => "CODEC_PRORES_4444",
                    Codec::Prores4444Xq => "CODEC_PRORES_4444_XQ",
                    Codec::Hap => "CODEC_HAP",
                    Codec::HapAlpha => "CODEC_HAP_ALPHA",
                    Codec::HapQ => "CODEC_HAP_Q",
                    Codec::HapQAlpha => "CODEC_HAP_Q_ALPHA",
                    Codec::Notch => "CODEC_NOTCH",
                    Codec::H264Software => "CODEC_H264_SOFTWARE",
                    Codec::H265Software => "CODEC_H265_SOFTWARE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CODEC_AUTOMATIC" => Some(Self::Automatic),
                    "CODEC_H264" => Some(Self::H264),
                    "CODEC_H265" => Some(Self::H265),
                    "CODEC_PRORES_422_PROXY" => Some(Self::Prores422Proxy),
                    "CODEC_PRORES_422_LT" => Some(Self::Prores422Lt),
                    "CODEC_PRORES_422" => Some(Self::Prores422),
                    "CODEC_PRORES_422_HQ" => Some(Self::Prores422Hq),
                    "CODEC_PRORES_4444" => Some(Self::Prores4444),
                    "CODEC_PRORES_4444_XQ" => Some(Self::Prores4444Xq),
                    "CODEC_HAP" => Some(Self::Hap),
                    "CODEC_HAP_ALPHA" => Some(Self::HapAlpha),
                    "CODEC_HAP_Q" => Some(Self::HapQ),
                    "CODEC_HAP_Q_ALPHA" => Some(Self::HapQAlpha),
                    "CODEC_NOTCH" => Some(Self::Notch),
                    "CODEC_H264_SOFTWARE" => Some(Self::H264Software),
                    "CODEC_H265_SOFTWARE" => Some(Self::H265Software),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FrameRate {
            Unknown = 0,
            FrameRate24 = 1,
            FrameRate25 = 2,
            FrameRate2997 = 3,
            FrameRate30 = 4,
            FrameRate50 = 5,
            FrameRate5994 = 6,
            FrameRate60 = 7,
        }
        impl FrameRate {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    FrameRate::Unknown => "FRAME_RATE_UNKNOWN",
                    FrameRate::FrameRate24 => "FRAME_RATE_24",
                    FrameRate::FrameRate25 => "FRAME_RATE_25",
                    FrameRate::FrameRate2997 => "FRAME_RATE_29_97",
                    FrameRate::FrameRate30 => "FRAME_RATE_30",
                    FrameRate::FrameRate50 => "FRAME_RATE_50",
                    FrameRate::FrameRate5994 => "FRAME_RATE_59_94",
                    FrameRate::FrameRate60 => "FRAME_RATE_60",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FRAME_RATE_UNKNOWN" => Some(Self::Unknown),
                    "FRAME_RATE_24" => Some(Self::FrameRate24),
                    "FRAME_RATE_25" => Some(Self::FrameRate25),
                    "FRAME_RATE_29_97" => Some(Self::FrameRate2997),
                    "FRAME_RATE_30" => Some(Self::FrameRate30),
                    "FRAME_RATE_50" => Some(Self::FrameRate50),
                    "FRAME_RATE_59_94" => Some(Self::FrameRate5994),
                    "FRAME_RATE_60" => Some(Self::FrameRate60),
                    _ => None,
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Source {
            #[prost(message, tag = "2")]
            OutputScreen(OutputScreenSource),
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Audio {}
/// Nested message and enum types in `Audio`.
pub mod audio {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SettingsDocument {
        #[prost(message, optional, tag = "1")]
        pub output_setup: ::core::option::Option<OutputSetup>,
        #[prost(message, optional, tag = "2")]
        pub monitor_device: ::core::option::Option<Device>,
        #[prost(bool, tag = "3")]
        pub monitor_on_mains: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OutputSetup {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(message, optional, tag = "2")]
        pub audio_device: ::core::option::Option<Device>,
        #[prost(message, repeated, tag = "3")]
        pub logical_channels: ::prost::alloc::vec::Vec<LogicalChannel>,
        #[prost(double, tag = "4")]
        pub audio_delay: f64,
        #[prost(double, tag = "5")]
        pub master_level: f64,
        #[prost(message, repeated, tag = "6")]
        pub physical_chanels: ::prost::alloc::vec::Vec<PhysicalChannel>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Device {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub render_id: ::prost::alloc::string::String,
        #[prost(uint32, tag = "3")]
        pub input_channel_count: u32,
        #[prost(uint32, tag = "4")]
        pub output_channel_count: u32,
        #[prost(message, repeated, tag = "5")]
        pub formats: ::prost::alloc::vec::Vec<device::Format>,
    }
    /// Nested message and enum types in `Device`.
    pub mod device {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Format {
            #[prost(uint32, tag = "1")]
            pub sample_rate: u32,
            #[prost(uint32, tag = "2")]
            pub bit_depth: u32,
            #[prost(enumeration = "format::Type", tag = "3")]
            pub r#type: i32,
        }
        /// Nested message and enum types in `Format`.
        pub mod format {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                Int = 0,
                Float = 1,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Type::Int => "TYPE_INT",
                        Type::Float => "TYPE_FLOAT",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TYPE_INT" => Some(Self::Int),
                        "TYPE_FLOAT" => Some(Self::Float),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LogicalChannel {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(uint32, tag = "3")]
        pub index: u32,
        #[prost(bool, tag = "4")]
        pub muted: bool,
        #[prost(message, repeated, tag = "5")]
        pub physical_audio_channels: ::prost::alloc::vec::Vec<
            logical_channel::OutputChannel,
        >,
        #[prost(bool, tag = "6")]
        pub solo: bool,
        #[prost(bool, tag = "7")]
        pub test_tone: bool,
    }
    /// Nested message and enum types in `LogicalChannel`.
    pub mod logical_channel {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OutputChannel {
            #[prost(uint32, tag = "1")]
            pub index: u32,
            #[prost(bool, tag = "2")]
            pub muted: bool,
            #[prost(bool, tag = "3")]
            pub solo: bool,
            #[prost(bool, tag = "4")]
            pub test_tone: bool,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PhysicalChannel {
        #[prost(uint32, tag = "1")]
        pub index: u32,
        #[prost(bool, tag = "2")]
        pub mute_enable: bool,
        #[prost(bool, tag = "3")]
        pub solo_enable: bool,
        #[prost(bool, tag = "4")]
        pub tone_enable: bool,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProAudienceLook {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub screen_looks: ::prost::alloc::vec::Vec<pro_audience_look::ProScreenLook>,
    #[prost(message, optional, tag = "4")]
    pub original_look_uuid: ::core::option::Option<Uuid>,
    #[prost(double, tag = "5")]
    pub transition_duration: f64,
}
/// Nested message and enum types in `ProAudienceLook`.
pub mod pro_audience_look {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProScreenLook {
        #[prost(message, optional, tag = "1")]
        pub pro_screen_uuid: ::core::option::Option<super::Uuid>,
        #[prost(bool, tag = "2")]
        pub props_enabled: bool,
        #[prost(bool, tag = "3")]
        pub live_video_enabled: bool,
        #[prost(bool, tag = "4")]
        pub presentation_background_enabled: bool,
        #[prost(message, optional, tag = "5")]
        pub template_document_file_path: ::core::option::Option<super::Url>,
        #[prost(message, optional, tag = "6")]
        pub template_slide_uuid: ::core::option::Option<super::Uuid>,
        #[prost(bool, tag = "7")]
        pub presentation_foreground_enabled: bool,
        #[prost(message, optional, tag = "8")]
        pub mask_uuid: ::core::option::Option<super::Uuid>,
        #[prost(bool, tag = "9")]
        pub announcements_enabled: bool,
        #[prost(bool, tag = "10")]
        pub props_layer_enabled: bool,
        #[prost(bool, tag = "11")]
        pub messages_layer_enabled: bool,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceLookCollection {
    #[prost(message, repeated, tag = "1")]
    pub collection: ::prost::alloc::vec::Vec<ProAudienceLook>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Screen {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub color: ::core::option::Option<Color>,
    #[prost(message, optional, tag = "4")]
    pub bounds: ::core::option::Option<graphics::Rect>,
    #[prost(bool, tag = "5")]
    pub aspect_ratio_locked: bool,
    #[prost(bool, tag = "6")]
    pub output_bounds_aspect_ratio_locked: bool,
    #[prost(bool, tag = "7")]
    pub corner_pinning_enabled: bool,
    #[prost(message, optional, tag = "8")]
    pub subscreen_unit_rect: ::core::option::Option<graphics::Rect>,
    #[prost(double, tag = "9")]
    pub rotation: f64,
    #[prost(double, tag = "10")]
    pub gamma: f64,
    #[prost(double, tag = "11")]
    pub black_level: f64,
    #[prost(uint32, tag = "12")]
    pub blended_edges: u32,
    #[prost(message, optional, tag = "13")]
    pub corner_values: ::core::option::Option<CornerValues>,
    #[prost(message, optional, tag = "14")]
    pub output_display: ::core::option::Option<OutputDisplay>,
    #[prost(bool, tag = "15")]
    pub color_enabled: bool,
    #[prost(message, optional, tag = "16")]
    pub color_adjustment: ::core::option::Option<screen::ColorAdjustment>,
    #[prost(message, optional, tag = "17")]
    pub blend_compensation: ::core::option::Option<screen::BlendCompensation>,
    #[prost(message, optional, tag = "18")]
    pub alpha_settings: ::core::option::Option<screen::AlphaSettings>,
}
/// Nested message and enum types in `Screen`.
pub mod screen {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ColorAdjustment {
        #[prost(double, tag = "1")]
        pub gamma: f64,
        #[prost(double, tag = "2")]
        pub black_level: f64,
        #[prost(double, tag = "3")]
        pub red_level: f64,
        #[prost(double, tag = "4")]
        pub green_level: f64,
        #[prost(double, tag = "5")]
        pub blue_level: f64,
        #[prost(double, tag = "6")]
        pub brightness: f64,
        #[prost(double, tag = "7")]
        pub contrast: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlendCompensation {
        #[prost(double, tag = "1")]
        pub black_level: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AlphaSettings {
        #[prost(enumeration = "alpha_settings::Mode", tag = "1")]
        pub mode: i32,
        #[prost(message, optional, tag = "2")]
        pub alpha_device: ::core::option::Option<alpha_settings::AlphaDevice>,
    }
    /// Nested message and enum types in `AlphaSettings`.
    pub mod alpha_settings {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AlphaDevice {
            #[prost(message, optional, tag = "1")]
            pub display: ::core::option::Option<super::super::OutputDisplay>,
            #[prost(message, optional, tag = "2")]
            pub subscreen_unit_rect: ::core::option::Option<
                super::super::graphics::Rect,
            >,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Mode {
            Unknown = 0,
            Disabled = 1,
            Premultiplied = 2,
            Straight = 3,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Mode::Unknown => "MODE_UNKNOWN",
                    Mode::Disabled => "MODE_DISABLED",
                    Mode::Premultiplied => "MODE_PREMULTIPLIED",
                    Mode::Straight => "MODE_STRAIGHT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MODE_UNKNOWN" => Some(Self::Unknown),
                    "MODE_DISABLED" => Some(Self::Disabled),
                    "MODE_PREMULTIPLIED" => Some(Self::Premultiplied),
                    "MODE_STRAIGHT" => Some(Self::Straight),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CornerValues {
    #[prost(message, optional, tag = "1")]
    pub top_left: ::core::option::Option<graphics::Point>,
    #[prost(message, optional, tag = "2")]
    pub top_right: ::core::option::Option<graphics::Point>,
    #[prost(message, optional, tag = "3")]
    pub bottom_left: ::core::option::Option<graphics::Point>,
    #[prost(message, optional, tag = "4")]
    pub bottom_right: ::core::option::Option<graphics::Point>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisplayMode {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub width: u32,
    #[prost(uint32, tag = "3")]
    pub height: u32,
    #[prost(double, tag = "4")]
    pub refresh_rate: f64,
    #[prost(bool, tag = "5")]
    pub interlaced: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputDisplay {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub serial: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub device_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub vendor: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub mode_index: u32,
    #[prost(message, optional, tag = "7")]
    pub bounds: ::core::option::Option<graphics::Rect>,
    #[prost(enumeration = "output_display::Type", tag = "8")]
    pub r#type: i32,
    #[prost(message, optional, tag = "9")]
    pub mode: ::core::option::Option<DisplayMode>,
    #[prost(string, tag = "10")]
    pub render_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "12")]
    pub video_delay: i32,
    #[prost(oneof = "output_display::HardwareOptions", tags = "11")]
    pub hardware_options: ::core::option::Option<output_display::HardwareOptions>,
}
/// Nested message and enum types in `OutputDisplay`.
pub mod output_display {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Blackmagic {
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        #[prost(enumeration = "blackmagic::KeyMode", tag = "2")]
        pub key_mode: i32,
        #[prost(double, tag = "3")]
        pub blend_value: f64,
    }
    /// Nested message and enum types in `Blackmagic`.
    pub mod blackmagic {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum KeyMode {
            Internal = 0,
            External = 1,
        }
        impl KeyMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    KeyMode::Internal => "KEY_MODE_INTERNAL",
                    KeyMode::External => "KEY_MODE_EXTERNAL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KEY_MODE_INTERNAL" => Some(Self::Internal),
                    "KEY_MODE_EXTERNAL" => Some(Self::External),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Screen = 1,
        Card = 2,
        Ndi = 3,
        Syphon = 4,
        Custom = 5,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unknown => "TYPE_UNKNOWN",
                Type::Screen => "TYPE_SCREEN",
                Type::Card => "TYPE_CARD",
                Type::Ndi => "TYPE_NDI",
                Type::Syphon => "TYPE_SYPHON",
                Type::Custom => "TYPE_CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "TYPE_SCREEN" => Some(Self::Screen),
                "TYPE_CARD" => Some(Self::Card),
                "TYPE_NDI" => Some(Self::Ndi),
                "TYPE_SYPHON" => Some(Self::Syphon),
                "TYPE_CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum HardwareOptions {
        #[prost(message, tag = "11")]
        Blackmagic(Blackmagic),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EdgeBlend {
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(double, tag = "2")]
    pub radius: f64,
    #[prost(double, tag = "3")]
    pub intensity: f64,
    #[prost(enumeration = "edge_blend::Mode", tag = "4")]
    pub mode: i32,
    #[prost(message, optional, tag = "5")]
    pub first_screen: ::core::option::Option<edge_blend::Screen>,
    #[prost(message, optional, tag = "6")]
    pub second_screen: ::core::option::Option<edge_blend::Screen>,
    #[prost(message, optional, tag = "7")]
    pub left_screen: ::core::option::Option<edge_blend::Screen>,
    #[prost(message, optional, tag = "8")]
    pub right_screen: ::core::option::Option<edge_blend::Screen>,
    #[prost(message, optional, tag = "9")]
    pub top_screen: ::core::option::Option<edge_blend::Screen>,
    #[prost(message, optional, tag = "10")]
    pub bottom_screen: ::core::option::Option<edge_blend::Screen>,
}
/// Nested message and enum types in `EdgeBlend`.
pub mod edge_blend {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Screen {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(enumeration = "screen::Edge", tag = "2")]
        pub edge: i32,
        #[prost(double, tag = "3")]
        pub gamma: f64,
        #[prost(double, tag = "4")]
        pub black_level: f64,
        #[prost(enumeration = "Mode", tag = "5")]
        pub mode: i32,
        #[prost(double, tag = "6")]
        pub radius: f64,
        #[prost(double, tag = "7")]
        pub intensity: f64,
    }
    /// Nested message and enum types in `Screen`.
    pub mod screen {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Edge {
            Unknown = 0,
            Left = 1,
            Right = 2,
            Top = 3,
            Bottom = 4,
        }
        impl Edge {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Edge::Unknown => "EDGE_UNKNOWN",
                    Edge::Left => "EDGE_LEFT",
                    Edge::Right => "EDGE_RIGHT",
                    Edge::Top => "EDGE_TOP",
                    Edge::Bottom => "EDGE_BOTTOM",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "EDGE_UNKNOWN" => Some(Self::Unknown),
                    "EDGE_LEFT" => Some(Self::Left),
                    "EDGE_RIGHT" => Some(Self::Right),
                    "EDGE_TOP" => Some(Self::Top),
                    "EDGE_BOTTOM" => Some(Self::Bottom),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Linear = 0,
        Cubic = 1,
        Quadratic = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::Linear => "MODE_LINEAR",
                Mode::Cubic => "MODE_CUBIC",
                Mode::Quadratic => "MODE_QUADRATIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_LINEAR" => Some(Self::Linear),
                "MODE_CUBIC" => Some(Self::Cubic),
                "MODE_QUADRATIC" => Some(Self::Quadratic),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProPresenterScreen {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "pro_presenter_screen::ScreenType", tag = "2")]
    pub screen_type: i32,
    #[prost(message, optional, tag = "6")]
    pub background_color: ::core::option::Option<Color>,
    #[prost(message, optional, tag = "7")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(bool, tag = "8")]
    pub background_color_enabled: bool,
    #[prost(oneof = "pro_presenter_screen::Arrangement", tags = "3, 4, 5")]
    pub arrangement: ::core::option::Option<pro_presenter_screen::Arrangement>,
}
/// Nested message and enum types in `ProPresenterScreen`.
pub mod pro_presenter_screen {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SingleArrangement {
        #[prost(message, repeated, tag = "1")]
        pub screens: ::prost::alloc::vec::Vec<super::Screen>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CombinedArrangement {
        #[prost(message, repeated, tag = "1")]
        pub screens: ::prost::alloc::vec::Vec<super::Screen>,
        #[prost(uint32, tag = "2")]
        pub rows: u32,
        #[prost(uint32, tag = "3")]
        pub columns: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EdgeBlendArrangement {
        #[prost(uint32, tag = "1")]
        pub screen_count: u32,
        #[prost(message, repeated, tag = "2")]
        pub screens: ::prost::alloc::vec::Vec<super::Screen>,
        #[prost(message, repeated, tag = "3")]
        pub edge_blends: ::prost::alloc::vec::Vec<super::EdgeBlend>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScreenType {
        Unknown = 0,
        Audience = 1,
        Stage = 2,
    }
    impl ScreenType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ScreenType::Unknown => "SCREEN_TYPE_UNKNOWN",
                ScreenType::Audience => "SCREEN_TYPE_AUDIENCE",
                ScreenType::Stage => "SCREEN_TYPE_STAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCREEN_TYPE_UNKNOWN" => Some(Self::Unknown),
                "SCREEN_TYPE_AUDIENCE" => Some(Self::Audience),
                "SCREEN_TYPE_STAGE" => Some(Self::Stage),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Arrangement {
        #[prost(message, tag = "3")]
        ArrangementSingle(SingleArrangement),
        #[prost(message, tag = "4")]
        ArrangementCombined(CombinedArrangement),
        #[prost(message, tag = "5")]
        ArrangementEdgeBlend(EdgeBlendArrangement),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProMask {
    #[prost(message, optional, tag = "1")]
    pub base_slide: ::core::option::Option<Slide>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaskCollection {
    #[prost(message, repeated, tag = "1")]
    pub collection: ::prost::alloc::vec::Vec<ProMask>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProPresenterWorkspace {
    #[prost(message, repeated, tag = "1")]
    pub pro_screens: ::prost::alloc::vec::Vec<ProPresenterScreen>,
    #[prost(message, repeated, tag = "2")]
    pub audience_looks: ::prost::alloc::vec::Vec<ProAudienceLook>,
    #[prost(message, optional, tag = "3")]
    pub live_audience_look: ::core::option::Option<ProAudienceLook>,
    #[prost(message, repeated, tag = "4")]
    pub masks: ::prost::alloc::vec::Vec<ProMask>,
    #[prost(message, repeated, tag = "5")]
    pub video_inputs: ::prost::alloc::vec::Vec<VideoInput>,
    #[prost(message, repeated, tag = "6")]
    pub stage_layout_mappings: ::prost::alloc::vec::Vec<stage::ScreenAssignment>,
    #[prost(message, optional, tag = "7")]
    pub audio_settings: ::core::option::Option<audio::SettingsDocument>,
    #[prost(string, tag = "8")]
    pub selected_library_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub record_settings: ::core::option::Option<recording::SettingsDocument>,
    #[prost(message, optional, tag = "10")]
    pub digital_audio_setup: ::core::option::Option<digital_audio::Setup>,
    #[prost(message, repeated, tag = "11")]
    pub audio_inputs: ::prost::alloc::vec::Vec<AudioInput>,
    #[prost(double, tag = "12")]
    pub audio_input_transition_time: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerSource {
    #[prost(oneof = "trigger_source::Location", tags = "1, 2, 3, 4")]
    pub location: ::core::option::Option<trigger_source::Location>,
}
/// Nested message and enum types in `TriggerSource`.
pub mod trigger_source {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Library {
        #[prost(string, tag = "1")]
        pub path: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub presentation_name: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Playlist {
        #[prost(message, optional, tag = "1")]
        pub identifier: ::core::option::Option<super::Uuid>,
        #[prost(message, optional, tag = "2")]
        pub item_identifier: ::core::option::Option<super::Uuid>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Location {
        #[prost(message, tag = "1")]
        LibraryLocation(Library),
        #[prost(message, tag = "2")]
        PlaylistLocation(Playlist),
        #[prost(message, tag = "3")]
        MediaPlaylistLocation(Playlist),
        #[prost(message, tag = "4")]
        AudioPlaylistLocation(Playlist),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimedPlayback {
    #[prost(message, optional, tag = "1")]
    pub sequence: ::core::option::Option<timed_playback::Sequence>,
    #[prost(message, optional, tag = "2")]
    pub timing: ::core::option::Option<timed_playback::Timing>,
}
/// Nested message and enum types in `TimedPlayback`.
pub mod timed_playback {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Sequence {
        #[prost(message, repeated, tag = "1")]
        pub sequence: ::prost::alloc::vec::Vec<sequence::SequenceItem>,
        #[prost(enumeration = "super::action::ContentDestination", tag = "2")]
        pub content_destination: i32,
        #[prost(message, optional, tag = "3")]
        pub presentation: ::core::option::Option<super::Presentation>,
        #[prost(message, optional, tag = "4")]
        pub playlist: ::core::option::Option<super::Playlist>,
    }
    /// Nested message and enum types in `Sequence`.
    pub mod sequence {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SequenceItem {
            #[prost(message, optional, tag = "1")]
            pub identifier: ::core::option::Option<super::super::Uuid>,
            #[prost(double, tag = "2")]
            pub time: f64,
            #[prost(message, optional, tag = "3")]
            pub trigger_source: ::core::option::Option<super::super::TriggerSource>,
            #[prost(enumeration = "super::super::action::ContentDestination", tag = "4")]
            pub content_destination: i32,
            #[prost(double, tag = "7")]
            pub end_time: f64,
            #[prost(oneof = "sequence_item::Item", tags = "5, 6")]
            pub item: ::core::option::Option<sequence_item::Item>,
        }
        /// Nested message and enum types in `SequenceItem`.
        pub mod sequence_item {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Item {
                #[prost(message, tag = "5")]
                Cue(super::super::super::Cue),
                #[prost(message, tag = "6")]
                Action(super::super::super::Action),
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Timing {
        #[prost(oneof = "timing::Source", tags = "1, 2, 3")]
        pub source: ::core::option::Option<timing::Source>,
    }
    /// Nested message and enum types in `Timing`.
    pub mod timing {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LayerTransport {
            #[prost(int32, tag = "1")]
            pub layer: i32,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SmpteTimecode {
            #[prost(string, tag = "1")]
            pub device_identifier: ::prost::alloc::string::String,
            #[prost(int32, tag = "2")]
            pub channel: i32,
            #[prost(enumeration = "smpte_timecode::Format", tag = "3")]
            pub format: i32,
            #[prost(double, tag = "4")]
            pub offset: f64,
        }
        /// Nested message and enum types in `SMPTETimecode`.
        pub mod smpte_timecode {
            #[derive(serde::Serialize, serde::Deserialize)]
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Format {
                Format24Fps = 0,
                Format25Fps = 1,
                Format2997Fps = 2,
                Format30Fps = 3,
            }
            impl Format {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Format::Format24Fps => "FORMAT_24_FPS",
                        Format::Format25Fps => "FORMAT_25_FPS",
                        Format::Format2997Fps => "FORMAT_29_97_FPS",
                        Format::Format30Fps => "FORMAT_30_FPS",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "FORMAT_24_FPS" => Some(Self::Format24Fps),
                        "FORMAT_25_FPS" => Some(Self::Format25Fps),
                        "FORMAT_29_97_FPS" => Some(Self::Format2997Fps),
                        "FORMAT_30_FPS" => Some(Self::Format30Fps),
                        _ => None,
                    }
                }
            }
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Internal {
            #[prost(double, tag = "1")]
            pub duration: f64,
            #[prost(bool, tag = "2")]
            pub should_loop: bool,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Source {
            #[prost(message, tag = "1")]
            LayerTransport(LayerTransport),
            #[prost(message, tag = "2")]
            SmpteTimecode(SmpteTimecode),
            #[prost(message, tag = "3")]
            Internal(Internal),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Update {
        #[prost(
            oneof = "update::ActionType",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11"
        )]
        pub action_type: ::core::option::Option<update::ActionType>,
    }
    /// Nested message and enum types in `Update`.
    pub mod update {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Play {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Record {
            #[prost(bool, tag = "1")]
            pub is_recording: bool,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Pause {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Reset {}
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JumpToTime {
            #[prost(double, tag = "1")]
            pub time: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct StartScrub {
            #[prost(double, tag = "1")]
            pub time: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EndScrub {
            #[prost(double, tag = "2")]
            pub time: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Duration {
            #[prost(double, tag = "1")]
            pub duration: f64,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Loop {
            #[prost(bool, tag = "1")]
            pub r#loop: bool,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MonitorSource {
            #[prost(bool, tag = "1")]
            pub enable: bool,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ActionType {
            #[prost(message, tag = "1")]
            Play(Play),
            #[prost(message, tag = "2")]
            Record(Record),
            #[prost(message, tag = "3")]
            Pause(Pause),
            #[prost(message, tag = "4")]
            Reset(Reset),
            #[prost(message, tag = "5")]
            JumpToTime(JumpToTime),
            #[prost(message, tag = "6")]
            StartScrub(StartScrub),
            #[prost(message, tag = "7")]
            EndScrub(EndScrub),
            #[prost(message, tag = "8")]
            Duration(Duration),
            #[prost(message, tag = "9")]
            Loop(Loop),
            #[prost(message, tag = "10")]
            UpdateSequence(super::Sequence),
            #[prost(message, tag = "11")]
            MonitorSource(MonitorSource),
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkIdentifier {
    #[prost(message, repeated, tag = "1")]
    pub identifiers: ::prost::alloc::vec::Vec<network_identifier::IndexOrName>,
}
/// Nested message and enum types in `NetworkIdentifier`.
pub mod network_identifier {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IndexOrName {
        #[prost(oneof = "index_or_name::Component", tags = "1, 2")]
        pub component: ::core::option::Option<index_or_name::Component>,
    }
    /// Nested message and enum types in `IndexOrName`.
    pub mod index_or_name {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Component {
            #[prost(int32, tag = "1")]
            Index(i32),
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerOptions {
    #[prost(enumeration = "action::ContentDestination", tag = "1")]
    pub content_destination: i32,
    #[prost(bool, tag = "2")]
    pub suppress_auto_start_video: bool,
    #[prost(bool, tag = "3")]
    pub suppress_media_background: bool,
    #[prost(bool, tag = "4")]
    pub force_retrigger: bool,
    #[prost(bool, tag = "5")]
    pub reset_chord_chart: bool,
    #[prost(bool, tag = "6")]
    pub from_playlist_library: bool,
    #[prost(bool, tag = "7")]
    pub from_timeline: bool,
    #[prost(bool, tag = "8")]
    pub ignore_analytics: bool,
    #[prost(double, tag = "9")]
    pub start_position: f64,
    #[prost(message, optional, tag = "10")]
    pub trigger_source: ::core::option::Option<TriggerSource>,
    #[prost(message, optional, tag = "11")]
    pub network_identifier: ::core::option::Option<NetworkIdentifier>,
    #[prost(bool, tag = "12")]
    pub request_client_context: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlTransport {
    #[prost(
        oneof = "control_transport::ControlType",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28"
    )]
    pub control_type: ::core::option::Option<control_transport::ControlType>,
}
/// Nested message and enum types in `ControlTransport`.
pub mod control_transport {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlayControlType {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PauseControlType {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RewindControlType {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FastForwardControlType {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SkipBackControlType {
        #[prost(double, tag = "1")]
        pub offset: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SkipForwardControlType {
        #[prost(double, tag = "1")]
        pub offset: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StepBackControlType {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StepForwardControlType {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GoToStartControlType {
        #[prost(double, tag = "1")]
        pub offset: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GoToEndControlType {
        #[prost(double, tag = "1")]
        pub offset: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JumpToTimeControlType {
        #[prost(double, tag = "1")]
        pub time: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JumpToPercentControlType {
        #[prost(double, tag = "1")]
        pub percent: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MarkInPointControlType {
        #[prost(double, tag = "1")]
        pub time: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MarkOutPointControlType {
        #[prost(double, tag = "1")]
        pub time: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetScaleModeControlType {
        #[prost(enumeration = "super::media::ScaleBehavior", tag = "1")]
        pub mode: i32,
        #[prost(bool, tag = "3")]
        pub is_blurred: bool,
        #[prost(enumeration = "super::media::ScaleAlignment", tag = "2")]
        pub alignment: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetFlippedModeControlType {
        #[prost(bool, tag = "1")]
        pub horizontal: bool,
        #[prost(bool, tag = "2")]
        pub vertical: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetPlayRateControlType {
        #[prost(double, tag = "1")]
        pub play_rate: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetNativeRotationControlType {
        #[prost(
            enumeration = "super::media::drawing_properties::NativeRotationType",
            tag = "1"
        )]
        pub rotation: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetAlphaTypeControlType {
        #[prost(enumeration = "super::AlphaType", tag = "1")]
        pub alpha_type: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TogglePlaybackControlType {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetEffectsControlType {
        #[prost(message, repeated, tag = "1")]
        pub effects: ::prost::alloc::vec::Vec<super::Effect>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateEffectControlType {
        #[prost(message, optional, tag = "1")]
        pub effect: ::core::option::Option<super::Effect>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BeginScrubControlType {
        #[prost(double, tag = "1")]
        pub time: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EndScrubControlType {
        #[prost(double, tag = "1")]
        pub time: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ScrubToTimeControlType {
        #[prost(double, tag = "1")]
        pub time: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ScrubToPercentControlType {
        #[prost(double, tag = "1")]
        pub percent: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetAudioFadeType {
        #[prost(double, tag = "1")]
        pub fade_in_duration: f64,
        #[prost(double, tag = "2")]
        pub fade_out_duration: f64,
        #[prost(bool, tag = "3")]
        pub should_fade_in: bool,
        #[prost(bool, tag = "4")]
        pub should_fade_out: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetAudioPropertiesType {
        #[prost(message, optional, tag = "1")]
        pub audio_properties: ::core::option::Option<super::media::AudioProperties>,
        #[prost(bool, repeated, tag = "2")]
        pub solo: ::prost::alloc::vec::Vec<bool>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ControlType {
        #[prost(message, tag = "1")]
        Play(PlayControlType),
        #[prost(message, tag = "2")]
        Pause(PauseControlType),
        #[prost(message, tag = "3")]
        Rewind(RewindControlType),
        #[prost(message, tag = "4")]
        Fastforward(FastForwardControlType),
        #[prost(message, tag = "5")]
        SkipBack(SkipBackControlType),
        #[prost(message, tag = "6")]
        SkipForward(SkipForwardControlType),
        #[prost(message, tag = "7")]
        StepBack(StepBackControlType),
        #[prost(message, tag = "8")]
        StepForward(StepForwardControlType),
        #[prost(message, tag = "9")]
        GoToStart(GoToStartControlType),
        #[prost(message, tag = "10")]
        GoToEnd(GoToEndControlType),
        #[prost(message, tag = "11")]
        JumpToTime(JumpToTimeControlType),
        #[prost(message, tag = "12")]
        JumpToPercent(JumpToPercentControlType),
        #[prost(message, tag = "13")]
        MarkIn(MarkInPointControlType),
        #[prost(message, tag = "14")]
        MarkOut(MarkOutPointControlType),
        #[prost(message, tag = "15")]
        SetScaleMode(SetScaleModeControlType),
        #[prost(message, tag = "16")]
        SetFlippedMode(SetFlippedModeControlType),
        #[prost(message, tag = "17")]
        SetPlayRate(SetPlayRateControlType),
        #[prost(message, tag = "18")]
        SetRotation(SetNativeRotationControlType),
        #[prost(message, tag = "19")]
        TogglePlayback(TogglePlaybackControlType),
        #[prost(message, tag = "20")]
        SetEffects(SetEffectsControlType),
        #[prost(message, tag = "21")]
        UpdateEffect(UpdateEffectControlType),
        #[prost(message, tag = "22")]
        BeginScrub(BeginScrubControlType),
        #[prost(message, tag = "23")]
        EndScrub(EndScrubControlType),
        #[prost(message, tag = "24")]
        ScrubToTime(ScrubToTimeControlType),
        #[prost(message, tag = "25")]
        ScrubToPercent(ScrubToPercentControlType),
        #[prost(message, tag = "26")]
        SetAudioFade(SetAudioFadeType),
        #[prost(message, tag = "27")]
        SetAudioProperties(SetAudioPropertiesType),
        #[prost(message, tag = "28")]
        SetAlphaType(SetAlphaTypeControlType),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioInputSettings {
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<AudioInput>,
    #[prost(double, tag = "2")]
    pub transition_time: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoInputSettings {
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<VideoInput>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordRequest {
    #[prost(message, optional, tag = "1")]
    pub stream: ::core::option::Option<recording::Stream>,
    #[prost(message, optional, tag = "2")]
    pub working_directory: ::core::option::Option<Url>,
    #[prost(message, optional, tag = "3")]
    pub resi: ::core::option::Option<record_request::Resi>,
}
/// Nested message and enum types in `RecordRequest`.
pub mod record_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Resi {
        #[prost(uint32, tag = "1")]
        pub gop: u32,
        #[prost(double, tag = "2")]
        pub segment_size: f64,
        #[prost(string, tag = "3")]
        pub destination_group_id: ::prost::alloc::string::String,
        #[prost(uint32, tag = "4")]
        pub buf_size: u32,
        #[prost(uint32, tag = "5")]
        pub min_rate: u32,
        #[prost(uint32, tag = "6")]
        pub max_rate: u32,
        #[prost(string, tag = "7")]
        pub event_name: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub social_description: ::prost::alloc::string::String,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextSegmentRequest {
    #[prost(message, repeated, tag = "1")]
    pub segments: ::prost::alloc::vec::Vec<text_segment_request::Segment>,
    #[prost(double, tag = "2")]
    pub start_position: f64,
}
/// Nested message and enum types in `TextSegmentRequest`.
pub mod text_segment_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Segment {
        #[prost(uint32, tag = "1")]
        pub index: u32,
        #[prost(double, tag = "2")]
        pub size: f64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerCue {
    #[prost(uint64, tag = "1")]
    pub trigger_handle: u64,
    #[prost(message, optional, tag = "2")]
    pub trigger_options: ::core::option::Option<TriggerOptions>,
    #[prost(message, optional, tag = "3")]
    pub cue: ::core::option::Option<Cue>,
    #[prost(message, optional, tag = "4")]
    pub presentation: ::core::option::Option<trigger_cue::PresentationCue>,
    #[prost(message, optional, tag = "5")]
    pub playlist: ::core::option::Option<Playlist>,
    #[prost(uint64, tag = "6")]
    pub client_data: u64,
}
/// Nested message and enum types in `TriggerCue`.
pub mod trigger_cue {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PresentationCue {
        #[prost(message, optional, tag = "1")]
        pub presentation: ::core::option::Option<super::Presentation>,
        #[prost(message, optional, tag = "2")]
        pub arrangement_id: ::core::option::Option<super::Uuid>,
        #[prost(int32, tag = "3")]
        pub cue_index: i32,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkTriggerDataItem {
    #[prost(message, optional, tag = "3")]
    pub trigger_options: ::core::option::Option<TriggerOptions>,
    #[prost(message, optional, tag = "4")]
    pub trigger_cue: ::core::option::Option<TriggerCue>,
    #[prost(oneof = "network_trigger_data_item::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<network_trigger_data_item::Type>,
}
/// Nested message and enum types in `NetworkTriggerDataItem`.
pub mod network_trigger_data_item {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        Action(super::Action),
        #[prost(message, tag = "2")]
        Cue(super::Cue),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlideElementTextRenderInfo {
    #[prost(message, repeated, tag = "1")]
    pub layers: ::prost::alloc::vec::Vec<slide_element_text_render_info::Layer>,
}
/// Nested message and enum types in `SlideElementTextRenderInfo`.
pub mod slide_element_text_render_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Layer {
        #[prost(enumeration = "LayerType", tag = "1")]
        pub layer_type: i32,
        #[prost(int32, tag = "5")]
        pub text_build_index: i32,
        #[prost(oneof = "layer::AdvancedFill", tags = "2, 3, 4")]
        pub advanced_fill: ::core::option::Option<layer::AdvancedFill>,
    }
    /// Nested message and enum types in `Layer`.
    pub mod layer {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum AdvancedFill {
            #[prost(message, tag = "2")]
            CutOutFill(super::super::graphics::text::CutOutFill),
            #[prost(message, tag = "3")]
            MediaFill(super::super::graphics::text::MediaFill),
            #[prost(message, tag = "4")]
            BackgroundEffect(super::super::graphics::BackgroundEffect),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LayerType {
        Composite = 0,
        Mask = 1,
        Over = 2,
        Under = 3,
    }
    impl LayerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LayerType::Composite => "LAYER_TYPE_COMPOSITE",
                LayerType::Mask => "LAYER_TYPE_MASK",
                LayerType::Over => "LAYER_TYPE_OVER",
                LayerType::Under => "LAYER_TYPE_UNDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LAYER_TYPE_COMPOSITE" => Some(Self::Composite),
                "LAYER_TYPE_MASK" => Some(Self::Mask),
                "LAYER_TYPE_OVER" => Some(Self::Over),
                "LAYER_TYPE_UNDER" => Some(Self::Under),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateEncoderRequest {
    #[prost(message, optional, tag = "1")]
    pub encoder: ::core::option::Option<recording::stream::Encoder>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateEncoderResponse {
    #[prost(bool, tag = "1")]
    pub is_valid: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CaptureActionRequest {
    #[prost(oneof = "capture_action_request::RequestType", tags = "1, 2, 3")]
    pub request_type: ::core::option::Option<capture_action_request::RequestType>,
}
/// Nested message and enum types in `CaptureActionRequest`.
pub mod capture_action_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartResi {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopCapture {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Error {
        #[prost(int32, tag = "1")]
        pub error_code: i32,
        #[prost(message, optional, tag = "2")]
        pub capture_action: ::core::option::Option<super::action::CaptureType>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestType {
        #[prost(message, tag = "1")]
        StartResi(StartResi),
        #[prost(message, tag = "2")]
        StopCapture(StopCapture),
        #[prost(message, tag = "3")]
        Error(Error),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CaptureActionResponse {
    #[prost(oneof = "capture_action_response::ResponseType", tags = "1, 2, 3")]
    pub response_type: ::core::option::Option<capture_action_response::ResponseType>,
}
/// Nested message and enum types in `CaptureActionResponse`.
pub mod capture_action_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CancelCaptureAction {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StartResi {
        #[prost(string, tag = "1")]
        pub event_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub event_description: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StopCapture {
        #[prost(bool, tag = "1")]
        pub stop_capture: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResponseType {
        #[prost(message, tag = "1")]
        StartResi(StartResi),
        #[prost(message, tag = "2")]
        StopCapture(StopCapture),
        #[prost(message, tag = "3")]
        CancelCaptureAction(CancelCaptureAction),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MacroIcons {
    #[prost(message, repeated, tag = "1")]
    pub icons: ::prost::alloc::vec::Vec<macro_icons::MacroIcon>,
}
/// Nested message and enum types in `MacroIcons`.
pub mod macro_icons {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MacroIcon {
        #[prost(enumeration = "super::macros_document::r#macro::ImageType", tag = "1")]
        pub image_type: i32,
        #[prost(bytes = "vec", tag = "2")]
        pub image_data: ::prost::alloc::vec::Vec<u8>,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropPauseRequest {
    #[prost(message, optional, tag = "1")]
    pub prop_id: ::core::option::Option<Uuid>,
    #[prost(oneof = "prop_pause_request::RequestType", tags = "2, 3, 4")]
    pub request_type: ::core::option::Option<prop_pause_request::RequestType>,
}
/// Nested message and enum types in `PropPauseRequest`.
pub mod prop_pause_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Pause {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Resume {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Status {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestType {
        #[prost(message, tag = "2")]
        Pause(Pause),
        #[prost(message, tag = "3")]
        Resume(Resume),
        #[prost(message, tag = "4")]
        Status(Status),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericEvent {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaThumbnail {
    #[prost(int32, tag = "1")]
    pub width: i32,
    #[prost(int32, tag = "2")]
    pub height: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub stride: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcoData {
    #[prost(string, tag = "2")]
    pub service_type_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub plan_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebFillTokenAndCookies {
    #[prost(message, repeated, tag = "1")]
    pub cookies: ::prost::alloc::vec::Vec<web_fill_token_and_cookies::Cookie>,
    #[prost(string, tag = "2")]
    pub token: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WebFillTokenAndCookies`.
pub mod web_fill_token_and_cookies {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Cookie {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub domain: ::prost::alloc::string::String,
        #[prost(uint64, tag = "4")]
        pub expiry: u64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendData {
    #[prost(int32, tag = "1")]
    pub message_id: i32,
    #[prost(
        oneof = "send_data::MessageType",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39"
    )]
    pub message_type: ::core::option::Option<send_data::MessageType>,
}
/// Nested message and enum types in `SendData`.
pub mod send_data {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MessageType {
        #[prost(message, tag = "2")]
        Workspace(super::ProPresenterWorkspace),
        #[prost(message, tag = "3")]
        StageDocument(super::stage::Document),
        #[prost(message, tag = "4")]
        TimersDocument(super::TimersDocument),
        #[prost(message, tag = "5")]
        ValidateEncoderRequest(super::ValidateEncoderRequest),
        #[prost(message, tag = "6")]
        TriggerCue(super::TriggerCue),
        #[prost(message, tag = "7")]
        DigitalAudioSetup(super::digital_audio::Setup),
        #[prost(message, tag = "8")]
        MacrosDocument(super::MacrosDocument),
        #[prost(message, tag = "9")]
        MessageDocument(super::MessageDocument),
        #[prost(message, tag = "10")]
        PropDocument(super::PropDocument),
        #[prost(message, tag = "11")]
        CcliDocument(super::CcliDocument),
        #[prost(message, tag = "12")]
        AudienceLooks(super::AudienceLookCollection),
        #[prost(message, tag = "13")]
        LiveAudienceLook(super::ProAudienceLook),
        #[prost(message, tag = "14")]
        Masks(super::MaskCollection),
        #[prost(message, tag = "15")]
        RecordingSettingsDocument(super::recording::SettingsDocument),
        #[prost(message, tag = "16")]
        CaptureActionResponse(super::CaptureActionResponse),
        #[prost(message, tag = "17")]
        CopyrightLayout(super::CopyrightLayout),
        #[prost(message, tag = "18")]
        GlobalBackgroundTransition(super::Transition),
        #[prost(message, tag = "19")]
        GlobalMessagesTransition(super::Transition),
        #[prost(message, tag = "20")]
        GlobalForegroundTransition(super::Transition),
        #[prost(message, tag = "21")]
        GlobalPropsTransition(super::Transition),
        #[prost(message, tag = "22")]
        GlobalAudioTransition(super::Transition),
        #[prost(message, tag = "23")]
        Preferences(super::Preferences),
        #[prost(message, tag = "24")]
        TestPattern(super::TestPatternRequest),
        #[prost(message, tag = "25")]
        StartupComplete(super::GenericEvent),
        #[prost(message, tag = "26")]
        VisualPlaylistDoc(super::PlaylistDocument),
        #[prost(message, tag = "27")]
        AudioPlaylistDoc(super::PlaylistDocument),
        #[prost(message, tag = "28")]
        KillWatchdog(super::GenericEvent),
        #[prost(message, tag = "29")]
        MacroIcons(super::MacroIcons),
        #[prost(message, tag = "30")]
        DebugTriggerDataDump(super::GenericEvent),
        #[prost(message, tag = "31")]
        LibraryPlaylistDoc(super::PlaylistDocument),
        #[prost(message, tag = "32")]
        AudioPlaylistFocusUuid(super::Uuid),
        #[prost(message, tag = "33")]
        MediaPlaylistFocusUuid(super::Uuid),
        #[prost(message, tag = "34")]
        LibraryPlaylistFocusUuid(super::Uuid),
        #[prost(message, tag = "35")]
        LibraryPlaylistItemFocusUuid(super::Uuid),
        #[prost(message, tag = "36")]
        PropPause(super::PropPauseRequest),
        #[prost(message, tag = "37")]
        MediaThumbnail(super::MediaThumbnail),
        #[prost(message, tag = "38")]
        PcoData(super::PcoData),
        #[prost(message, tag = "39")]
        WebfillTokenAndCookies(super::WebFillTokenAndCookies),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerRuntimeState {
    #[prost(message, optional, tag = "1")]
    pub timer_uuid: ::core::option::Option<Uuid>,
    #[prost(string, tag = "2")]
    pub timer_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub action_type: ::core::option::Option<action::TimerType>,
    #[prost(bool, tag = "4")]
    pub is_running: bool,
    #[prost(bool, tag = "5")]
    pub has_overrun: bool,
    #[prost(enumeration = "timer_runtime_state::ResourceState", tag = "6")]
    pub state: i32,
    #[prost(double, tag = "7")]
    pub current_time: f64,
    #[prost(bool, tag = "8")]
    pub has_started: bool,
}
/// Nested message and enum types in `TimerRuntimeState`.
pub mod timer_runtime_state {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceState {
        Prerolling = 0,
        Activated = 1,
        Updated = 2,
        Deactivated = 3,
        Released = 4,
    }
    impl ResourceState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ResourceState::Prerolling => "PREROLLING",
                ResourceState::Activated => "ACTIVATED",
                ResourceState::Updated => "UPDATED",
                ResourceState::Deactivated => "DEACTIVATED",
                ResourceState::Released => "RELEASED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PREROLLING" => Some(Self::Prerolling),
                "ACTIVATED" => Some(Self::Activated),
                "UPDATED" => Some(Self::Updated),
                "DEACTIVATED" => Some(Self::Deactivated),
                "RELEASED" => Some(Self::Released),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerStateUpdate {
    #[prost(message, optional, tag = "1")]
    pub timer: ::core::option::Option<Timer>,
    #[prost(message, optional, tag = "2")]
    pub state: ::core::option::Option<TimerRuntimeState>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HandledException {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoreDataStateDump {
    #[prost(message, optional, tag = "1")]
    pub macros: ::core::option::Option<MacrosDocument>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropPauseResponse {
    #[prost(message, optional, tag = "1")]
    pub prop_id: ::core::option::Option<Uuid>,
    #[prost(oneof = "prop_pause_response::ResponseType", tags = "2")]
    pub response_type: ::core::option::Option<prop_pause_response::ResponseType>,
}
/// Nested message and enum types in `PropPauseResponse`.
pub mod prop_pause_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Status {
        #[prost(bool, tag = "1")]
        pub paused: bool,
        #[prost(double, tag = "2")]
        pub time_remaining: f64,
        #[prost(double, tag = "3")]
        pub percentage_complete: f64,
        #[prost(double, tag = "4")]
        pub total_time: f64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResponseType {
        #[prost(message, tag = "2")]
        Status(Status),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowMessage {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMediaThumbnail {
    #[prost(int32, tag = "3")]
    pub width_hint: i32,
    #[prost(int32, tag = "4")]
    pub height_hint: i32,
    #[prost(oneof = "get_media_thumbnail::MediaType", tags = "1, 2")]
    pub media_type: ::core::option::Option<get_media_thumbnail::MediaType>,
}
/// Nested message and enum types in `GetMediaThumbnail`.
pub mod get_media_thumbnail {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MediaType {
        #[prost(message, tag = "1")]
        Media(super::Media),
        #[prost(message, tag = "2")]
        Action(super::Action),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestWebFillTokenAndCookies {
    #[prost(bool, tag = "1")]
    pub refresh_first: bool,
    #[prost(string, tag = "2")]
    pub link: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaAssetTriggered {
    #[prost(message, optional, tag = "1")]
    pub media_uuid: ::core::option::Option<Uuid>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendDataResponse {
    #[prost(int32, tag = "1")]
    pub message_id: i32,
    #[prost(
        oneof = "send_data_response::MessageType",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17"
    )]
    pub message_type: ::core::option::Option<send_data_response::MessageType>,
}
/// Nested message and enum types in `SendDataResponse`.
pub mod send_data_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MessageType {
        #[prost(message, tag = "2")]
        ValidateEncoderResponse(super::ValidateEncoderResponse),
        #[prost(message, tag = "3")]
        TimerState(super::TimerStateUpdate),
        #[prost(message, tag = "4")]
        CaptureActionRequest(super::CaptureActionRequest),
        #[prost(message, tag = "5")]
        TestPattern(super::TestPatternResponse),
        #[prost(message, tag = "6")]
        HandledException(super::HandledException),
        #[prost(message, tag = "7")]
        TestStateDump(super::CoreDataStateDump),
        #[prost(message, tag = "8")]
        AudioPlaylistFocusUuid(super::Uuid),
        #[prost(message, tag = "9")]
        MediaPlaylistFocusUuid(super::Uuid),
        #[prost(message, tag = "10")]
        LibraryPlaylistFocusUuid(super::Uuid),
        #[prost(message, tag = "11")]
        LibraryPlaylistItemFocusUuid(super::Uuid),
        #[prost(message, tag = "12")]
        PropPause(super::PropPauseResponse),
        #[prost(message, tag = "13")]
        ShowMessage(super::ShowMessage),
        #[prost(message, tag = "14")]
        HideMessage(super::GenericEvent),
        #[prost(message, tag = "15")]
        GetMediaThumbnail(super::GetMediaThumbnail),
        #[prost(message, tag = "16")]
        RequestWebfillTokenAndCookies(super::RequestWebFillTokenAndCookies),
        #[prost(message, tag = "17")]
        MediaAssetTriggered(super::MediaAssetTriggered),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerTransferRenderState {
    #[prost(message, optional, tag = "1")]
    pub slide: ::core::option::Option<Slide>,
    #[prost(string, tag = "2")]
    pub stage_message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub presentation_media: ::core::option::Option<
        trigger_transfer_render_state::MediaState,
    >,
    #[prost(message, optional, tag = "4")]
    pub announcement_media: ::core::option::Option<
        trigger_transfer_render_state::MediaState,
    >,
    #[prost(message, optional, tag = "5")]
    pub audio_media: ::core::option::Option<trigger_transfer_render_state::MediaState>,
    #[prost(message, optional, tag = "6")]
    pub live_video_media: ::core::option::Option<Media>,
    #[prost(message, optional, tag = "7")]
    pub presentation: ::core::option::Option<trigger_transfer_render_state::SlideState>,
    #[prost(message, optional, tag = "8")]
    pub announcement: ::core::option::Option<trigger_transfer_render_state::SlideState>,
    #[prost(message, repeated, tag = "9")]
    pub timers: ::prost::alloc::vec::Vec<trigger_transfer_render_state::TimerState>,
    #[prost(message, optional, tag = "10")]
    pub capture: ::core::option::Option<trigger_transfer_render_state::CaptureState>,
    #[prost(message, optional, tag = "11")]
    pub timecode: ::core::option::Option<trigger_transfer_render_state::TimecodeState>,
    #[prost(uint64, tag = "12")]
    pub system_time: u64,
}
/// Nested message and enum types in `TriggerTransferRenderState`.
pub mod trigger_transfer_render_state {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimerState {
        #[prost(message, optional, tag = "1")]
        pub timer: ::core::option::Option<super::Timer>,
        #[prost(bool, tag = "2")]
        pub is_running: bool,
        #[prost(bool, tag = "3")]
        pub has_overrun: bool,
        #[prost(float, tag = "4")]
        pub value: f32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MediaState {
        #[prost(message, optional, tag = "1")]
        pub current_media: ::core::option::Option<super::Media>,
        #[prost(bool, tag = "2")]
        pub is_playing: bool,
        #[prost(bool, tag = "3")]
        pub is_looping: bool,
        #[prost(float, tag = "4")]
        pub current_time: f32,
        #[prost(float, tag = "5")]
        pub time_remaining: f32,
        #[prost(message, optional, tag = "6")]
        pub playlist_uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "7")]
        pub playlist_name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "8")]
        pub markers: ::prost::alloc::vec::Vec<super::action::media_type::PlaybackMarker>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CaptureState {
        #[prost(enumeration = "capture_state::Status", tag = "1")]
        pub status: i32,
        #[prost(float, tag = "2")]
        pub time: f32,
    }
    /// Nested message and enum types in `CaptureState`.
    pub mod capture_state {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Status {
            Stopped = 0,
            Active = 1,
            Caution = 2,
            Error = 3,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Status::Stopped => "Stopped",
                    Status::Active => "Active",
                    Status::Caution => "Caution",
                    Status::Error => "Error",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Stopped" => Some(Self::Stopped),
                    "Active" => Some(Self::Active),
                    "Caution" => Some(Self::Caution),
                    "Error" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AutoAdvanceState {
        #[prost(bool, tag = "1")]
        pub active: bool,
        #[prost(float, tag = "2")]
        pub remaining_time: f32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimelineState {
        #[prost(bool, tag = "1")]
        pub active: bool,
        #[prost(float, tag = "2")]
        pub current_time: f32,
        #[prost(int32, tag = "3")]
        pub last_slide_index: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SlideState {
        #[prost(message, optional, tag = "1")]
        pub presentation: ::core::option::Option<super::Presentation>,
        #[prost(message, optional, tag = "2")]
        pub playlist: ::core::option::Option<super::Playlist>,
        #[prost(message, optional, tag = "3")]
        pub current_cue: ::core::option::Option<super::Uuid>,
        #[prost(message, optional, tag = "4")]
        pub next_cue: ::core::option::Option<super::Uuid>,
        #[prost(message, optional, tag = "5")]
        pub auto_advance: ::core::option::Option<AutoAdvanceState>,
        #[prost(message, optional, tag = "6")]
        pub timeline_state: ::core::option::Option<TimelineState>,
        #[prost(int32, tag = "7")]
        pub current_cue_index: i32,
        #[prost(int32, tag = "8")]
        pub current_playlist_index: i32,
        #[prost(bool, tag = "9")]
        pub is_current_position: bool,
        #[prost(bool, tag = "10")]
        pub from_timeline: bool,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimecodeState {
        #[prost(enumeration = "timecode_state::Status", tag = "1")]
        pub status: i32,
        #[prost(float, tag = "2")]
        pub time: f32,
        #[prost(float, tag = "3")]
        pub fps: f32,
    }
    /// Nested message and enum types in `TimecodeState`.
    pub mod timecode_state {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Status {
            Stopped = 0,
            Playing = 1,
            Error = 2,
            Discontinuity = 3,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Status::Stopped => "Stopped",
                    Status::Playing => "Playing",
                    Status::Error => "Error",
                    Status::Discontinuity => "Discontinuity",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Stopped" => Some(Self::Stopped),
                    "Playing" => Some(Self::Playing),
                    "Error" => Some(Self::Error),
                    "Discontinuity" => Some(Self::Discontinuity),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentificationOverlay {
    #[prost(string, tag = "3")]
    pub screen_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "1")]
    pub outputs: ::prost::alloc::vec::Vec<identification_overlay::Output>,
}
/// Nested message and enum types in `IdentificationOverlay`.
pub mod identification_overlay {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Output {
        #[prost(int32, tag = "1")]
        pub x: i32,
        #[prost(int32, tag = "2")]
        pub y: i32,
        #[prost(int32, tag = "3")]
        pub width: i32,
        #[prost(int32, tag = "4")]
        pub height: i32,
        #[prost(string, tag = "5")]
        pub name: ::prost::alloc::string::String,
        #[prost(double, tag = "6")]
        pub frame_rate: f64,
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LayerIdentificationOverlay {
    #[prost(enumeration = "layer_identification_overlay::Layer", tag = "1")]
    pub layer: i32,
    #[prost(string, tag = "2")]
    pub layer_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LayerIdentificationOverlay`.
pub mod layer_identification_overlay {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Layer {
        VideoInput = 0,
        Media = 1,
        Presentation = 2,
        Announcements = 3,
        Props = 4,
        Messages = 5,
    }
    impl Layer {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Layer::VideoInput => "LAYER_VIDEO_INPUT",
                Layer::Media => "LAYER_MEDIA",
                Layer::Presentation => "LAYER_PRESENTATION",
                Layer::Announcements => "LAYER_ANNOUNCEMENTS",
                Layer::Props => "LAYER_PROPS",
                Layer::Messages => "LAYER_MESSAGES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LAYER_VIDEO_INPUT" => Some(Self::VideoInput),
                "LAYER_MEDIA" => Some(Self::Media),
                "LAYER_PRESENTATION" => Some(Self::Presentation),
                "LAYER_ANNOUNCEMENTS" => Some(Self::Announcements),
                "LAYER_PROPS" => Some(Self::Props),
                "LAYER_MESSAGES" => Some(Self::Messages),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenderLayer {
    #[prost(message, optional, tag = "8")]
    pub bounds: ::core::option::Option<graphics::Rect>,
    #[prost(enumeration = "graphics::element::FlipMode", tag = "9")]
    pub flip_mode: i32,
    #[prost(double, tag = "10")]
    pub rotation: f64,
    #[prost(int32, tag = "11")]
    pub build_index: i32,
    #[prost(bool, tag = "12")]
    pub build_out: bool,
    #[prost(oneof = "render_layer::LayerType", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub layer_type: ::core::option::Option<render_layer::LayerType>,
}
/// Nested message and enum types in `RenderLayer`.
pub mod render_layer {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Composite {}
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Scrolling {
        #[prost(int32, tag = "1")]
        pub segment_size: i32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum LayerType {
        #[prost(message, tag = "1")]
        Composite(Composite),
        #[prost(message, tag = "2")]
        Media(super::Media),
        #[prost(message, tag = "3")]
        CutOut(super::graphics::text::CutOutFill),
        #[prost(message, tag = "4")]
        BackgroundEffect(super::graphics::BackgroundEffect),
        #[prost(message, tag = "5")]
        OutputScreen(super::slide::element::data_link::OutputScreen),
        #[prost(message, tag = "6")]
        Scrolling(Scrolling),
        #[prost(message, tag = "7")]
        SlideImage(super::slide::element::data_link::SlideImage),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlideElement {
    #[prost(message, optional, tag = "1")]
    pub element: ::core::option::Option<slide::Element>,
    #[prost(int32, tag = "2")]
    pub build_index: i32,
    #[prost(message, optional, tag = "3")]
    pub base_key: ::core::option::Option<MusicKeyScale>,
    #[prost(message, optional, tag = "4")]
    pub target_key: ::core::option::Option<MusicKeyScale>,
    #[prost(message, repeated, tag = "5")]
    pub cookies: ::prost::alloc::vec::Vec<web_fill_token_and_cookies::Cookie>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlidePreview {
    #[prost(message, optional, tag = "1")]
    pub cue: ::core::option::Option<Cue>,
    #[prost(message, optional, tag = "2")]
    pub element: ::core::option::Option<slide::Element>,
    #[prost(message, optional, tag = "3")]
    pub background: ::core::option::Option<Color>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaPreview {
    #[prost(message, optional, tag = "1")]
    pub action: ::core::option::Option<Action>,
    #[prost(message, optional, tag = "2")]
    pub media: ::core::option::Option<Media>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearGroupsDocument {
    #[prost(message, optional, tag = "1")]
    pub application_info: ::core::option::Option<ApplicationInfo>,
    #[prost(message, repeated, tag = "2")]
    pub groups: ::prost::alloc::vec::Vec<clear_groups_document::ClearGroup>,
}
/// Nested message and enum types in `ClearGroupsDocument`.
pub mod clear_groups_document {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClearGroup {
        #[prost(message, optional, tag = "1")]
        pub uuid: ::core::option::Option<super::Uuid>,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub layer_targets: ::prost::alloc::vec::Vec<super::action::ClearType>,
        #[prost(bool, tag = "4")]
        pub is_hidden_in_preview: bool,
        #[prost(bytes = "vec", tag = "5")]
        pub image_data: ::prost::alloc::vec::Vec<u8>,
        #[prost(enumeration = "clear_group::ImageType", tag = "6")]
        pub image_type: i32,
        #[prost(bool, tag = "7")]
        pub is_icon_tinted: bool,
        #[prost(message, optional, tag = "8")]
        pub icon_tint_color: ::core::option::Option<super::Color>,
        #[prost(enumeration = "super::action::ContentDestination", repeated, tag = "9")]
        pub timeline_targets: ::prost::alloc::vec::Vec<i32>,
        #[prost(bool, tag = "10")]
        pub clear_presentation_next_slide: bool,
    }
    /// Nested message and enum types in `ClearGroup`.
    pub mod clear_group {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ImageType {
            Custom = 0,
            One = 1,
            Two = 2,
            Three = 3,
            Four = 4,
            Five = 5,
            Six = 6,
            Seven = 7,
            Eight = 8,
            Nine = 9,
            Zero = 10,
            All = 11,
            Megahorn = 12,
            Play = 13,
            Bulb = 14,
            Sunglasses = 15,
            Arrow = 16,
            Target = 17,
            Star = 18,
            Sun = 19,
            Bell = 20,
            Paperclip = 21,
            Flask = 22,
            Eyeglasses = 23,
            Cupcake = 24,
            Slide = 25,
            Hat = 26,
            Flower = 27,
            Heart = 28,
            Message = 29,
            Audio = 30,
            Cloud = 31,
            Exclamation = 32,
        }
        impl ImageType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ImageType::Custom => "ImageTypeCustom",
                    ImageType::One => "ImageTypeOne",
                    ImageType::Two => "ImageTypeTwo",
                    ImageType::Three => "ImageTypeThree",
                    ImageType::Four => "ImageTypeFour",
                    ImageType::Five => "ImageTypeFive",
                    ImageType::Six => "ImageTypeSix",
                    ImageType::Seven => "ImageTypeSeven",
                    ImageType::Eight => "ImageTypeEight",
                    ImageType::Nine => "ImageTypeNine",
                    ImageType::Zero => "ImageTypeZero",
                    ImageType::All => "ImageTypeAll",
                    ImageType::Megahorn => "ImageTypeMegahorn",
                    ImageType::Play => "ImageTypePlay",
                    ImageType::Bulb => "ImageTypeBulb",
                    ImageType::Sunglasses => "ImageTypeSunglasses",
                    ImageType::Arrow => "ImageTypeArrow",
                    ImageType::Target => "ImageTypeTarget",
                    ImageType::Star => "ImageTypeStar",
                    ImageType::Sun => "ImageTypeSun",
                    ImageType::Bell => "ImageTypeBell",
                    ImageType::Paperclip => "ImageTypePaperclip",
                    ImageType::Flask => "ImageTypeFlask",
                    ImageType::Eyeglasses => "ImageTypeEyeglasses",
                    ImageType::Cupcake => "ImageTypeCupcake",
                    ImageType::Slide => "ImageTypeSlide",
                    ImageType::Hat => "ImageTypeHat",
                    ImageType::Flower => "ImageTypeFlower",
                    ImageType::Heart => "ImageTypeHeart",
                    ImageType::Message => "ImageTypeMessage",
                    ImageType::Audio => "ImageTypeAudio",
                    ImageType::Cloud => "ImageTypeCloud",
                    ImageType::Exclamation => "ImageTypeExclamation",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ImageTypeCustom" => Some(Self::Custom),
                    "ImageTypeOne" => Some(Self::One),
                    "ImageTypeTwo" => Some(Self::Two),
                    "ImageTypeThree" => Some(Self::Three),
                    "ImageTypeFour" => Some(Self::Four),
                    "ImageTypeFive" => Some(Self::Five),
                    "ImageTypeSix" => Some(Self::Six),
                    "ImageTypeSeven" => Some(Self::Seven),
                    "ImageTypeEight" => Some(Self::Eight),
                    "ImageTypeNine" => Some(Self::Nine),
                    "ImageTypeZero" => Some(Self::Zero),
                    "ImageTypeAll" => Some(Self::All),
                    "ImageTypeMegahorn" => Some(Self::Megahorn),
                    "ImageTypePlay" => Some(Self::Play),
                    "ImageTypeBulb" => Some(Self::Bulb),
                    "ImageTypeSunglasses" => Some(Self::Sunglasses),
                    "ImageTypeArrow" => Some(Self::Arrow),
                    "ImageTypeTarget" => Some(Self::Target),
                    "ImageTypeStar" => Some(Self::Star),
                    "ImageTypeSun" => Some(Self::Sun),
                    "ImageTypeBell" => Some(Self::Bell),
                    "ImageTypePaperclip" => Some(Self::Paperclip),
                    "ImageTypeFlask" => Some(Self::Flask),
                    "ImageTypeEyeglasses" => Some(Self::Eyeglasses),
                    "ImageTypeCupcake" => Some(Self::Cupcake),
                    "ImageTypeSlide" => Some(Self::Slide),
                    "ImageTypeHat" => Some(Self::Hat),
                    "ImageTypeFlower" => Some(Self::Flower),
                    "ImageTypeHeart" => Some(Self::Heart),
                    "ImageTypeMessage" => Some(Self::Message),
                    "ImageTypeAudio" => Some(Self::Audio),
                    "ImageTypeCloud" => Some(Self::Cloud),
                    "ImageTypeExclamation" => Some(Self::Exclamation),
                    _ => None,
                }
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolvedFeatureFlags {
    #[prost(bool, tag = "1")]
    pub content_store_staging_enabled: bool,
    #[prost(bool, tag = "2")]
    pub props_update_enabled: bool,
    #[prost(bool, tag = "3")]
    pub macros_update_enabled: bool,
    #[prost(bool, tag = "4")]
    pub scale_and_blur_enabled: bool,
    #[prost(bool, tag = "5")]
    pub settings_update_enabled: bool,
    #[prost(bool, tag = "6")]
    pub subscription_enabled: bool,
    #[prost(bool, tag = "7")]
    pub core_data_validation_enabled: bool,
    #[prost(bool, tag = "8")]
    pub staging_api_endpoint_enabled: bool,
    #[prost(bool, tag = "9")]
    pub core_slide_rendering: bool,
    #[prost(bool, tag = "10")]
    pub pro_content_staging_enabled: bool,
    #[prost(bool, tag = "11")]
    pub core_networkapi_playlist: bool,
    #[prost(bool, tag = "12")]
    pub core_networkapi_presentation: bool,
    #[prost(bool, tag = "13")]
    pub endpoint_version_1_1_enabled: bool,
    #[prost(bool, tag = "15")]
    pub core_client_sync: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaMetadataRequestInfo {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub time: f32,
    #[prost(uint32, tag = "3")]
    pub width: u32,
    #[prost(uint32, tag = "4")]
    pub height: u32,
    #[prost(message, repeated, tag = "5")]
    pub effects: ::prost::alloc::vec::Vec<Effect>,
    #[prost(message, optional, tag = "6")]
    pub crop_insets: ::core::option::Option<graphics::EdgeInsets>,
    #[prost(enumeration = "media::drawing_properties::NativeRotationType", tag = "7")]
    pub native_rotation: i32,
    #[prost(bool, tag = "8")]
    pub flipped_horizontally: bool,
    #[prost(bool, tag = "9")]
    pub flipped_vertically: bool,
    #[prost(enumeration = "AlphaType", tag = "10")]
    pub alpha_type: i32,
    #[prost(enumeration = "media_metadata_request_info::BufferFormat", tag = "11")]
    pub buffer_format: i32,
}
/// Nested message and enum types in `MediaMetadataRequestInfo`.
pub mod media_metadata_request_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BufferFormat {
        Raw = 0,
        Png = 1,
    }
    impl BufferFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BufferFormat::Raw => "BUFFER_FORMAT_RAW",
                BufferFormat::Png => "BUFFER_FORMAT_PNG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BUFFER_FORMAT_RAW" => Some(Self::Raw),
                "BUFFER_FORMAT_PNG" => Some(Self::Png),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaMetadataRequestResponse {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<media_metadata_request_response::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub generated_bitmap_info: ::core::option::Option<
        media_metadata_request_response::BitmapInfo,
    >,
}
/// Nested message and enum types in `MediaMetadataRequestResponse`.
pub mod media_metadata_request_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metadata {
        #[prost(uint32, tag = "1")]
        pub width: u32,
        #[prost(uint32, tag = "2")]
        pub height: u32,
        #[prost(float, tag = "3")]
        pub fps: f32,
        #[prost(float, tag = "4")]
        pub duration: f32,
        #[prost(uint32, tag = "5")]
        pub number_audio_channels: u32,
        #[prost(string, tag = "6")]
        pub codec: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub artist: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub title: ::prost::alloc::string::String,
        #[prost(float, tag = "9")]
        pub rotation: f32,
        #[prost(enumeration = "metadata::ContentType", tag = "10")]
        pub content_type: i32,
        #[prost(bool, tag = "11")]
        pub has_alpha_channel: bool,
    }
    /// Nested message and enum types in `Metadata`.
    pub mod metadata {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ContentType {
            Unknown = 0,
            Audio = 1,
            Image = 2,
            Video = 3,
        }
        impl ContentType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    ContentType::Unknown => "CONTENT_TYPE_UNKNOWN",
                    ContentType::Audio => "CONTENT_TYPE_AUDIO",
                    ContentType::Image => "CONTENT_TYPE_IMAGE",
                    ContentType::Video => "CONTENT_TYPE_VIDEO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONTENT_TYPE_UNKNOWN" => Some(Self::Unknown),
                    "CONTENT_TYPE_AUDIO" => Some(Self::Audio),
                    "CONTENT_TYPE_IMAGE" => Some(Self::Image),
                    "CONTENT_TYPE_VIDEO" => Some(Self::Video),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BitmapInfo {
        #[prost(uint32, tag = "1")]
        pub width: u32,
        #[prost(uint32, tag = "2")]
        pub height: u32,
        #[prost(uint64, tag = "3")]
        pub size: u64,
    }
}
