// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Looks {
    #[prost(int32, tag = "1")]
    pub number_presets: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Summary {
    #[prost(int32, tag = "1")]
    pub total_screens: i32,
    #[prost(int32, tag = "2")]
    pub audience_screen_count: i32,
    #[prost(int32, tag = "3")]
    pub stage_screen_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Output {
    #[prost(enumeration = "output::ProScreenType", tag = "1")]
    pub proscreen_type: i32,
    #[prost(enumeration = "output::OutputType", tag = "2")]
    pub output_type: i32,
    #[prost(bool, tag = "3")]
    pub color_correction_enabled: bool,
    #[prost(bool, tag = "4")]
    pub corner_pin_enabled: bool,
    #[prost(enumeration = "output::Alignment", tag = "5")]
    pub alignment: i32,
    #[prost(int32, tag = "6")]
    pub width: i32,
    #[prost(int32, tag = "7")]
    pub height: i32,
    #[prost(enumeration = "output::AlphaKeyMode", tag = "8")]
    pub alpha_key_mode: i32,
    #[prost(enumeration = "output::AlphaDevice", tag = "9")]
    pub alpha_device: i32,
}
/// Nested message and enum types in `Output`.
pub mod output {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProScreenType {
        Unknown = 0,
        Single = 1,
        Mirrored = 2,
        EdgeBlend = 3,
        Grouped = 4,
    }
    impl ProScreenType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProScreenType::Unknown => "PRO_SCREEN_TYPE_UNKNOWN",
                ProScreenType::Single => "SINGLE",
                ProScreenType::Mirrored => "MIRRORED",
                ProScreenType::EdgeBlend => "EDGE_BLEND",
                ProScreenType::Grouped => "GROUPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRO_SCREEN_TYPE_UNKNOWN" => Some(Self::Unknown),
                "SINGLE" => Some(Self::Single),
                "MIRRORED" => Some(Self::Mirrored),
                "EDGE_BLEND" => Some(Self::EdgeBlend),
                "GROUPED" => Some(Self::Grouped),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OutputType {
        Unknown = 0,
        Sdi = 1,
        Ndi = 2,
        Syphon = 3,
        System = 4,
        Placeholder = 5,
        Dvi = 6,
    }
    impl OutputType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OutputType::Unknown => "OUTPUT_TYPE_UNKNOWN",
                OutputType::Sdi => "SDI",
                OutputType::Ndi => "NDI",
                OutputType::Syphon => "SYPHON",
                OutputType::System => "SYSTEM",
                OutputType::Placeholder => "PLACEHOLDER",
                OutputType::Dvi => "DVI",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTPUT_TYPE_UNKNOWN" => Some(Self::Unknown),
                "SDI" => Some(Self::Sdi),
                "NDI" => Some(Self::Ndi),
                "SYPHON" => Some(Self::Syphon),
                "SYSTEM" => Some(Self::System),
                "PLACEHOLDER" => Some(Self::Placeholder),
                "DVI" => Some(Self::Dvi),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Alignment {
        Unknown = 0,
        Full = 1,
        _2x1 = 2,
        _3x1 = 3,
        _2x2 = 4,
        Custom = 5,
    }
    impl Alignment {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Alignment::Unknown => "ALIGNMENT_UNKNOWN",
                Alignment::Full => "FULL",
                Alignment::_2x1 => "_2X1",
                Alignment::_3x1 => "_3X1",
                Alignment::_2x2 => "_2X2",
                Alignment::Custom => "CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALIGNMENT_UNKNOWN" => Some(Self::Unknown),
                "FULL" => Some(Self::Full),
                "_2X1" => Some(Self::_2x1),
                "_3X1" => Some(Self::_3x1),
                "_2X2" => Some(Self::_2x2),
                "CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AlphaKeyMode {
        None = 0,
        Premultiplied = 1,
        Straight = 2,
    }
    impl AlphaKeyMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AlphaKeyMode::None => "ALPHA_KEY_MODE_NONE",
                AlphaKeyMode::Premultiplied => "PREMULTIPLIED",
                AlphaKeyMode::Straight => "STRAIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALPHA_KEY_MODE_NONE" => Some(Self::None),
                "PREMULTIPLIED" => Some(Self::Premultiplied),
                "STRAIGHT" => Some(Self::Straight),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AlphaDevice {
        None = 0,
        Self_ = 1,
        Other = 2,
    }
    impl AlphaDevice {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AlphaDevice::None => "ALPHA_DEVICE_NONE",
                AlphaDevice::Self_ => "SELF",
                AlphaDevice::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALPHA_DEVICE_NONE" => Some(Self::None),
                "SELF" => Some(Self::Self_),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Single {
    #[prost(enumeration = "ScreenType", tag = "1")]
    pub screen_type: i32,
    #[prost(bool, tag = "2")]
    pub screen_color_enabled: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mirrored {
    #[prost(enumeration = "ScreenType", tag = "1")]
    pub screen_type: i32,
    #[prost(bool, tag = "2")]
    pub screen_color_enabled: bool,
    #[prost(int32, tag = "3")]
    pub count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EdgeBlend {
    #[prost(enumeration = "ScreenType", tag = "1")]
    pub screen_type: i32,
    #[prost(bool, tag = "2")]
    pub screen_color_enabled: bool,
    #[prost(int32, tag = "3")]
    pub count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Grouped {
    #[prost(enumeration = "ScreenType", tag = "1")]
    pub screen_type: i32,
    #[prost(bool, tag = "2")]
    pub screen_color_enabled: bool,
    #[prost(int32, tag = "3")]
    pub columns: i32,
    #[prost(int32, tag = "4")]
    pub rows: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Preferences {
    #[prost(bool, tag = "1")]
    pub house_of_worship: bool,
    #[prost(bool, tag = "2")]
    pub has_custom_logo: bool,
    #[prost(bool, tag = "3")]
    pub copyright_enabled: bool,
    #[prost(enumeration = "preferences::CopyrightStyle", tag = "4")]
    pub copyright_style: i32,
    #[prost(bool, tag = "5")]
    pub copyright_has_license: bool,
    #[prost(enumeration = "preferences::RenderMode", tag = "6")]
    pub render_mode: i32,
    #[prost(bool, tag = "7")]
    pub suppress_auto_start: bool,
    #[prost(bool, tag = "8")]
    pub manage_media_automatically: bool,
    #[prost(bool, tag = "9")]
    pub search_paths_relink: bool,
    #[prost(enumeration = "preferences::UpdateChannel", tag = "10")]
    pub update_channel: i32,
}
/// Nested message and enum types in `Preferences`.
pub mod preferences {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CopyrightStyle {
        Unknown = 0,
        First = 1,
        Last = 2,
        FirstAndLast = 3,
        AllSlides = 4,
    }
    impl CopyrightStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CopyrightStyle::Unknown => "COPYRIGHT_STYLE_UNKNOWN",
                CopyrightStyle::First => "FIRST",
                CopyrightStyle::Last => "LAST",
                CopyrightStyle::FirstAndLast => "FIRST_AND_LAST",
                CopyrightStyle::AllSlides => "ALL_SLIDES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COPYRIGHT_STYLE_UNKNOWN" => Some(Self::Unknown),
                "FIRST" => Some(Self::First),
                "LAST" => Some(Self::Last),
                "FIRST_AND_LAST" => Some(Self::FirstAndLast),
                "ALL_SLIDES" => Some(Self::AllSlides),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RenderMode {
        Unknown = 0,
        Opengl = 1,
        Metal = 2,
        Directx = 3,
    }
    impl RenderMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RenderMode::Unknown => "RENDER_MODE_UNKNOWN",
                RenderMode::Opengl => "OPENGL",
                RenderMode::Metal => "METAL",
                RenderMode::Directx => "DIRECTX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RENDER_MODE_UNKNOWN" => Some(Self::Unknown),
                "OPENGL" => Some(Self::Opengl),
                "METAL" => Some(Self::Metal),
                "DIRECTX" => Some(Self::Directx),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UpdateChannel {
        Unknown = 0,
        Release = 1,
        Beta = 2,
    }
    impl UpdateChannel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UpdateChannel::Unknown => "UPDATE_CHANNEL_UNKNOWN",
                UpdateChannel::Release => "RELEASE",
                UpdateChannel::Beta => "BETA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UPDATE_CHANNEL_UNKNOWN" => Some(Self::Unknown),
                "RELEASE" => Some(Self::Release),
                "BETA" => Some(Self::Beta),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Screens {
    #[prost(bool, tag = "1")]
    pub show_screens_launch: bool,
    #[prost(bool, tag = "2")]
    pub show_performance_on_screen: bool,
    #[prost(bool, tag = "3")]
    pub ignore_background_colors: bool,
    #[prost(bool, tag = "4")]
    pub show_keynote_ppt_screens: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SongSelect {
    #[prost(bool, tag = "1")]
    pub logged_in: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    #[prost(int32, tag = "1")]
    pub library_count: i32,
    #[prost(int32, tag = "2")]
    pub library_playlist_count: i32,
    #[prost(int32, tag = "3")]
    pub library_playlist_folder_count: i32,
    #[prost(int32, tag = "4")]
    pub library_playlist_max_depth: i32,
    #[prost(int32, tag = "5")]
    pub media_bin_total_playlist_count: i32,
    #[prost(int32, tag = "6")]
    pub media_bin_playlist_folder_count: i32,
    #[prost(int32, tag = "7")]
    pub media_bin_playlist_max_depth: i32,
    #[prost(int32, tag = "8")]
    pub media_bin_normal_playlist_count: i32,
    #[prost(int32, tag = "9")]
    pub media_bin_smart_playlist_count: i32,
    #[prost(int32, tag = "10")]
    pub media_bin_video_input_count: i32,
    #[prost(int32, tag = "11")]
    pub audio_bin_playlist_count: i32,
    #[prost(int32, tag = "12")]
    pub audio_bin_playlist_folder_count: i32,
    #[prost(int32, tag = "13")]
    pub audio_bin_playlist_max_depth: i32,
    #[prost(int32, tag = "14")]
    pub timer_count: i32,
    #[prost(int32, tag = "15")]
    pub messages_count: i32,
    #[prost(int32, tag = "16")]
    pub props_count: i32,
    #[prost(int32, tag = "17")]
    pub props_auto_clear_count: i32,
    #[prost(int32, tag = "18")]
    pub prop_collections_count: i32,
    #[prost(int32, tag = "19")]
    pub prop_collections_single_prop_enabled_count: i32,
    #[prost(int32, tag = "20")]
    pub stage_layout_count: i32,
    #[prost(int32, tag = "21")]
    pub macros_count: i32,
    #[prost(int32, tag = "22")]
    pub macros_collections_count: i32,
    #[prost(int32, tag = "23")]
    pub macros_custom_icons: i32,
    #[prost(bool, tag = "24")]
    pub ubiquitous_show_directory: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Themes {
    #[prost(int32, tag = "1")]
    pub theme_count: i32,
    #[prost(int32, tag = "2")]
    pub theme_folder_count: i32,
    #[prost(int32, tag = "3")]
    pub theme_folder_max_depth: i32,
    #[prost(int32, tag = "4")]
    pub theme_slides_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Macro {
    #[prost(int32, tag = "1")]
    pub trigger_on_startup_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearGroup {
    #[prost(int32, tag = "1")]
    pub clear_group_count: i32,
    #[prost(int32, tag = "2")]
    pub hidden_clear_group_count: i32,
    #[prost(int32, tag = "3")]
    pub default_icon_count: i32,
    #[prost(int32, tag = "4")]
    pub custom_icon_count: i32,
    #[prost(int32, tag = "5")]
    pub icon_tint_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyMapping {
    #[prost(int32, tag = "1")]
    pub total_mapped: i32,
    #[prost(int32, tag = "2")]
    pub clear_groups: i32,
    #[prost(int32, tag = "3")]
    pub groups: i32,
    #[prost(int32, tag = "4")]
    pub macros: i32,
    #[prost(int32, tag = "5")]
    pub props: i32,
    #[prost(int32, tag = "6")]
    pub menus: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkLink {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(uint32, tag = "2")]
    pub member_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Capture {
    #[prost(int32, tag = "1")]
    pub presets_count: i32,
    #[prost(int32, tag = "2")]
    pub disk_presets_count: i32,
    #[prost(int32, tag = "3")]
    pub rtmp_presets_count: i32,
    #[prost(int32, tag = "4")]
    pub resi_presets_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Versioning {
    #[prost(string, tag = "1")]
    pub highest_version: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskUsage {
    #[prost(uint64, tag = "1")]
    pub bytes_of_show_files: u64,
    #[prost(uint64, tag = "2")]
    pub bytes_of_media_asset_files: u64,
    #[prost(uint64, tag = "3")]
    pub number_of_media_asset_files: u64,
    #[prost(uint64, tag = "4")]
    pub bytes_of_unmanaged_media_asset_files: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Interface {
    #[prost(enumeration = "interface::SplitViewState", tag = "1")]
    pub library_outline: i32,
    #[prost(enumeration = "interface::SplitViewState", tag = "2")]
    pub media_outline: i32,
    #[prost(enumeration = "interface::SplitViewState", tag = "3")]
    pub audio_outline: i32,
    #[prost(bool, tag = "4")]
    pub continuous_playlist: bool,
    #[prost(enumeration = "interface::SplitViewState", tag = "5")]
    pub media_bin: i32,
    #[prost(enumeration = "interface::PresentationViewStyle", tag = "6")]
    pub presentation_view_style: i32,
    #[prost(int32, tag = "7")]
    pub presentation_grid_column_count: i32,
    #[prost(enumeration = "interface::MediaBinViewStyle", tag = "8")]
    pub media_bin_view_style: i32,
    #[prost(int32, tag = "9")]
    pub media_bin_grid_column_count: i32,
    #[prost(int32, tag = "10")]
    pub media_bin_table_column_count: i32,
    #[prost(string, tag = "11")]
    pub presentation_transition: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub media_transition: ::prost::alloc::string::String,
    #[prost(bool, tag = "13")]
    pub audio_shuffle: bool,
}
/// Nested message and enum types in `Interface`.
pub mod interface {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SplitViewState {
        Unknown = 0,
        Collapsed = 1,
        Expanded = 2,
    }
    impl SplitViewState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SplitViewState::Unknown => "SPLIT_VIEW_STATE_UNKNOWN",
                SplitViewState::Collapsed => "SPLIT_VIEW_STATE_COLLAPSED",
                SplitViewState::Expanded => "SPLIT_VIEW_STATE_EXPANDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SPLIT_VIEW_STATE_UNKNOWN" => Some(Self::Unknown),
                "SPLIT_VIEW_STATE_COLLAPSED" => Some(Self::Collapsed),
                "SPLIT_VIEW_STATE_EXPANDED" => Some(Self::Expanded),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PresentationViewStyle {
        Unknown = 0,
        Grid = 1,
        Easy = 2,
        Table = 3,
    }
    impl PresentationViewStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PresentationViewStyle::Unknown => "PRESENTATION_VIEW_STYLE_UNKNOWN",
                PresentationViewStyle::Grid => "PRESENTATION_VIEW_STYLE_GRID",
                PresentationViewStyle::Easy => "PRESENTATION_VIEW_STYLE_EASY",
                PresentationViewStyle::Table => "PRESENTATION_VIEW_STYLE_TABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRESENTATION_VIEW_STYLE_UNKNOWN" => Some(Self::Unknown),
                "PRESENTATION_VIEW_STYLE_GRID" => Some(Self::Grid),
                "PRESENTATION_VIEW_STYLE_EASY" => Some(Self::Easy),
                "PRESENTATION_VIEW_STYLE_TABLE" => Some(Self::Table),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaBinViewStyle {
        Unknown = 0,
        Grid = 1,
        Table = 2,
    }
    impl MediaBinViewStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MediaBinViewStyle::Unknown => "MEDIA_BIN_VIEW_STYLE_UNKNOWN",
                MediaBinViewStyle::Grid => "MEDIA_BIN_VIEW_STYLE_GRID",
                MediaBinViewStyle::Table => "MEDIA_BIN_VIEW_STYLE_TABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEDIA_BIN_VIEW_STYLE_UNKNOWN" => Some(Self::Unknown),
                "MEDIA_BIN_VIEW_STYLE_GRID" => Some(Self::Grid),
                "MEDIA_BIN_VIEW_STYLE_TABLE" => Some(Self::Table),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ScreenType {
    Unknown = 0,
    Audience = 1,
    Stage = 2,
}
impl ScreenType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ScreenType::Unknown => "SCREEN_TYPE_UNKNOWN",
            ScreenType::Audience => "AUDIENCE",
            ScreenType::Stage => "STAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCREEN_TYPE_UNKNOWN" => Some(Self::Unknown),
            "AUDIENCE" => Some(Self::Audience),
            "STAGE" => Some(Self::Stage),
            _ => None,
        }
    }
}
