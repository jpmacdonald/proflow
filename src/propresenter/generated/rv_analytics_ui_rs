// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickSearchShown {
    #[prost(enumeration = "quick_search_shown::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `QuickSearchShown`.
pub mod quick_search_shown {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        ApplicationMenu = 1,
        Toolbar = 2,
        UnlinkedHeader = 3,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::ApplicationMenu => "APPLICATION_MENU",
                Source::Toolbar => "TOOLBAR",
                Source::UnlinkedHeader => "UNLINKED_HEADER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "APPLICATION_MENU" => Some(Self::ApplicationMenu),
                "TOOLBAR" => Some(Self::Toolbar),
                "UNLINKED_HEADER" => Some(Self::UnlinkedHeader),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickSearchSearch {
    #[prost(enumeration = "quick_search_search::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `QuickSearchSearch`.
pub mod quick_search_search {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        Library = 1,
        SongSelect = 2,
        MultiTracks = 3,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::Library => "LIBRARY",
                Source::SongSelect => "SONG_SELECT",
                Source::MultiTracks => "MULTI_TRACKS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "LIBRARY" => Some(Self::Library),
                "SONG_SELECT" => Some(Self::SongSelect),
                "MULTI_TRACKS" => Some(Self::MultiTracks),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuickSearchOpenItems {
    #[prost(enumeration = "quick_search_open_items::Source", tag = "1")]
    pub source: i32,
    #[prost(enumeration = "quick_search_open_items::Style", tag = "2")]
    pub style: i32,
    #[prost(int32, tag = "3")]
    pub count: i32,
}
/// Nested message and enum types in `QuickSearchOpenItems`.
pub mod quick_search_open_items {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        Library = 1,
        SongSelect = 2,
        MultiTracks = 3,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::Library => "LIBRARY",
                Source::SongSelect => "SONG_SELECT",
                Source::MultiTracks => "MULTI_TRACKS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "LIBRARY" => Some(Self::Library),
                "SONG_SELECT" => Some(Self::SongSelect),
                "MULTI_TRACKS" => Some(Self::MultiTracks),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Style {
        Unknown = 0,
        ReturnKey = 1,
        CommandReturnKey = 2,
        DragDrop = 3,
    }
    impl Style {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Style::Unknown => "STYLE_UNKNOWN",
                Style::ReturnKey => "STYLE_RETURN_KEY",
                Style::CommandReturnKey => "COMMAND_RETURN_KEY",
                Style::DragDrop => "DRAG_DROP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STYLE_UNKNOWN" => Some(Self::Unknown),
                "STYLE_RETURN_KEY" => Some(Self::ReturnKey),
                "COMMAND_RETURN_KEY" => Some(Self::CommandReturnKey),
                "DRAG_DROP" => Some(Self::DragDrop),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolbarThemeShown {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolbarThemeApplication {
    #[prost(enumeration = "toolbar_theme_application::Target", tag = "1")]
    pub target: i32,
}
/// Nested message and enum types in `ToolbarThemeApplication`.
pub mod toolbar_theme_application {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Target {
        Unknown = 0,
        SlideSelection = 1,
        PresentationSelection = 2,
    }
    impl Target {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Target::Unknown => "TARGET_UNKNOWN",
                Target::SlideSelection => "SLIDE_SELECTION",
                Target::PresentationSelection => "PRESENTATION_SELECTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TARGET_UNKNOWN" => Some(Self::Unknown),
                "SLIDE_SELECTION" => Some(Self::SlideSelection),
                "PRESENTATION_SELECTION" => Some(Self::PresentationSelection),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainViewShow {
    #[prost(enumeration = "main_view_show::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `MainViewShow`.
pub mod main_view_show {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        Toolbar = 1,
        ApplicationMenu = 2,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::Toolbar => "TOOLBAR",
                Source::ApplicationMenu => "APPLICATION_MENU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "APPLICATION_MENU" => Some(Self::ApplicationMenu),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainViewPresentationEditor {
    #[prost(enumeration = "main_view_presentation_editor::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `MainViewPresentationEditor`.
pub mod main_view_presentation_editor {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        Toolbar = 1,
        ApplicationMenu = 2,
        ContextMenu = 3,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::Toolbar => "TOOLBAR",
                Source::ApplicationMenu => "APPLICATION_MENU",
                Source::ContextMenu => "CONTEXT_MENU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "APPLICATION_MENU" => Some(Self::ApplicationMenu),
                "CONTEXT_MENU" => Some(Self::ContextMenu),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainViewReflowEditor {
    #[prost(enumeration = "main_view_reflow_editor::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `MainViewReflowEditor`.
pub mod main_view_reflow_editor {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        Toolbar = 1,
        ApplicationMenu = 2,
        LibraryContextMenu = 3,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::Toolbar => "TOOLBAR",
                Source::ApplicationMenu => "APPLICATION_MENU",
                Source::LibraryContextMenu => "LIBRARY_CONTEXT_MENU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "APPLICATION_MENU" => Some(Self::ApplicationMenu),
                "LIBRARY_CONTEXT_MENU" => Some(Self::LibraryContextMenu),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainViewBible {
    #[prost(enumeration = "main_view_bible::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `MainViewBible`.
pub mod main_view_bible {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        Toolbar = 1,
        ApplicationMenu = 2,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::Toolbar => "TOOLBAR",
                Source::ApplicationMenu => "APPLICATION_MENU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "APPLICATION_MENU" => Some(Self::ApplicationMenu),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BibleTrigger {
    #[prost(enumeration = "Location", tag = "1")]
    pub location: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BibleGenerateSlides {
    #[prost(int32, tag = "1")]
    pub translation_count: i32,
    #[prost(int32, tag = "2")]
    pub slide_count: i32,
    #[prost(enumeration = "bible_generate_slides::TextBoxLocation", tag = "3")]
    pub verse_location: i32,
    #[prost(enumeration = "bible_generate_slides::TextBoxLocation", tag = "4")]
    pub reference_location: i32,
    #[prost(bool, tag = "5")]
    pub show_verse_numbers: bool,
    #[prost(bool, tag = "6")]
    pub break_new_verse: bool,
    #[prost(bool, tag = "7")]
    pub display_translation: bool,
    #[prost(bool, tag = "8")]
    pub preserve_font_color: bool,
    #[prost(enumeration = "bible_generate_slides::ReferenceType", tag = "9")]
    pub reference_style: i32,
}
/// Nested message and enum types in `BibleGenerateSlides`.
pub mod bible_generate_slides {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TextBoxLocation {
        Unknown = 0,
        LocationNone = 1,
        LocationTextBox = 2,
        LocationWithVerse = 3,
    }
    impl TextBoxLocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TextBoxLocation::Unknown => "TEXT_BOX_LOCATION_UNKNOWN",
                TextBoxLocation::LocationNone => "LOCATION_NONE",
                TextBoxLocation::LocationTextBox => "LOCATION_TEXT_BOX",
                TextBoxLocation::LocationWithVerse => "LOCATION_WITH_VERSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TEXT_BOX_LOCATION_UNKNOWN" => Some(Self::Unknown),
                "LOCATION_NONE" => Some(Self::LocationNone),
                "LOCATION_TEXT_BOX" => Some(Self::LocationTextBox),
                "LOCATION_WITH_VERSE" => Some(Self::LocationWithVerse),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReferenceType {
        Unknown = 0,
        PassageNone = 1,
        PassageEach = 2,
        PassageLast = 3,
        Verse = 4,
    }
    impl ReferenceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReferenceType::Unknown => "REFERENCE_TYPE_UNKNOWN",
                ReferenceType::PassageNone => "PASSAGE_NONE",
                ReferenceType::PassageEach => "PASSAGE_EACH",
                ReferenceType::PassageLast => "PASSAGE_LAST",
                ReferenceType::Verse => "VERSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REFERENCE_TYPE_UNKNOWN" => Some(Self::Unknown),
                "PASSAGE_NONE" => Some(Self::PassageNone),
                "PASSAGE_EACH" => Some(Self::PassageEach),
                "PASSAGE_LAST" => Some(Self::PassageLast),
                "VERSE" => Some(Self::Verse),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BibleGenerateNext {
    #[prost(enumeration = "Location", tag = "1")]
    pub location: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BibleGeneratePrevious {
    #[prost(enumeration = "Location", tag = "1")]
    pub location: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BibleSaveSlides {
    #[prost(enumeration = "bible_save_slides::SlideDestination", tag = "1")]
    pub destination: i32,
}
/// Nested message and enum types in `BibleSaveSlides`.
pub mod bible_save_slides {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SlideDestination {
        Unknown = 0,
        SaveToLibrary = 1,
        SaveToPlaylist = 2,
        CopyToPresentation = 3,
    }
    impl SlideDestination {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SlideDestination::Unknown => "SLIDE_DESTINATION_UNKNOWN",
                SlideDestination::SaveToLibrary => "SAVE_TO_LIBRARY",
                SlideDestination::SaveToPlaylist => "SAVE_TO_PLAYLIST",
                SlideDestination::CopyToPresentation => "COPY_TO_PRESENTATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SLIDE_DESTINATION_UNKNOWN" => Some(Self::Unknown),
                "SAVE_TO_LIBRARY" => Some(Self::SaveToLibrary),
                "SAVE_TO_PLAYLIST" => Some(Self::SaveToPlaylist),
                "COPY_TO_PRESENTATION" => Some(Self::CopyToPresentation),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BibleLookup {
    #[prost(enumeration = "bible_lookup::Location", tag = "1")]
    pub location: i32,
}
/// Nested message and enum types in `BibleLookup`.
pub mod bible_lookup {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Location {
        Unknown = 0,
        TextReference = 1,
        MenuBook = 2,
        MenuChapter = 3,
        MenuVerse = 4,
        TextSearchChapter = 5,
        TextSearchVerse = 6,
    }
    impl Location {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Location::Unknown => "LOCATION_UNKNOWN",
                Location::TextReference => "TEXT_REFERENCE",
                Location::MenuBook => "MENU_BOOK",
                Location::MenuChapter => "MENU_CHAPTER",
                Location::MenuVerse => "MENU_VERSE",
                Location::TextSearchChapter => "TEXT_SEARCH_CHAPTER",
                Location::TextSearchVerse => "TEXT_SEARCH_VERSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOCATION_UNKNOWN" => Some(Self::Unknown),
                "TEXT_REFERENCE" => Some(Self::TextReference),
                "MENU_BOOK" => Some(Self::MenuBook),
                "MENU_CHAPTER" => Some(Self::MenuChapter),
                "MENU_VERSE" => Some(Self::MenuVerse),
                "TEXT_SEARCH_CHAPTER" => Some(Self::TextSearchChapter),
                "TEXT_SEARCH_VERSE" => Some(Self::TextSearchVerse),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BibleInstall {
    #[prost(int32, tag = "1")]
    pub free_installed_count: i32,
    #[prost(int32, tag = "2")]
    pub purchased_installed_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BibleRemove {
    #[prost(int32, tag = "1")]
    pub free_installed_count: i32,
    #[prost(int32, tag = "2")]
    pub purchased_installed_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BibleStartup {
    #[prost(int32, tag = "1")]
    pub free_installed_count: i32,
    #[prost(int32, tag = "2")]
    pub purchased_installed_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainViewMaskEditor {
    #[prost(enumeration = "main_view_mask_editor::MaskSource", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `MainViewMaskEditor`.
pub mod main_view_mask_editor {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MaskSource {
        Unknown = 0,
        Toolbar = 1,
        LooksWindow = 2,
    }
    impl MaskSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MaskSource::Unknown => "MASK_SOURCE_UNKNOWN",
                MaskSource::Toolbar => "TOOLBAR",
                MaskSource::LooksWindow => "LOOKS_WINDOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MASK_SOURCE_UNKNOWN" => Some(Self::Unknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "LOOKS_WINDOW" => Some(Self::LooksWindow),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainViewStageEditor {
    #[prost(enumeration = "main_view_stage_editor::StageSource", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `MainViewStageEditor`.
pub mod main_view_stage_editor {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StageSource {
        Unknown = 0,
        Toolbar = 1,
        ApplicationMenu = 2,
        LowerRight = 3,
    }
    impl StageSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StageSource::Unknown => "STAGE_SOURCE_UNKNOWN",
                StageSource::Toolbar => "TOOLBAR",
                StageSource::ApplicationMenu => "APPLICATION_MENU",
                StageSource::LowerRight => "LOWER_RIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STAGE_SOURCE_UNKNOWN" => Some(Self::Unknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "APPLICATION_MENU" => Some(Self::ApplicationMenu),
                "LOWER_RIGHT" => Some(Self::LowerRight),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainViewThemeEditor {
    #[prost(enumeration = "main_view_theme_editor::ThemeSource", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `MainViewThemeEditor`.
pub mod main_view_theme_editor {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ThemeSource {
        StageSourceUnknown = 0,
        Toolbar = 1,
        ThemeContextMenu = 2,
    }
    impl ThemeSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ThemeSource::StageSourceUnknown => "STAGE_SOURCE_UNKNOWN",
                ThemeSource::Toolbar => "TOOLBAR",
                ThemeSource::ThemeContextMenu => "THEME_CONTEXT_MENU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STAGE_SOURCE_UNKNOWN" => Some(Self::StageSourceUnknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "THEME_CONTEXT_MENU" => Some(Self::ThemeContextMenu),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainViewCopyrightEditor {
    #[prost(enumeration = "main_view_copyright_editor::CopyrightSource", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `MainViewCopyrightEditor`.
pub mod main_view_copyright_editor {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CopyrightSource {
        Unknown = 0,
        Toolbar = 1,
        Preference = 2,
    }
    impl CopyrightSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CopyrightSource::Unknown => "COPYRIGHT_SOURCE_UNKNOWN",
                CopyrightSource::Toolbar => "TOOLBAR",
                CopyrightSource::Preference => "PREFERENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COPYRIGHT_SOURCE_UNKNOWN" => Some(Self::Unknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "PREFERENCE" => Some(Self::Preference),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MainViewPropsEditor {
    #[prost(enumeration = "main_view_props_editor::PropsSource", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `MainViewPropsEditor`.
pub mod main_view_props_editor {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PropsSource {
        Unknown = 0,
        Toolbar = 1,
        LowerRight = 2,
    }
    impl PropsSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PropsSource::Unknown => "PROPS_SOURCE_UNKNOWN",
                PropsSource::Toolbar => "TOOLBAR",
                PropsSource::LowerRight => "LOWER_RIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROPS_SOURCE_UNKNOWN" => Some(Self::Unknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "LOWER_RIGHT" => Some(Self::LowerRight),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightTimers {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightTimersCollapse {
    #[prost(enumeration = "lower_right_timers_collapse::State", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `LowerRightTimersCollapse`.
pub mod lower_right_timers_collapse {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unknown = 0,
        Collapsed = 1,
        Expanded = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unknown => "STATE_UNKNOWN",
                State::Collapsed => "COLLAPSED",
                State::Expanded => "EXPANDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNKNOWN" => Some(Self::Unknown),
                "COLLAPSED" => Some(Self::Collapsed),
                "EXPANDED" => Some(Self::Expanded),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightTimersEdit {
    #[prost(enumeration = "lower_right_timers_edit::Field", tag = "1")]
    pub field: i32,
}
/// Nested message and enum types in `LowerRightTimersEdit`.
pub mod lower_right_timers_edit {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Field {
        Unknown = 0,
        Type = 1,
        Value = 2,
        Overrun = 3,
        Name = 4,
    }
    impl Field {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Field::Unknown => "FIELD_UNKNOWN",
                Field::Type => "TYPE",
                Field::Value => "VALUE",
                Field::Overrun => "OVERRUN",
                Field::Name => "NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIELD_UNKNOWN" => Some(Self::Unknown),
                "TYPE" => Some(Self::Type),
                "VALUE" => Some(Self::Value),
                "OVERRUN" => Some(Self::Overrun),
                "NAME" => Some(Self::Name),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightTimersState {
    #[prost(enumeration = "lower_right_timers_state::State", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `LowerRightTimersState`.
pub mod lower_right_timers_state {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unknown = 0,
        Start = 1,
        Stop = 2,
        Reset = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unknown => "STATE_UNKNOWN",
                State::Start => "START",
                State::Stop => "STOP",
                State::Reset => "RESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNKNOWN" => Some(Self::Unknown),
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                "RESET" => Some(Self::Reset),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightTimersCreate {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightTimersDelete {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightMessages {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightMessagesEdit {
    #[prost(enumeration = "lower_right_messages_edit::Action", tag = "1")]
    pub action: i32,
}
/// Nested message and enum types in `LowerRightMessagesEdit`.
pub mod lower_right_messages_edit {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        Unknown = 0,
        AddTextToken = 1,
        AddTimerToken = 2,
        AddCustomToken = 3,
        SetTheme = 4,
        SetText = 5,
        SetWebNotification = 6,
        SetDismissBehavior = 7,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::Unknown => "ACTION_UNKNOWN",
                Action::AddTextToken => "ADD_TEXT_TOKEN",
                Action::AddTimerToken => "ADD_TIMER_TOKEN",
                Action::AddCustomToken => "ADD_CUSTOM_TOKEN",
                Action::SetTheme => "SET_THEME",
                Action::SetText => "SET_TEXT",
                Action::SetWebNotification => "SET_WEB_NOTIFICATION",
                Action::SetDismissBehavior => "SET_DISMISS_BEHAVIOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNKNOWN" => Some(Self::Unknown),
                "ADD_TEXT_TOKEN" => Some(Self::AddTextToken),
                "ADD_TIMER_TOKEN" => Some(Self::AddTimerToken),
                "ADD_CUSTOM_TOKEN" => Some(Self::AddCustomToken),
                "SET_THEME" => Some(Self::SetTheme),
                "SET_TEXT" => Some(Self::SetText),
                "SET_WEB_NOTIFICATION" => Some(Self::SetWebNotification),
                "SET_DISMISS_BEHAVIOR" => Some(Self::SetDismissBehavior),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightMessagesState {
    #[prost(enumeration = "lower_right_messages_state::State", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `LowerRightMessagesState`.
pub mod lower_right_messages_state {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unknown = 0,
        Show = 1,
        Clear = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unknown => "STATE_UNKNOWN",
                State::Show => "SHOW",
                State::Clear => "CLEAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNKNOWN" => Some(Self::Unknown),
                "SHOW" => Some(Self::Show),
                "CLEAR" => Some(Self::Clear),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightMessagesCreate {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightMessagesDelete {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightProps {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightPropsTransition {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightPropsCreate {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightPropsDelete {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightPropsState {
    #[prost(enumeration = "lower_right_props_state::State", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `LowerRightPropsState`.
pub mod lower_right_props_state {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unknown = 0,
        Show = 1,
        Clear = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unknown => "STATE_UNKNOWN",
                State::Show => "SHOW",
                State::Clear => "CLEAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNKNOWN" => Some(Self::Unknown),
                "SHOW" => Some(Self::Show),
                "CLEAR" => Some(Self::Clear),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightStage {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightStageChangeLayout {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightStageConfigureScreens {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightStageEditLayouts {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightStageMessageState {
    #[prost(enumeration = "lower_right_stage_message_state::State", tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `LowerRightStageMessageState`.
pub mod lower_right_stage_message_state {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unknown = 0,
        Show = 1,
        Clear = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unknown => "STATE_UNKNOWN",
                State::Show => "SHOW",
                State::Clear => "CLEAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNKNOWN" => Some(Self::Unknown),
                "SHOW" => Some(Self::Show),
                "CLEAR" => Some(Self::Clear),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightMacros {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightMacrosTrigger {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightMacrosCreate {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LowerRightMacrosDelete {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInspector {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInspectorScrollingText {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInspectorForeground {
    #[prost(enumeration = "text_inspector_foreground::FillType", tag = "1")]
    pub fill_type: i32,
    #[prost(enumeration = "SelectionMode", tag = "2")]
    pub selection_mode: i32,
}
/// Nested message and enum types in `TextInspectorForeground`.
pub mod text_inspector_foreground {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FillType {
        Unknown = 0,
        Solid = 1,
        Gradient = 2,
    }
    impl FillType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FillType::Unknown => "FILL_TYPE_UNKNOWN",
                FillType::Solid => "SOLID",
                FillType::Gradient => "GRADIENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FILL_TYPE_UNKNOWN" => Some(Self::Unknown),
                "SOLID" => Some(Self::Solid),
                "GRADIENT" => Some(Self::Gradient),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInspectorUnderlineColor {
    #[prost(bool, tag = "1")]
    pub is_enabled: bool,
    #[prost(enumeration = "SelectionMode", tag = "2")]
    pub selection_mode: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInspectorBackgroundColor {
    #[prost(enumeration = "text_inspector_background_color::ColorType", tag = "1")]
    pub color_type: i32,
    #[prost(enumeration = "SelectionMode", tag = "2")]
    pub selection_mode: i32,
}
/// Nested message and enum types in `TextInspectorBackgroundColor`.
pub mod text_inspector_background_color {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ColorType {
        Unknown = 0,
        Clear = 1,
        Other = 2,
    }
    impl ColorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ColorType::Unknown => "COLOR_TYPE_UNKNOWN",
                ColorType::Clear => "CLEAR",
                ColorType::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COLOR_TYPE_UNKNOWN" => Some(Self::Unknown),
                "CLEAR" => Some(Self::Clear),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextInspectorLineTransform {
    #[prost(enumeration = "text_inspector_line_transform::TransformType", tag = "1")]
    pub transform_type: i32,
}
/// Nested message and enum types in `TextInspectorLineTransform`.
pub mod text_inspector_line_transform {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransformType {
        Unknown = 0,
        None = 1,
        RemoveLineReturns = 2,
        ReplaceLineReturns = 3,
        OneWordPerLine = 4,
        OneCharacterPerLine = 5,
    }
    impl TransformType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TransformType::Unknown => "TRANSFORM_TYPE_UNKNOWN",
                TransformType::None => "NONE",
                TransformType::RemoveLineReturns => "REMOVE_LINE_RETURNS",
                TransformType::ReplaceLineReturns => "REPLACE_LINE_RETURNS",
                TransformType::OneWordPerLine => "ONE_WORD_PER_LINE",
                TransformType::OneCharacterPerLine => "ONE_CHARACTER_PER_LINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSFORM_TYPE_UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "REMOVE_LINE_RETURNS" => Some(Self::RemoveLineReturns),
                "REPLACE_LINE_RETURNS" => Some(Self::ReplaceLineReturns),
                "ONE_WORD_PER_LINE" => Some(Self::OneWordPerLine),
                "ONE_CHARACTER_PER_LINE" => Some(Self::OneCharacterPerLine),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowSlideLabel {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowSlideLabelChange {
    #[prost(int32, tag = "1")]
    pub number_of_slides: i32,
    #[prost(enumeration = "show_slide_label_change::Source", tag = "2")]
    pub source: i32,
}
/// Nested message and enum types in `ShowSlideLabelChange`.
pub mod show_slide_label_change {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        ContextMenu = 1,
        Popover = 2,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::ContextMenu => "CONTEXT_MENU",
                Source::Popover => "POPOVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "CONTEXT_MENU" => Some(Self::ContextMenu),
                "POPOVER" => Some(Self::Popover),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditorOverlayShown {
    #[prost(enumeration = "editor_overlay_shown::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `EditorOverlayShown`.
pub mod editor_overlay_shown {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        DoubleClick = 1,
        ContextualMenu = 2,
        PlusButtonMenu = 3,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::DoubleClick => "DOUBLE_CLICK",
                Source::ContextualMenu => "CONTEXTUAL_MENU",
                Source::PlusButtonMenu => "PLUS_BUTTON_MENU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "DOUBLE_CLICK" => Some(Self::DoubleClick),
                "CONTEXTUAL_MENU" => Some(Self::ContextualMenu),
                "PLUS_BUTTON_MENU" => Some(Self::PlusButtonMenu),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditorOverlayClosed {
    #[prost(enumeration = "editor_overlay_closed::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `EditorOverlayClosed`.
pub mod editor_overlay_closed {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        ClickOffElement = 1,
        EscapeKey = 2,
        CloseButton = 3,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::ClickOffElement => "CLICK_OFF_ELEMENT",
                Source::EscapeKey => "ESCAPE_KEY",
                Source::CloseButton => "CLOSE_BUTTON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "CLICK_OFF_ELEMENT" => Some(Self::ClickOffElement),
                "ESCAPE_KEY" => Some(Self::EscapeKey),
                "CLOSE_BUTTON" => Some(Self::CloseButton),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WhatsNewViewed {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub view_time: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearGroups {
    #[prost(enumeration = "clear_groups::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `ClearGroups`.
pub mod clear_groups {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        ApplicationMenu = 1,
        PreviewMenu = 2,
        ActionMenu = 3,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::ApplicationMenu => "APPLICATION_MENU",
                Source::PreviewMenu => "PREVIEW_MENU",
                Source::ActionMenu => "ACTION_MENU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "APPLICATION_MENU" => Some(Self::ApplicationMenu),
                "PREVIEW_MENU" => Some(Self::PreviewMenu),
                "ACTION_MENU" => Some(Self::ActionMenu),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearGroupsCreate {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearGroupsDelete {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearGroupsChangeVisibility {
    #[prost(enumeration = "clear_groups_change_visibility::Visibility", tag = "1")]
    pub visibility: i32,
}
/// Nested message and enum types in `ClearGroupsChangeVisibility`.
pub mod clear_groups_change_visibility {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Visibility {
        Unknown = 0,
        Shown = 1,
        Hidden = 2,
    }
    impl Visibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Visibility::Unknown => "VISIBILITY_UNKNOWN",
                Visibility::Shown => "SHOWN",
                Visibility::Hidden => "HIDDEN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VISIBILITY_UNKNOWN" => Some(Self::Unknown),
                "SHOWN" => Some(Self::Shown),
                "HIDDEN" => Some(Self::Hidden),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearGroupsChangeIcon {
    #[prost(enumeration = "clear_groups_change_icon::IconType", tag = "1")]
    pub icon_type: i32,
    #[prost(bool, tag = "2")]
    pub is_tinted: bool,
}
/// Nested message and enum types in `ClearGroupsChangeIcon`.
pub mod clear_groups_change_icon {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IconType {
        Unknown = 0,
        Default = 1,
        Custom = 2,
    }
    impl IconType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IconType::Unknown => "ICON_TYPE_UNKNOWN",
                IconType::Default => "DEFAULT",
                IconType::Custom => "CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ICON_TYPE_UNKNOWN" => Some(Self::Unknown),
                "DEFAULT" => Some(Self::Default),
                "CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewAreaClearGroupsTrigger {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewAreaClearGroupsChanged {
    #[prost(int32, tag = "1")]
    pub count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaceholderLink {
    #[prost(enumeration = "placeholder_link::Type", tag = "1")]
    pub link_type: i32,
    #[prost(enumeration = "placeholder_link::Source", tag = "2")]
    pub link_source: i32,
}
/// Nested message and enum types in `PlaceholderLink`.
pub mod placeholder_link {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Presentation = 1,
        Media = 2,
        ExternalPresentation = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unknown => "TYPE_UNKNOWN",
                Type::Presentation => "PRESENTATION",
                Type::Media => "MEDIA",
                Type::ExternalPresentation => "EXTERNAL_PRESENTATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "PRESENTATION" => Some(Self::Presentation),
                "MEDIA" => Some(Self::Media),
                "EXTERNAL_PRESENTATION" => Some(Self::ExternalPresentation),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        QuickSearch = 1,
        ImportButton = 2,
        CreateButton = 3,
        DragDrop = 4,
        Automatic = 5,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::QuickSearch => "QUICK_SEARCH",
                Source::ImportButton => "IMPORT_BUTTON",
                Source::CreateButton => "CREATE_BUTTON",
                Source::DragDrop => "DRAG_DROP",
                Source::Automatic => "AUTOMATIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "QUICK_SEARCH" => Some(Self::QuickSearch),
                "IMPORT_BUTTON" => Some(Self::ImportButton),
                "CREATE_BUTTON" => Some(Self::CreateButton),
                "DRAG_DROP" => Some(Self::DragDrop),
                "AUTOMATIC" => Some(Self::Automatic),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaceholderUnlink {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlanningCenterLive {
    #[prost(enumeration = "planning_center_live::WindowType", tag = "1")]
    pub window_type: i32,
}
/// Nested message and enum types in `PlanningCenterLive`.
pub mod planning_center_live {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WindowType {
        Unknown = 0,
        Docked = 1,
        Floating = 2,
    }
    impl WindowType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WindowType::Unknown => "WINDOW_TYPE_UNKNOWN",
                WindowType::Docked => "DOCKED",
                WindowType::Floating => "FLOATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WINDOW_TYPE_UNKNOWN" => Some(Self::Unknown),
                "DOCKED" => Some(Self::Docked),
                "FLOATING" => Some(Self::Floating),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkGroupAdd {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkGroupRemove {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkGroupLeave {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcliReportReset {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcliReportShown {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Capture {
    #[prost(enumeration = "capture::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `Capture`.
pub mod capture {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        Unknown = 0,
        Toolbar = 1,
        ActionPopover = 2,
        ActionContextualMenu = 3,
        Calendar = 4,
        PreferencesResi = 5,
        MainMenu = 6,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::Unknown => "SOURCE_UNKNOWN",
                Source::Toolbar => "TOOLBAR",
                Source::ActionPopover => "ACTION_POPOVER",
                Source::ActionContextualMenu => "ACTION_CONTEXTUAL_MENU",
                Source::Calendar => "CALENDAR",
                Source::PreferencesResi => "PREFERENCES_RESI",
                Source::MainMenu => "MAIN_MENU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_UNKNOWN" => Some(Self::Unknown),
                "TOOLBAR" => Some(Self::Toolbar),
                "ACTION_POPOVER" => Some(Self::ActionPopover),
                "ACTION_CONTEXTUAL_MENU" => Some(Self::ActionContextualMenu),
                "CALENDAR" => Some(Self::Calendar),
                "PREFERENCES_RESI" => Some(Self::PreferencesResi),
                "MAIN_MENU" => Some(Self::MainMenu),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Welcome {
    #[prost(enumeration = "welcome::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `Welcome`.
pub mod welcome {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        FirstLaunch = 0,
        ApplicationMenu = 1,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::FirstLaunch => "FIRST_LAUNCH",
                Source::ApplicationMenu => "APPLICATION_MENU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIRST_LAUNCH" => Some(Self::FirstLaunch),
                "APPLICATION_MENU" => Some(Self::ApplicationMenu),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WelcomeScreenConfigurationHelp {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WelcomeDownloadSampleContent {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WelcomeUserGroup {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WelcomeTutorials {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WelcomeKnowledgeBase {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WelcomeBlog {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WelcomeInstagram {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WelcomeFacebook {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WelcomeMigration {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPatterns {
    #[prost(enumeration = "test_patterns::Source", tag = "1")]
    pub source: i32,
}
/// Nested message and enum types in `TestPatterns`.
pub mod test_patterns {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        ApplicationMenu = 0,
        ScreenConfiguration = 1,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::ApplicationMenu => "APPLICATION_MENU",
                Source::ScreenConfiguration => "SCREEN_CONFIGURATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPLICATION_MENU" => Some(Self::ApplicationMenu),
                "SCREEN_CONFIGURATION" => Some(Self::ScreenConfiguration),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingsCustomLogo {
    #[prost(bool, tag = "1")]
    pub has_logo: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowedOutputCreated {
    #[prost(enumeration = "windowed_output_created::ScreenType", tag = "1")]
    pub screen_type: i32,
    #[prost(int32, tag = "2")]
    pub num_active_windowed_outputs: i32,
}
/// Nested message and enum types in `WindowedOutputCreated`.
pub mod windowed_output_created {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScreenType {
        Audience = 0,
        Stage = 1,
    }
    impl ScreenType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ScreenType::Audience => "AUDIENCE",
                ScreenType::Stage => "STAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIENCE" => Some(Self::Audience),
                "STAGE" => Some(Self::Stage),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Location {
    Unknown = 0,
    Presentation = 1,
    BibleModule = 2,
}
impl Location {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Location::Unknown => "LOCATION_UNKNOWN",
            Location::Presentation => "PRESENTATION",
            Location::BibleModule => "BIBLE_MODULE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOCATION_UNKNOWN" => Some(Self::Unknown),
            "PRESENTATION" => Some(Self::Presentation),
            "BIBLE_MODULE" => Some(Self::BibleModule),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SelectionMode {
    Unknown = 0,
    Object = 1,
    Range = 2,
}
impl SelectionMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SelectionMode::Unknown => "SELECTION_MODE_UNKNOWN",
            SelectionMode::Object => "OBJECT",
            SelectionMode::Range => "RANGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SELECTION_MODE_UNKNOWN" => Some(Self::Unknown),
            "OBJECT" => Some(Self::Object),
            "RANGE" => Some(Self::Range),
            _ => None,
        }
    }
}
