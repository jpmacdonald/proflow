// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionCaptureStart {
    #[prost(enumeration = "action_capture_start::PresetType", tag = "1")]
    pub preset_type: i32,
}
/// Nested message and enum types in `ActionCaptureStart`.
pub mod action_capture_start {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PresetType {
        Unknown = 0,
        ActiveSettings = 1,
        CapturePreset = 2,
    }
    impl PresetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PresetType::Unknown => "UNKNOWN",
                PresetType::ActiveSettings => "ACTIVE_SETTINGS",
                PresetType::CapturePreset => "CAPTURE_PRESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "ACTIVE_SETTINGS" => Some(Self::ActiveSettings),
                "CAPTURE_PRESET" => Some(Self::CapturePreset),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionCaptureStop {
    #[prost(bool, tag = "1")]
    pub confirm_before_stopping: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionClear {
    #[prost(enumeration = "action_clear::Type", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `ActionClear`.
pub mod action_clear {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Audio = 1,
        Messages = 2,
        Props = 3,
        Announcements = 4,
        Slide = 5,
        Media = 6,
        VideoInput = 7,
        ClearToLogo = 8,
        ClearGroup = 9,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unknown => "UNKNOWN",
                Type::Audio => "AUDIO",
                Type::Messages => "MESSAGES",
                Type::Props => "PROPS",
                Type::Announcements => "ANNOUNCEMENTS",
                Type::Slide => "SLIDE",
                Type::Media => "MEDIA",
                Type::VideoInput => "VIDEO_INPUT",
                Type::ClearToLogo => "CLEAR_TO_LOGO",
                Type::ClearGroup => "CLEAR_GROUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "AUDIO" => Some(Self::Audio),
                "MESSAGES" => Some(Self::Messages),
                "PROPS" => Some(Self::Props),
                "ANNOUNCEMENTS" => Some(Self::Announcements),
                "SLIDE" => Some(Self::Slide),
                "MEDIA" => Some(Self::Media),
                "VIDEO_INPUT" => Some(Self::VideoInput),
                "CLEAR_TO_LOGO" => Some(Self::ClearToLogo),
                "CLEAR_GROUP" => Some(Self::ClearGroup),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionClearGroup {
    #[prost(bool, tag = "1")]
    pub layer_audio: bool,
    #[prost(bool, tag = "2")]
    pub layer_messages: bool,
    #[prost(bool, tag = "3")]
    pub layer_props: bool,
    #[prost(bool, tag = "4")]
    pub layer_announcement: bool,
    #[prost(bool, tag = "5")]
    pub layer_slide: bool,
    #[prost(bool, tag = "6")]
    pub layer_media: bool,
    #[prost(bool, tag = "7")]
    pub layer_video_input: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionCommunications {}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionLook {
    #[prost(int32, tag = "1")]
    pub total_screen_count: i32,
    #[prost(enumeration = "action_look::Setting", tag = "2")]
    pub mask: i32,
    #[prost(enumeration = "action_look::Setting", tag = "3")]
    pub messages: i32,
    #[prost(enumeration = "action_look::Setting", tag = "4")]
    pub props: i32,
    #[prost(enumeration = "action_look::Setting", tag = "5")]
    pub announcements: i32,
    #[prost(enumeration = "action_look::Setting", tag = "6")]
    pub presentation_theme: i32,
    #[prost(enumeration = "action_look::Setting", tag = "7")]
    pub slide: i32,
    #[prost(enumeration = "action_look::Setting", tag = "8")]
    pub media: i32,
    #[prost(enumeration = "action_look::Setting", tag = "9")]
    pub video_input: i32,
}
/// Nested message and enum types in `ActionLook`.
pub mod action_look {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Setting {
        None = 0,
        Some = 1,
        All = 2,
    }
    impl Setting {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Setting::None => "NONE",
                Setting::Some => "SOME",
                Setting::All => "ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "SOME" => Some(Self::Some),
                "ALL" => Some(Self::All),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionMacro {
    #[prost(int32, tag = "1")]
    pub action_count: i32,
    #[prost(int32, tag = "2")]
    pub cue_action_count: i32,
    #[prost(int32, tag = "3")]
    pub total_action_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionMessage {
    #[prost(int32, tag = "1")]
    pub token_count: i32,
    #[prost(int32, tag = "2")]
    pub text_token_count: i32,
    #[prost(int32, tag = "3")]
    pub timer_token_count: i32,
    #[prost(int32, tag = "4")]
    pub clock_token_count: i32,
    #[prost(int32, tag = "5")]
    pub showing_count: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionProp {
    #[prost(string, tag = "1")]
    pub transition: ::prost::alloc::string::String,
    #[prost(enumeration = "action_prop::Type", tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "action_prop::AutoClear", tag = "3")]
    pub auto_clear: i32,
}
/// Nested message and enum types in `ActionProp`.
pub mod action_prop {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Trigger = 1,
        Clear = 2,
        TriggerFromPropBin = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unknown => "TYPE_UNKNOWN",
                Type::Trigger => "TRIGGER",
                Type::Clear => "CLEAR",
                Type::TriggerFromPropBin => "TRIGGER_FROM_PROP_BIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::Unknown),
                "TRIGGER" => Some(Self::Trigger),
                "CLEAR" => Some(Self::Clear),
                "TRIGGER_FROM_PROP_BIN" => Some(Self::TriggerFromPropBin),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AutoClear {
        Unknown = 0,
        DefaultDisabled = 1,
        DefaultEnabled = 2,
        Disabled = 3,
        Enabled = 4,
        DisabledOverride = 5,
        EnabledOverride = 6,
        ClearAction = 7,
    }
    impl AutoClear {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AutoClear::Unknown => "UNKNOWN",
                AutoClear::DefaultDisabled => "DEFAULT_DISABLED",
                AutoClear::DefaultEnabled => "DEFAULT_ENABLED",
                AutoClear::Disabled => "DISABLED",
                AutoClear::Enabled => "ENABLED",
                AutoClear::DisabledOverride => "DISABLED_OVERRIDE",
                AutoClear::EnabledOverride => "ENABLED_OVERRIDE",
                AutoClear::ClearAction => "CLEAR_ACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "DEFAULT_DISABLED" => Some(Self::DefaultDisabled),
                "DEFAULT_ENABLED" => Some(Self::DefaultEnabled),
                "DISABLED" => Some(Self::Disabled),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED_OVERRIDE" => Some(Self::DisabledOverride),
                "ENABLED_OVERRIDE" => Some(Self::EnabledOverride),
                "CLEAR_ACTION" => Some(Self::ClearAction),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionSlideDestination {
    #[prost(enumeration = "action_slide_destination::ChangeSlideDestination", tag = "1")]
    pub change_slide_destination: i32,
}
/// Nested message and enum types in `ActionSlideDestination`.
pub mod action_slide_destination {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeSlideDestination {
        Unknown = 0,
        NoChange = 1,
        StageOnly = 2,
        StageAudience = 3,
    }
    impl ChangeSlideDestination {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChangeSlideDestination::Unknown => "UNKNOWN",
                ChangeSlideDestination::NoChange => "NO_CHANGE",
                ChangeSlideDestination::StageOnly => "STAGE_ONLY",
                ChangeSlideDestination::StageAudience => "STAGE_AUDIENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "NO_CHANGE" => Some(Self::NoChange),
                "STAGE_ONLY" => Some(Self::StageOnly),
                "STAGE_AUDIENCE" => Some(Self::StageAudience),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionStage {
    #[prost(int32, tag = "1")]
    pub layouts: i32,
    #[prost(int32, tag = "2")]
    pub total_stage_screens: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionTimer {
    #[prost(enumeration = "action_timer::Type", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `ActionTimer`.
pub mod action_timer {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        StartSetConfiguration = 1,
        Start = 2,
        Stop = 3,
        Reset = 4,
        StopSetConfiguration = 5,
        Increment = 6,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unknown => "UNKNOWN",
                Type::StartSetConfiguration => "START_SET_CONFIGURATION",
                Type::Start => "START",
                Type::Stop => "STOP",
                Type::Reset => "RESET",
                Type::StopSetConfiguration => "STOP_SET_CONFIGURATION",
                Type::Increment => "INCREMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "START_SET_CONFIGURATION" => Some(Self::StartSetConfiguration),
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                "RESET" => Some(Self::Reset),
                "STOP_SET_CONFIGURATION" => Some(Self::StopSetConfiguration),
                "INCREMENT" => Some(Self::Increment),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPattern {
    #[prost(enumeration = "test_pattern::Pattern", tag = "1")]
    pub pattern: i32,
    #[prost(enumeration = "test_pattern::Logo", tag = "2")]
    pub logo: i32,
}
/// Nested message and enum types in `TestPattern`.
pub mod test_pattern {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Pattern {
        AudioVideoSync = 0,
        BlendGrid = 1,
        ColorBars = 2,
        CustomColors = 3,
        Focus = 4,
        GrayScale = 5,
        Lines = 6,
        LogoBounce = 7,
        Radar = 8,
        Text = 9,
    }
    impl Pattern {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Pattern::AudioVideoSync => "AUDIO_VIDEO_SYNC",
                Pattern::BlendGrid => "BLEND_GRID",
                Pattern::ColorBars => "COLOR_BARS",
                Pattern::CustomColors => "CUSTOM_COLORS",
                Pattern::Focus => "FOCUS",
                Pattern::GrayScale => "GRAY_SCALE",
                Pattern::Lines => "LINES",
                Pattern::LogoBounce => "LOGO_BOUNCE",
                Pattern::Radar => "RADAR",
                Pattern::Text => "TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIO_VIDEO_SYNC" => Some(Self::AudioVideoSync),
                "BLEND_GRID" => Some(Self::BlendGrid),
                "COLOR_BARS" => Some(Self::ColorBars),
                "CUSTOM_COLORS" => Some(Self::CustomColors),
                "FOCUS" => Some(Self::Focus),
                "GRAY_SCALE" => Some(Self::GrayScale),
                "LINES" => Some(Self::Lines),
                "LOGO_BOUNCE" => Some(Self::LogoBounce),
                "RADAR" => Some(Self::Radar),
                "TEXT" => Some(Self::Text),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Logo {
        None = 0,
        Propresenter = 1,
        Custom = 2,
    }
    impl Logo {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Logo::None => "NONE",
                Logo::Propresenter => "PROPRESENTER",
                Logo::Custom => "CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "PROPRESENTER" => Some(Self::Propresenter),
                "CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
}
